:orphan:

:mod:`jaxlie.manifold._manifold_helpers`
========================================

.. py:module:: jaxlie.manifold._manifold_helpers


Module Contents
---------------


Functions
~~~~~~~~~

.. autoapisummary::

   jaxlie.manifold._manifold_helpers.rplus
   jaxlie.manifold._manifold_helpers.rplus_jacobian_parameters_wrt_delta
   jaxlie.manifold._manifold_helpers.rminus


.. data:: T
   

   

.. function:: rplus(transform: T, delta: hints.TangentVector) -> T

   Manifold right plus.

   Computes ``T_wb = T_wa @ exp(delta)``.

   :param transform: ``T_wa``
   :type transform: T
   :param delta: ``T_ab.log()``
   :type delta: annotations.TangentVector

   :returns: *T* -- ``T_wb``


.. function:: rplus_jacobian_parameters_wrt_delta(transform: MatrixLieGroup) -> jnp.ndarray

   Analytical Jacobians for ``jaxlie.manifold.rplus()``\ , linearized around a zero
   local delta.

   Useful for on-manifold optimization.

   Equivalent to --

   .. code-block::

      def rplus_jacobian_parameters_wrt_delta(transform: MatrixLieGroup) -> jnp.ndarray:
          # Since transform objects are PyTree containers, note that `jacfwd` returns a
          # transformation object itself and that the Jacobian terms corresponding to the
          # parameters are grabbed explicitly.
          return jax.jacfwd(
              jaxlie.manifold.rplus,  # Args are (transform, delta)
              argnums=1,  # Jacobian wrt delta
          )(transform, onp.zeros(transform.tangent_dim)).parameters()

   :param transform: transform
   :type transform: T

   :returns: *jnp.ndarray* -- Jacobian. Shape should be ``(Group.parameters_dim, Group.tangent_dim)``.


.. function:: rminus(a: T, b: T) -> hints.TangentVector

   Manifold right minus.

   Computes ``delta = (T_wa.inverse() @ T_wb).log()``.

   :param a: ``T_wa``
   :type a: T
   :param b: ``T_wb``
   :type b: T

   :returns: *annotations.TangentVector* -- ``T_ab.log()``


