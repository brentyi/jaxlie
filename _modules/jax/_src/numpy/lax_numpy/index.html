

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>jax._src.numpy.lax_numpy &mdash; jaxlie  documentation</title>
  

  
  <link rel="stylesheet" href="../../../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../../../_static/graphviz.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../../../" src="../../../../../_static/documentation_options.js"></script>
        <script src="../../../../../_static/jquery.js"></script>
        <script src="../../../../../_static/underscore.js"></script>
        <script src="../../../../../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../../../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../../../genindex/" />
    <link rel="search" title="Search" href="../../../../../search/" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../../../" class="icon icon-home"> jaxlie
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../search/" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../api/jaxlie/"><code class="xref py py-mod docutils literal notranslate"><span class="pre">jaxlie</span></code></a></li>
</ul>
<p class="caption"><span class="caption-text">Example usage</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../se3_overview/">SE(3) Overview</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../">jaxlie</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../../../" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../../../">Module code</a> &raquo;</li>
        
      <li>jax._src.numpy.lax_numpy</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for jax._src.numpy.lax_numpy</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright 2018 Google LLC</span>
<span class="c1">#</span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1">#</span>
<span class="c1">#     https://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>

<span class="c1"># pytype: skip-file</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Implements the NumPy API, using the primitives in :mod:`jax.lax`.</span>

<span class="sd">NumPy operations are implemented in Python in terms of the primitive operations</span>
<span class="sd">in :mod:`jax.lax`. Since NumPy operations are not primitive and instead are</span>
<span class="sd">implemented in terms of :mod:`jax.lax` operations, we do not need to define</span>
<span class="sd">transformation rules such as gradient or batching rules. Instead,</span>
<span class="sd">transformations for NumPy primitives can be derived from the transformation</span>
<span class="sd">rules for the underlying :code:`lax` primitives.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">builtins</span>
<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">types</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">FrozenSet</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">cast</span>
<span class="kn">from</span> <span class="nn">textwrap</span> <span class="kn">import</span> <span class="n">dedent</span> <span class="k">as</span> <span class="n">_dedent</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">opt_einsum</span>

<span class="kn">import</span> <span class="nn">jax</span>
<span class="kn">from</span> <span class="nn">jax</span> <span class="kn">import</span> <span class="n">jit</span><span class="p">,</span> <span class="n">custom_jvp</span>
<span class="kn">from</span> <span class="nn">.vectorize</span> <span class="kn">import</span> <span class="n">vectorize</span>
<span class="kn">from</span> <span class="nn">.util</span> <span class="kn">import</span> <span class="n">_wraps</span>
<span class="kn">from</span> <span class="nn">jax</span> <span class="kn">import</span> <span class="n">core</span>
<span class="kn">from</span> <span class="nn">jax</span> <span class="kn">import</span> <span class="n">dtypes</span>
<span class="kn">from</span> <span class="nn">jax.core</span> <span class="kn">import</span> <span class="n">UnshapedArray</span><span class="p">,</span> <span class="n">ShapedArray</span><span class="p">,</span> <span class="n">ConcreteArray</span><span class="p">,</span> <span class="n">canonicalize_shape</span>
<span class="kn">from</span> <span class="nn">jax.config</span> <span class="kn">import</span> <span class="n">flags</span><span class="p">,</span> <span class="n">config</span>
<span class="kn">from</span> <span class="nn">jax.interpreters.xla</span> <span class="kn">import</span> <span class="n">DeviceArray</span><span class="p">,</span> <span class="n">_DeviceArray</span><span class="p">,</span> <span class="n">_CppDeviceArray</span>
<span class="kn">from</span> <span class="nn">jax.interpreters.masking</span> <span class="kn">import</span> <span class="n">Poly</span>
<span class="kn">from</span> <span class="nn">jax</span> <span class="kn">import</span> <span class="n">lax</span>
<span class="kn">from</span> <span class="nn">jax._src.lax.lax</span> <span class="kn">import</span> <span class="n">_device_put_raw</span>
<span class="kn">from</span> <span class="nn">jax</span> <span class="kn">import</span> <span class="n">ops</span>
<span class="kn">from</span> <span class="nn">jax._src.util</span> <span class="kn">import</span> <span class="p">(</span><span class="n">partial</span><span class="p">,</span> <span class="n">unzip2</span><span class="p">,</span> <span class="n">prod</span> <span class="k">as</span> <span class="n">_prod</span><span class="p">,</span> <span class="n">subvals</span><span class="p">,</span> <span class="n">safe_zip</span><span class="p">,</span>
                           <span class="n">canonicalize_axis</span> <span class="k">as</span> <span class="n">_canonicalize_axis</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">jax.tree_util</span> <span class="kn">import</span> <span class="n">tree_leaves</span><span class="p">,</span> <span class="n">tree_flatten</span>

<span class="n">FLAGS</span> <span class="o">=</span> <span class="n">flags</span><span class="o">.</span><span class="n">FLAGS</span>
<span class="n">flags</span><span class="o">.</span><span class="n">DEFINE_enum</span><span class="p">(</span>
    <span class="s1">&#39;jax_numpy_rank_promotion&#39;</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">getenv</span><span class="p">(</span><span class="s1">&#39;JAX_NUMPY_RANK_PROMOTION&#39;</span><span class="p">,</span> <span class="s1">&#39;allow&#39;</span><span class="p">),</span>
    <span class="n">enum_values</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;allow&#39;</span><span class="p">,</span> <span class="s1">&#39;warn&#39;</span><span class="p">,</span> <span class="s1">&#39;raise&#39;</span><span class="p">],</span>
    <span class="n">help</span><span class="o">=</span>
    <span class="s1">&#39;Control NumPy-style automatic rank promotion broadcasting &#39;</span>
    <span class="s1">&#39;(&quot;allow&quot;, &quot;warn&quot;, or &quot;raise&quot;).&#39;</span><span class="p">)</span>

<span class="n">newaxis</span> <span class="o">=</span> <span class="kc">None</span>

<span class="c1"># Common docstring additions:</span>

<span class="n">_PRECISION_DOC</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">In addition to the original NumPy arguments listed below, also supports</span>
<span class="s2">``precision`` for extra control over matrix-multiplication precision</span>
<span class="s2">on supported devices. ``precision`` may be set to ``None``, which means</span>
<span class="s2">default precision for the backend, a ``lax.Precision`` enum value</span>
<span class="s2">(``Precision.DEFAULT``, ``Precision.HIGH`` or ``Precision.HIGHEST``) or a tuple</span>
<span class="s2">of two ``lax.Precision`` enums indicating separate precision for each argument.</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="c1"># We replace some builtin names to follow Numpy&#39;s API, so we capture here.</span>
<span class="n">_abs</span> <span class="o">=</span> <span class="n">builtins</span><span class="o">.</span><span class="n">abs</span>
<span class="n">_all</span> <span class="o">=</span> <span class="n">builtins</span><span class="o">.</span><span class="n">all</span>
<span class="n">_any</span> <span class="o">=</span> <span class="n">builtins</span><span class="o">.</span><span class="n">any</span>
<span class="n">_max</span> <span class="o">=</span> <span class="n">builtins</span><span class="o">.</span><span class="n">max</span>
<span class="n">_min</span> <span class="o">=</span> <span class="n">builtins</span><span class="o">.</span><span class="n">min</span>
<span class="n">_sum</span> <span class="o">=</span> <span class="n">builtins</span><span class="o">.</span><span class="n">sum</span>
<span class="n">_divmod</span> <span class="o">=</span> <span class="n">builtins</span><span class="o">.</span><span class="n">divmod</span>

<span class="c1"># NumPy constants</span>

<span class="n">pi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
<span class="n">e</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">e</span>
<span class="n">euler_gamma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">euler_gamma</span>
<span class="n">inf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
<span class="n">NINF</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">NINF</span>
<span class="n">PZERO</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">PZERO</span>
<span class="n">NZERO</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">NZERO</span>
<span class="n">nan</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

<span class="c1"># And some numpy utility functions</span>
<span class="n">set_printoptions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">set_printoptions</span>

<span class="c1"># We want isinstance(x, np.ndarray) checks in user code to work with the our</span>
<span class="c1"># array-like types, including DeviceArray and UnshapedArray (i.e. the abstract</span>
<span class="c1"># array base class). We can override the isinstance behavior directly, without</span>
<span class="c1"># having the complexity of multiple inheritance on those classes, by defining</span>
<span class="c1"># the ndarray class to have a metaclass with special __instancecheck__ behavior.</span>
<span class="n">_arraylike_types</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">UnshapedArray</span><span class="p">,</span> <span class="n">DeviceArray</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">_ArrayMeta</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>  <span class="c1"># type: ignore</span>
  <span class="sd">&quot;&quot;&quot;Metaclass for overriding ndarray isinstance checks.&quot;&quot;&quot;</span>

  <span class="k">def</span> <span class="fm">__instancecheck__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
      <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">instance</span><span class="o">.</span><span class="n">aval</span><span class="p">,</span> <span class="n">_arraylike_types</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
      <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">_arraylike_types</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">ndarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">_ArrayMeta</span><span class="p">):</span>
  <span class="n">dtype</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span>
  <span class="n">shape</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
  <span class="n">size</span><span class="p">:</span> <span class="nb">int</span>

  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">buffer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">strides</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;jax.numpy.ndarray() should not be instantiated explicitly.&quot;</span>
                    <span class="s2">&quot; Use jax.numpy.array, or jax.numpy.zeros instead.&quot;</span><span class="p">)</span>


<span class="n">iscomplexobj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">iscomplexobj</span>

<span class="n">shape</span> <span class="o">=</span> <span class="n">_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span>
<span class="n">ndim</span> <span class="o">=</span> <span class="n">_ndim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span>
<span class="n">size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span>
<span class="n">_dtype</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">result_type</span>

<span class="c1"># At present JAX doesn&#39;t have a reason to distinguish between scalars and arrays</span>
<span class="c1"># in its object system. Further, we want JAX scalars to have the same type</span>
<span class="c1"># promotion behaviors as JAX arrays. Rather than introducing a new type of JAX</span>
<span class="c1"># scalar object with JAX promotion behaviors, instead we make the JAX scalar</span>
<span class="c1"># types return JAX arrays when instantiated.</span>

<span class="k">class</span> <span class="nc">_ScalarMeta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
  <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>

  <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="nb">id</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">other</span>

  <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">return</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span> <span class="o">==</span> <span class="n">other</span><span class="p">)</span>

  <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_make_scalar_type</span><span class="p">(</span><span class="n">np_scalar_type</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">_ScalarMeta</span><span class="p">(</span><span class="n">np_scalar_type</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="p">(</span><span class="nb">object</span><span class="p">,),</span>
                     <span class="p">{</span><span class="s2">&quot;dtype&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">np_scalar_type</span><span class="p">)})</span>

<span class="n">bool_</span> <span class="o">=</span> <span class="n">_make_scalar_type</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span>
<span class="n">uint8</span> <span class="o">=</span> <span class="n">_make_scalar_type</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="n">uint16</span> <span class="o">=</span> <span class="n">_make_scalar_type</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint16</span><span class="p">)</span>
<span class="n">uint32</span> <span class="o">=</span> <span class="n">_make_scalar_type</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span>
<span class="n">uint64</span> <span class="o">=</span> <span class="n">_make_scalar_type</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint64</span><span class="p">)</span>
<span class="n">int8</span> <span class="o">=</span> <span class="n">_make_scalar_type</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
<span class="n">int16</span> <span class="o">=</span> <span class="n">_make_scalar_type</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span>
<span class="n">int32</span> <span class="o">=</span> <span class="n">_make_scalar_type</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
<span class="n">int64</span> <span class="o">=</span> <span class="n">_make_scalar_type</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
<span class="n">bfloat16</span> <span class="o">=</span> <span class="n">_make_scalar_type</span><span class="p">(</span><span class="n">dtypes</span><span class="o">.</span><span class="n">bfloat16</span><span class="p">)</span>
<span class="n">float16</span> <span class="o">=</span> <span class="n">_make_scalar_type</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float16</span><span class="p">)</span>
<span class="n">float32</span> <span class="o">=</span> <span class="n">single</span> <span class="o">=</span> <span class="n">_make_scalar_type</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="n">float64</span> <span class="o">=</span> <span class="n">double</span> <span class="o">=</span> <span class="n">_make_scalar_type</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="n">complex64</span> <span class="o">=</span> <span class="n">csingle</span> <span class="o">=</span> <span class="n">_make_scalar_type</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">)</span>
<span class="n">complex128</span> <span class="o">=</span> <span class="n">cdouble</span> <span class="o">=</span> <span class="n">_make_scalar_type</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>

<span class="n">int_</span> <span class="o">=</span> <span class="n">int32</span> <span class="k">if</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">int_</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span> <span class="k">else</span> <span class="n">int64</span>
<span class="n">float_</span> <span class="o">=</span> <span class="n">float32</span> <span class="k">if</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">float_</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span> <span class="k">else</span> <span class="n">float64</span>
<span class="n">complex_</span> <span class="o">=</span> <span class="n">complex64</span> <span class="k">if</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">complex_</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">complex64</span> <span class="k">else</span> <span class="n">complex128</span>

<span class="n">number</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">number</span>
<span class="n">inexact</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inexact</span>
<span class="n">complexfloating</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">complexfloating</span>
<span class="n">floating</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floating</span>
<span class="n">integer</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span>
<span class="n">signedinteger</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">signedinteger</span>
<span class="n">unsignedinteger</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unsignedinteger</span>

<span class="n">flexible</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flexible</span>
<span class="n">character</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">character</span>
<span class="n">object_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">object_</span>

<span class="n">iinfo</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">iinfo</span>
<span class="n">finfo</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">finfo</span>

<span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span>
<span class="n">can_cast</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">can_cast</span>
<span class="n">issubsctype</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">issubsctype</span>
<span class="n">promote_types</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">promote_types</span>

<span class="n">ComplexWarning</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ComplexWarning</span>

<span class="n">array_str</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array_str</span>
<span class="n">array_repr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array_repr</span>

<span class="n">save</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">save</span>
<span class="n">savez</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">savez</span>
<span class="n">load</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span>


<span class="c1">### utility functions</span>

<span class="n">_DEFAULT_TYPEMAP</span> <span class="o">=</span> <span class="p">{</span>
  <span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">:</span> <span class="n">bool_</span><span class="p">,</span>
  <span class="n">np</span><span class="o">.</span><span class="n">int_</span><span class="p">:</span> <span class="n">int_</span><span class="p">,</span>
  <span class="n">np</span><span class="o">.</span><span class="n">float_</span><span class="p">:</span> <span class="n">float_</span><span class="p">,</span>
  <span class="n">np</span><span class="o">.</span><span class="n">complex_</span><span class="p">:</span> <span class="n">complex_</span>
<span class="p">}</span>

<span class="n">_INT_DTYPES</span> <span class="o">=</span> <span class="p">{</span>
  <span class="mi">16</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">,</span>
  <span class="mi">32</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span>
  <span class="mi">64</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">def</span> <span class="nf">_np_array</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Return a properly-typed numpy array.</span>

<span class="sd">  `_np_array(obj, **kwds)` is equivalent to `np.array(obj, **kwds)`, with the</span>
<span class="sd">  exception that when obj.dtype is not defined and dtype is not specified, it</span>
<span class="sd">  uses Jax&#39;s default dtypes.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
  <span class="n">obj_dtype</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;dtype&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
  <span class="n">arr_dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">type</span>
  <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">obj_dtype</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">arr_dtype</span> <span class="ow">in</span> <span class="n">_DEFAULT_TYPEMAP</span><span class="p">:</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">_DEFAULT_TYPEMAP</span><span class="p">[</span><span class="n">arr_dtype</span><span class="p">])</span>
  <span class="k">return</span> <span class="n">arr</span>

<span class="n">_np_asarray</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">_np_array</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_promote_shapes</span><span class="p">(</span><span class="n">fun_name</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Prepend implicit leading singleton dimensions for Numpy broadcasting.&quot;&quot;&quot;</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">args</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">shapes</span> <span class="o">=</span> <span class="p">[</span><span class="n">shape</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>
    <span class="n">nonscalar_ranks</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">shp</span><span class="p">)</span> <span class="k">for</span> <span class="n">shp</span> <span class="ow">in</span> <span class="n">shapes</span> <span class="k">if</span> <span class="n">shp</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">nonscalar_ranks</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">nonscalar_ranks</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">args</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">if</span> <span class="n">FLAGS</span><span class="o">.</span><span class="n">jax_numpy_rank_promotion</span> <span class="o">!=</span> <span class="s2">&quot;allow&quot;</span><span class="p">:</span>
        <span class="n">_rank_promotion_warning_or_error</span><span class="p">(</span><span class="n">fun_name</span><span class="p">,</span> <span class="n">shapes</span><span class="p">)</span>
      <span class="n">result_rank</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">broadcast_shapes</span><span class="p">(</span><span class="o">*</span><span class="n">shapes</span><span class="p">))</span>
      <span class="k">return</span> <span class="p">[</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">*</span> <span class="p">(</span><span class="n">result_rank</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">shp</span><span class="p">))</span> <span class="o">+</span> <span class="n">shp</span><span class="p">)</span>
              <span class="k">for</span> <span class="n">arg</span><span class="p">,</span> <span class="n">shp</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">shapes</span><span class="p">)]</span>

<span class="k">def</span> <span class="nf">_rank_promotion_warning_or_error</span><span class="p">(</span><span class="n">fun_name</span><span class="p">,</span> <span class="n">shapes</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">FLAGS</span><span class="o">.</span><span class="n">jax_numpy_rank_promotion</span> <span class="o">==</span> <span class="s2">&quot;warn&quot;</span><span class="p">:</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Following NumPy automatic rank promotion for </span><span class="si">{}</span><span class="s2"> on shapes </span><span class="si">{}</span><span class="s2">. &quot;</span>
           <span class="s2">&quot;Set the jax_numpy_rank_promotion config option to &#39;allow&#39; to &quot;</span>
           <span class="s2">&quot;disable this warning; for more information, see &quot;</span>
           <span class="s2">&quot;https://jax.readthedocs.io/en/latest/rank_promotion_warning.html.&quot;</span><span class="p">)</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fun_name</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">shapes</span><span class="p">))))</span>
  <span class="k">elif</span> <span class="n">FLAGS</span><span class="o">.</span><span class="n">jax_numpy_rank_promotion</span> <span class="o">==</span> <span class="s2">&quot;raise&quot;</span><span class="p">:</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Operands could not be broadcast together for </span><span class="si">{}</span><span class="s2"> on shapes </span><span class="si">{}</span><span class="s2"> &quot;</span>
           <span class="s2">&quot;and with the config option jax_numpy_rank_promotion=&#39;raise&#39;. &quot;</span>
           <span class="s2">&quot;For more information, see &quot;</span>
           <span class="s2">&quot;https://jax.readthedocs.io/en/latest/rank_promotion_warning.html.&quot;</span><span class="p">)</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fun_name</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">shapes</span><span class="p">))))</span>

<span class="k">def</span> <span class="nf">_promote_dtypes</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Convenience function to apply Numpy argument dtype promotion.&quot;&quot;&quot;</span>
  <span class="c1"># TODO(dougalm,mattjj): This is a performance bottleneck. Consider memoizing.</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">args</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">to_dtype</span> <span class="o">=</span> <span class="n">result_type</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">lax</span><span class="o">.</span><span class="n">convert_element_type</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">to_dtype</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">_promote_dtypes_inexact</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Convenience function to apply Numpy argument dtype promotion.</span>

<span class="sd">  Promotes arguments to an inexact type.&quot;&quot;&quot;</span>
  <span class="n">to_dtype</span> <span class="o">=</span> <span class="n">_to_inexact_dtype</span><span class="p">(</span><span class="n">result_type</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">))</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">lax</span><span class="o">.</span><span class="n">convert_element_type</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">to_dtype</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">_to_inexact_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Promotes a dtype into an inexact dtype, if it is not already one.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">dtype</span> <span class="k">if</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">inexact</span><span class="p">)</span> <span class="k">else</span> <span class="n">promote_types</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">float_</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_complex_elem_type</span><span class="p">(</span><span class="n">dtype</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Returns the float type of the real/imaginary parts of a complex dtype.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((),</span> <span class="n">dtype</span><span class="p">))</span><span class="o">.</span><span class="n">dtype</span>

<span class="k">def</span> <span class="nf">_result_dtype</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Compute result dtype of applying op to arguments with given dtypes.&quot;&quot;&quot;</span>
  <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">0</span><span class="p">,)</span> <span class="o">*</span> <span class="n">ndim</span><span class="p">(</span><span class="n">arg</span><span class="p">),</span> <span class="n">_dtype</span><span class="p">(</span><span class="n">arg</span><span class="p">))</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>
  <span class="k">return</span> <span class="n">_dtype</span><span class="p">(</span><span class="n">op</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_arraylike</span><span class="p">(</span><span class="n">x</span><span class="p">):</span> <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">)</span> <span class="ow">or</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_check_arraylike</span><span class="p">(</span><span class="n">fun_name</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Check if all args fit JAX&#39;s definition of arraylike (ndarray or scalar).&quot;&quot;&quot;</span>
  <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fun_name</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;fun_name must be a string. Got </span><span class="si">{</span><span class="n">fun_name</span><span class="si">}</span><span class="s2">&quot;</span>
  <span class="k">if</span> <span class="n">_any</span><span class="p">(</span><span class="ow">not</span> <span class="n">_arraylike</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">):</span>
    <span class="n">pos</span><span class="p">,</span> <span class="n">arg</span> <span class="o">=</span> <span class="nb">next</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">arg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">_arraylike</span><span class="p">(</span><span class="n">arg</span><span class="p">))</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> requires ndarray or scalar arguments, got </span><span class="si">{}</span><span class="s2"> at position </span><span class="si">{}</span><span class="s2">.&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fun_name</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">arg</span><span class="p">),</span> <span class="n">pos</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">_check_no_float0s</span><span class="p">(</span><span class="n">fun_name</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Check if none of the args have dtype float0.&quot;&quot;&quot;</span>
  <span class="k">if</span> <span class="n">_any</span><span class="p">(</span><span class="n">dtypes</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="ow">is</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">float0</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
        <span class="sa">f</span><span class="s2">&quot;Called </span><span class="si">{</span><span class="n">fun_name</span><span class="si">}</span><span class="s2"> with a float0 array. &quot;</span>
        <span class="s2">&quot;float0s do not support any operations by design because they &quot;</span>
        <span class="s2">&quot;are not compatible with non-trivial vector spaces. No implicit dtype &quot;</span>
        <span class="s2">&quot;conversion is done. You can use np.zeros_like(arr, dtype=np.float) &quot;</span>
        <span class="s2">&quot;to cast a float0 array to a regular zeros array. </span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="s2">&quot;If you didn&#39;t expect to get a float0 you might have accidentally &quot;</span>
        <span class="s2">&quot;taken a gradient with respect to an integer argument.&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_promote_args</span><span class="p">(</span><span class="n">fun_name</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Convenience function to apply Numpy argument shape and dtype promotion.&quot;&quot;&quot;</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="n">fun_name</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
  <span class="n">_check_no_float0s</span><span class="p">(</span><span class="n">fun_name</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">_promote_shapes</span><span class="p">(</span><span class="n">fun_name</span><span class="p">,</span> <span class="o">*</span><span class="n">_promote_dtypes</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">_promote_args_inexact</span><span class="p">(</span><span class="n">fun_name</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Convenience function to apply Numpy argument shape and dtype promotion.</span>

<span class="sd">  Promotes non-inexact types to an inexact type.&quot;&quot;&quot;</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="n">fun_name</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
  <span class="n">_check_no_float0s</span><span class="p">(</span><span class="n">fun_name</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">_promote_shapes</span><span class="p">(</span><span class="n">fun_name</span><span class="p">,</span> <span class="o">*</span><span class="n">_promote_dtypes_inexact</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">_constant_like</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">const</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">const</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">_dtype</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>

<span class="c1">### implementations of numpy functions in terms of lax</span>

<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fmin</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">fmin</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">where</span><span class="p">((</span><span class="n">x1</span> <span class="o">&lt;</span> <span class="n">x2</span><span class="p">)</span> <span class="o">|</span> <span class="n">isnan</span><span class="p">(</span><span class="n">x2</span><span class="p">),</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span>

<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fmax</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">fmax</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">where</span><span class="p">((</span><span class="n">x1</span> <span class="o">&gt;</span> <span class="n">x2</span><span class="p">)</span> <span class="o">|</span> <span class="n">isnan</span><span class="p">(</span><span class="n">x2</span><span class="p">),</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span>

<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">issubdtype</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">)</span>

<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">isscalar</span><span class="p">(</span><span class="n">element</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">is_python_scalar</span><span class="p">(</span><span class="n">element</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>

<span class="n">iterable</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">iterable</span>

<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">result_type</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">result_type</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_one_to_one_unop</span><span class="p">(</span><span class="n">numpy_fn</span><span class="p">,</span> <span class="n">lax_fn</span><span class="p">,</span> <span class="n">promote_to_inexact</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">lax_doc</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">promote_to_inexact</span><span class="p">:</span>
    <span class="n">fn</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">lax_fn</span><span class="p">(</span><span class="o">*</span><span class="n">_promote_args_inexact</span><span class="p">(</span><span class="n">numpy_fn</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">fn</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">lax_fn</span><span class="p">(</span><span class="o">*</span><span class="n">_promote_args</span><span class="p">(</span><span class="n">numpy_fn</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
  <span class="k">if</span> <span class="n">lax_doc</span><span class="p">:</span>
    <span class="n">doc</span> <span class="o">=</span> <span class="n">_dedent</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lax_fn</span><span class="o">.</span><span class="vm">__doc__</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n\n</span><span class="s1">&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]))</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">_wraps</span><span class="p">(</span><span class="n">numpy_fn</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">doc</span><span class="p">)(</span><span class="n">fn</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">_wraps</span><span class="p">(</span><span class="n">numpy_fn</span><span class="p">)(</span><span class="n">fn</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_one_to_one_binop</span><span class="p">(</span><span class="n">numpy_fn</span><span class="p">,</span> <span class="n">lax_fn</span><span class="p">,</span> <span class="n">promote_to_inexact</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">lax_doc</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">promote_to_inexact</span><span class="p">:</span>
    <span class="n">fn</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">:</span> <span class="n">lax_fn</span><span class="p">(</span><span class="o">*</span><span class="n">_promote_args_inexact</span><span class="p">(</span><span class="n">numpy_fn</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">))</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">fn</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">:</span> <span class="n">lax_fn</span><span class="p">(</span><span class="o">*</span><span class="n">_promote_args</span><span class="p">(</span><span class="n">numpy_fn</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">))</span>
  <span class="k">if</span> <span class="n">lax_doc</span><span class="p">:</span>
    <span class="n">doc</span> <span class="o">=</span> <span class="n">_dedent</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lax_fn</span><span class="o">.</span><span class="vm">__doc__</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n\n</span><span class="s1">&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]))</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">_wraps</span><span class="p">(</span><span class="n">numpy_fn</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">doc</span><span class="p">)(</span><span class="n">fn</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">_wraps</span><span class="p">(</span><span class="n">numpy_fn</span><span class="p">)(</span><span class="n">fn</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_maybe_bool_binop</span><span class="p">(</span><span class="n">numpy_fn</span><span class="p">,</span> <span class="n">lax_fn</span><span class="p">,</span> <span class="n">bool_lax_fn</span><span class="p">,</span> <span class="n">lax_doc</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">fn</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">):</span>
    <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">_promote_args</span><span class="p">(</span><span class="n">numpy_fn</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">lax_fn</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span> <span class="k">if</span> <span class="n">x1</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">bool_</span> <span class="k">else</span> <span class="n">bool_lax_fn</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">_wraps</span><span class="p">(</span><span class="n">numpy_fn</span><span class="p">)(</span><span class="n">fn</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">lax_doc</span><span class="p">:</span>
    <span class="n">doc</span> <span class="o">=</span> <span class="n">_dedent</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lax_fn</span><span class="o">.</span><span class="vm">__doc__</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n\n</span><span class="s1">&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]))</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">_wraps</span><span class="p">(</span><span class="n">numpy_fn</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">doc</span><span class="p">)(</span><span class="n">fn</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">_wraps</span><span class="p">(</span><span class="n">numpy_fn</span><span class="p">)(</span><span class="n">fn</span><span class="p">)</span>

<span class="n">fabs</span> <span class="o">=</span> <span class="n">_one_to_one_unop</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fabs</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">abs</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="n">bitwise_not</span> <span class="o">=</span> <span class="n">_one_to_one_unop</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">bitwise_not</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">bitwise_not</span><span class="p">)</span>
<span class="n">invert</span> <span class="o">=</span> <span class="n">_one_to_one_unop</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">invert</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">bitwise_not</span><span class="p">)</span>
<span class="n">negative</span> <span class="o">=</span> <span class="n">_one_to_one_unop</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">negative</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">neg</span><span class="p">)</span>
<span class="n">positive</span> <span class="o">=</span> <span class="n">_one_to_one_unop</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">positive</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">)</span>

<span class="n">floor</span> <span class="o">=</span> <span class="n">_one_to_one_unop</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">floor</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="n">ceil</span> <span class="o">=</span> <span class="n">_one_to_one_unop</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">ceil</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="n">exp</span> <span class="o">=</span> <span class="n">_one_to_one_unop</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">exp</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="n">log</span> <span class="o">=</span> <span class="n">_one_to_one_unop</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">log</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="n">expm1</span> <span class="o">=</span> <span class="n">_one_to_one_unop</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">expm1</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">expm1</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="n">log1p</span> <span class="o">=</span> <span class="n">_one_to_one_unop</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log1p</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">log1p</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="n">sin</span> <span class="o">=</span> <span class="n">_one_to_one_unop</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">sin</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="n">cos</span> <span class="o">=</span> <span class="n">_one_to_one_unop</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">cos</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="n">tan</span> <span class="o">=</span> <span class="n">_one_to_one_unop</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">tan</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">tan</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="n">arcsin</span> <span class="o">=</span> <span class="n">_one_to_one_unop</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">asin</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="n">arccos</span> <span class="o">=</span> <span class="n">_one_to_one_unop</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">acos</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="n">arctan</span> <span class="o">=</span> <span class="n">_one_to_one_unop</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">atan</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="n">sinh</span> <span class="o">=</span> <span class="n">_one_to_one_unop</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sinh</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">sinh</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="n">cosh</span> <span class="o">=</span> <span class="n">_one_to_one_unop</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cosh</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">cosh</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="n">arcsinh</span> <span class="o">=</span> <span class="n">_one_to_one_unop</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arcsinh</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">asinh</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="n">tanh</span> <span class="o">=</span> <span class="n">_one_to_one_unop</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">tanh</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">tanh</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="n">arcsinh</span> <span class="o">=</span> <span class="n">_one_to_one_unop</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arcsinh</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">asinh</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="n">arctanh</span> <span class="o">=</span> <span class="n">_one_to_one_unop</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arctanh</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">atanh</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="n">sqrt</span> <span class="o">=</span> <span class="n">_one_to_one_unop</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">sqrt</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>


<span class="n">add</span> <span class="o">=</span> <span class="n">_maybe_bool_binop</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">add</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">bitwise_or</span><span class="p">)</span>
<span class="n">bitwise_and</span> <span class="o">=</span> <span class="n">_one_to_one_binop</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">bitwise_and</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">bitwise_and</span><span class="p">)</span>
<span class="n">bitwise_or</span> <span class="o">=</span> <span class="n">_one_to_one_binop</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">bitwise_or</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">bitwise_or</span><span class="p">)</span>
<span class="n">bitwise_xor</span> <span class="o">=</span> <span class="n">_one_to_one_binop</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">bitwise_xor</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">bitwise_xor</span><span class="p">)</span>
<span class="n">left_shift</span> <span class="o">=</span> <span class="n">_one_to_one_binop</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">left_shift</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">shift_left</span><span class="p">)</span>
<span class="n">equal</span> <span class="o">=</span> <span class="n">_one_to_one_binop</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">equal</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">eq</span><span class="p">)</span>
<span class="n">multiply</span> <span class="o">=</span> <span class="n">_maybe_bool_binop</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">mul</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">bitwise_and</span><span class="p">)</span>
<span class="n">not_equal</span> <span class="o">=</span> <span class="n">_one_to_one_binop</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">not_equal</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">ne</span><span class="p">)</span>
<span class="n">subtract</span> <span class="o">=</span> <span class="n">_one_to_one_binop</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">sub</span><span class="p">)</span>
<span class="n">arctan2</span> <span class="o">=</span> <span class="n">_one_to_one_binop</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">atan2</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="n">minimum</span> <span class="o">=</span> <span class="n">_one_to_one_binop</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">min</span><span class="p">)</span>
<span class="n">maximum</span> <span class="o">=</span> <span class="n">_one_to_one_binop</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">max</span><span class="p">)</span>
<span class="n">float_power</span> <span class="o">=</span> <span class="n">_one_to_one_binop</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float_power</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">pow</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="n">nextafter</span> <span class="o">=</span> <span class="n">_one_to_one_binop</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nextafter</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">nextafter</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arccosh</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">arccosh</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="c1"># Note: arccosh is multi-valued for complex input, and lax.acosh uses a different</span>
  <span class="c1"># convention than np.arccosh.</span>
  <span class="n">out</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">acosh</span><span class="p">(</span><span class="o">*</span><span class="n">_promote_args_inexact</span><span class="p">(</span><span class="s2">&quot;arccosh&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
  <span class="k">if</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">):</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">real</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">neg</span><span class="p">(</span><span class="n">out</span><span class="p">),</span> <span class="n">out</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">out</span>

<span class="k">def</span> <span class="nf">_comparison_op</span><span class="p">(</span><span class="n">numpy_fn</span><span class="p">,</span> <span class="n">lax_fn</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">fn</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">):</span>
    <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span> <span class="o">=</span>  <span class="n">_promote_args</span><span class="p">(</span><span class="n">numpy_fn</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span>
    <span class="c1"># Comparison on complex types are defined as a lexicographic ordering on</span>
    <span class="c1"># the (real, imag) pair.</span>
    <span class="k">if</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">_dtype</span><span class="p">(</span><span class="n">x1</span><span class="p">),</span> <span class="n">complexfloating</span><span class="p">):</span>
      <span class="n">rx</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span>
      <span class="n">ry</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="n">rx</span><span class="p">,</span> <span class="n">ry</span><span class="p">),</span> <span class="n">lax_fn</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">x1</span><span class="p">),</span> <span class="n">lax</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">x2</span><span class="p">)),</span>
                        <span class="n">lax_fn</span><span class="p">(</span><span class="n">rx</span><span class="p">,</span> <span class="n">ry</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">lax_fn</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">_wraps</span><span class="p">(</span><span class="n">numpy_fn</span><span class="p">)(</span><span class="n">fn</span><span class="p">)</span>

<span class="n">greater_equal</span> <span class="o">=</span> <span class="n">_comparison_op</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">greater_equal</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">ge</span><span class="p">)</span>
<span class="n">greater</span> <span class="o">=</span> <span class="n">_comparison_op</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">greater</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">gt</span><span class="p">)</span>
<span class="n">less_equal</span> <span class="o">=</span> <span class="n">_comparison_op</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">less_equal</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">le</span><span class="p">)</span>
<span class="n">less</span> <span class="o">=</span> <span class="n">_comparison_op</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">less</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">lt</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_logical_op</span><span class="p">(</span><span class="n">np_op</span><span class="p">,</span> <span class="n">bitwise_op</span><span class="p">):</span>
  <span class="nd">@_wraps</span><span class="p">(</span><span class="n">np_op</span><span class="p">,</span> <span class="n">update_doc</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
  <span class="k">def</span> <span class="nf">op</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="n">zero</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">lax</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(),</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="k">if</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">_dtype</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">bool_</span><span class="p">)</span> <span class="k">else</span> <span class="n">lax</span><span class="o">.</span><span class="n">ne</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">zero</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">args</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">bitwise_op</span><span class="p">(</span><span class="o">*</span><span class="n">_promote_args</span><span class="p">(</span><span class="n">np_op</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">op</span>

<span class="n">logical_and</span> <span class="o">=</span> <span class="n">_logical_op</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">bitwise_and</span><span class="p">)</span>
<span class="n">logical_not</span> <span class="o">=</span> <span class="n">_logical_op</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">bitwise_not</span><span class="p">)</span>
<span class="n">logical_or</span> <span class="o">=</span> <span class="n">_logical_op</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">bitwise_or</span><span class="p">)</span>
<span class="n">logical_xor</span> <span class="o">=</span> <span class="n">_logical_op</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_xor</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">bitwise_xor</span><span class="p">)</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">right_shift</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">right_shift</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">):</span>
  <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">_promote_args</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">right_shift</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span>
  <span class="n">lax_fn</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">shift_right_logical</span> <span class="k">if</span> \
    <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">x1</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">unsignedinteger</span><span class="p">)</span> <span class="k">else</span> <span class="n">lax</span><span class="o">.</span><span class="n">shift_right_arithmetic</span>
  <span class="k">return</span> <span class="n">lax_fn</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">absolute</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s1">&#39;absolute&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
  <span class="n">dt</span> <span class="o">=</span> <span class="n">_dtype</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">x</span> <span class="k">if</span> <span class="n">dt</span> <span class="o">==</span> <span class="n">bool_</span> <span class="ow">or</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">unsignedinteger</span><span class="p">)</span> <span class="k">else</span> <span class="n">lax</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="nb">abs</span> <span class="o">=</span> <span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">)(</span><span class="n">absolute</span><span class="p">)</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">rint</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s1">&#39;rint&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
  <span class="n">dtype</span> <span class="o">=</span> <span class="n">_dtype</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">integer</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">convert_element_type</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">float_</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">complexfloating</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">complex</span><span class="p">(</span><span class="n">rint</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span> <span class="n">rint</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">RoundingMethod</span><span class="o">.</span><span class="n">TO_NEAREST_EVEN</span><span class="p">)</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">sign</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s1">&#39;sign&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
  <span class="n">dtype</span> <span class="o">=</span> <span class="n">_dtype</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">complexfloating</span><span class="p">):</span>
    <span class="n">re</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">complex</span><span class="p">(</span>
      <span class="n">lax</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">where</span><span class="p">(</span><span class="n">re</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">re</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">x</span><span class="p">))),</span> <span class="n">_constant_like</span><span class="p">(</span><span class="n">re</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">copysign</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">copysign</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">):</span>
  <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">_promote_args_inexact</span><span class="p">(</span><span class="s2">&quot;copysign&quot;</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">_dtype</span><span class="p">(</span><span class="n">x1</span><span class="p">),</span> <span class="n">complexfloating</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;copysign does not support complex-valued inputs&quot;</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">where</span><span class="p">(</span><span class="n">signbit</span><span class="p">(</span><span class="n">x2</span><span class="p">),</span> <span class="o">-</span><span class="n">lax</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x1</span><span class="p">),</span> <span class="n">lax</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x1</span><span class="p">))</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">true_divide</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">true_divide</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">):</span>
  <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">_promote_args_inexact</span><span class="p">(</span><span class="s2">&quot;true_divide&quot;</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">div</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span>

<span class="n">divide</span> <span class="o">=</span> <span class="n">true_divide</span>

<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor_divide</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">floor_divide</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">):</span>
  <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">_promote_args</span><span class="p">(</span><span class="s2">&quot;floor_divide&quot;</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span>
  <span class="n">dtype</span> <span class="o">=</span> <span class="n">_dtype</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">integer</span><span class="p">):</span>
    <span class="n">quotient</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">div</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span>
    <span class="n">select</span> <span class="o">=</span> <span class="n">logical_and</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span> <span class="o">!=</span> <span class="n">lax</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">x2</span><span class="p">),</span> <span class="n">lax</span><span class="o">.</span><span class="n">rem</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="c1"># TODO(mattjj): investigate why subtracting a scalar was causing promotion</span>
    <span class="k">return</span> <span class="n">where</span><span class="p">(</span><span class="n">select</span><span class="p">,</span> <span class="n">quotient</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">_dtype</span><span class="p">(</span><span class="n">quotient</span><span class="p">)),</span> <span class="n">quotient</span><span class="p">)</span>
  <span class="k">elif</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">complexfloating</span><span class="p">):</span>
    <span class="n">x1r</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span>
    <span class="n">x1i</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span>
    <span class="n">x2r</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span>
    <span class="n">x2i</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span>
    <span class="n">which</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">ge</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x2r</span><span class="p">),</span> <span class="n">lax</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x2i</span><span class="p">))</span>
    <span class="n">rat1</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">which</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">_const</span><span class="p">(</span><span class="n">x2i</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">lax</span><span class="o">.</span><span class="n">div</span><span class="p">(</span><span class="n">x2r</span><span class="p">,</span> <span class="n">x2i</span><span class="p">))</span>
    <span class="n">rat2</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">which</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">div</span><span class="p">(</span><span class="n">x2i</span><span class="p">,</span> <span class="n">x2r</span><span class="p">),</span> <span class="n">lax</span><span class="o">.</span><span class="n">_const</span><span class="p">(</span><span class="n">x2i</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">div</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">x1r</span><span class="p">,</span> <span class="n">rat1</span><span class="p">),</span> <span class="n">lax</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">x1i</span><span class="p">,</span> <span class="n">rat2</span><span class="p">)),</span>
                            <span class="n">lax</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">x2r</span><span class="p">,</span> <span class="n">rat1</span><span class="p">),</span> <span class="n">lax</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">x2i</span><span class="p">,</span> <span class="n">rat2</span><span class="p">))))</span>
    <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">convert_element_type</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">_float_divmod</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">divmod</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">divmod</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">):</span>
  <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">_promote_args</span><span class="p">(</span><span class="s2">&quot;divmod&quot;</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">_dtype</span><span class="p">(</span><span class="n">x1</span><span class="p">),</span> <span class="n">integer</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">floor_divide</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">),</span> <span class="n">remainder</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">_float_divmod</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_float_divmod</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">):</span>
  <span class="c1"># see float_divmod in floatobject.c of CPython</span>
  <span class="n">mod</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">rem</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span>
  <span class="n">div</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">div</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">mod</span><span class="p">),</span> <span class="n">x2</span><span class="p">)</span>

  <span class="n">ind</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">bitwise_and</span><span class="p">(</span><span class="n">mod</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span> <span class="o">!=</span> <span class="n">lax</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">mod</span><span class="p">))</span>
  <span class="n">mod</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="n">mod</span> <span class="o">+</span> <span class="n">x2</span><span class="p">,</span> <span class="n">mod</span><span class="p">)</span>
  <span class="n">div</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="n">div</span> <span class="o">-</span> <span class="n">_constant_like</span><span class="p">(</span><span class="n">div</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">div</span><span class="p">)</span>

  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">div</span><span class="p">),</span> <span class="n">mod</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">power</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">):</span>
  <span class="c1"># Special case for concrete integer scalars: use binary exponentiation.</span>
  <span class="c1"># Using lax.pow may be imprecise for floating-point values; the goal of this</span>
  <span class="c1"># code path is to make sure we end up with a precise output for the common</span>
  <span class="c1"># pattern ``x ** 2`` or similar.</span>
  <span class="k">try</span><span class="p">:</span>
    <span class="n">x2</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span>
  <span class="k">except</span> <span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">ConcretizationTypeError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
    <span class="k">pass</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">integer_pow</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span>

  <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">_promote_args</span><span class="p">(</span><span class="s2">&quot;power&quot;</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span>
  <span class="n">dtype</span> <span class="o">=</span> <span class="n">_dtype</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">integer</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span>

  <span class="c1"># Integer power =&gt; use binary exponentiation.</span>

  <span class="c1"># TODO(phawkins): add integer pow support to XLA.</span>
  <span class="n">bits</span> <span class="o">=</span> <span class="mi">6</span>  <span class="c1"># Anything more would overflow for any x1 &gt; 1</span>
  <span class="n">acc</span> <span class="o">=</span> <span class="n">ones</span><span class="p">(</span><span class="n">shape</span><span class="p">(</span><span class="n">x1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">bits</span><span class="p">):</span>
    <span class="n">acc</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">bitwise_and</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">_constant_like</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span>
                <span class="n">lax</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">acc</span><span class="p">,</span> <span class="n">x1</span><span class="p">),</span> <span class="n">acc</span><span class="p">)</span>
    <span class="n">x1</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x1</span><span class="p">)</span>
    <span class="n">x2</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">shift_right_logical</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">_constant_like</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">acc</span>


<span class="nd">@custom_jvp</span>
<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logaddexp</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">logaddexp</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">):</span>
  <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">_promote_shapes</span><span class="p">(</span><span class="s2">&quot;logaddexp&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">_promote_dtypes_inexact</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">))</span>
  <span class="n">amax</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span>
  <span class="n">delta</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">isnan</span><span class="p">(</span><span class="n">delta</span><span class="p">),</span>
                    <span class="n">lax</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">),</span>  <span class="c1"># NaNs or infinities of the same sign.</span>
                    <span class="n">lax</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">amax</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">log1p</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">lax</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">delta</span><span class="p">)))))</span>

<span class="nd">@logaddexp</span><span class="o">.</span><span class="n">defjvp</span>
<span class="k">def</span> <span class="nf">_logaddexp_jvp</span><span class="p">(</span><span class="n">primals</span><span class="p">,</span> <span class="n">tangents</span><span class="p">):</span>
  <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">primals</span>
  <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span> <span class="o">=</span> <span class="n">tangents</span>
  <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span> <span class="o">=</span> <span class="n">broadcast_arrays</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">)</span>
  <span class="n">primal_out</span> <span class="o">=</span> <span class="n">logaddexp</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span>
  <span class="n">tangent_out</span> <span class="o">=</span> <span class="p">(</span><span class="n">t1</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="n">_replace_inf</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span> <span class="o">-</span> <span class="n">_replace_inf</span><span class="p">(</span><span class="n">primal_out</span><span class="p">))</span> <span class="o">+</span>
                 <span class="n">t2</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="n">_replace_inf</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span> <span class="o">-</span> <span class="n">_replace_inf</span><span class="p">(</span><span class="n">primal_out</span><span class="p">)))</span>
  <span class="k">return</span> <span class="n">primal_out</span><span class="p">,</span> <span class="n">tangent_out</span>

<span class="k">def</span> <span class="nf">_replace_inf</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">isposinf</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">zeros_like</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span>


<span class="nd">@custom_jvp</span>
<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logaddexp2</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">logaddexp2</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">):</span>
  <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">_promote_shapes</span><span class="p">(</span><span class="s2">&quot;logaddexp2&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">_promote_dtypes_inexact</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">))</span>
  <span class="n">amax</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span>
  <span class="n">delta</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">isnan</span><span class="p">(</span><span class="n">delta</span><span class="p">),</span>
                    <span class="n">lax</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">),</span>  <span class="c1"># NaNs or infinities of the same sign.</span>
                    <span class="n">lax</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">amax</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">div</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">log1p</span><span class="p">(</span><span class="n">exp2</span><span class="p">(</span><span class="o">-</span><span class="n">lax</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">delta</span><span class="p">))),</span>
                                          <span class="n">_constant_like</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="p">)))))</span>
<span class="nd">@logaddexp2</span><span class="o">.</span><span class="n">defjvp</span>
<span class="k">def</span> <span class="nf">_logaddexp2_jvp</span><span class="p">(</span><span class="n">primals</span><span class="p">,</span> <span class="n">tangents</span><span class="p">):</span>
  <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">primals</span>
  <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span> <span class="o">=</span> <span class="n">tangents</span>
  <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span> <span class="o">=</span> <span class="n">broadcast_arrays</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">)</span>
  <span class="n">primal_out</span> <span class="o">=</span> <span class="n">logaddexp2</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span>
  <span class="n">tangent_out</span> <span class="o">=</span> <span class="p">(</span><span class="n">t1</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">**</span> <span class="p">(</span><span class="n">_replace_inf</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span> <span class="o">-</span> <span class="n">_replace_inf</span><span class="p">(</span><span class="n">primal_out</span><span class="p">))</span> <span class="o">+</span>
                 <span class="n">t2</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">**</span> <span class="p">(</span><span class="n">_replace_inf</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span> <span class="o">-</span> <span class="n">_replace_inf</span><span class="p">(</span><span class="n">primal_out</span><span class="p">)))</span>
  <span class="k">return</span> <span class="n">primal_out</span><span class="p">,</span> <span class="n">tangent_out</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">log2</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="n">x</span><span class="p">,</span> <span class="o">=</span> <span class="n">_promote_dtypes_inexact</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">div</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">lax</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">_constant_like</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)))</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">log10</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="n">x</span><span class="p">,</span> <span class="o">=</span> <span class="n">_promote_dtypes_inexact</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">div</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">lax</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">_constant_like</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">10</span><span class="p">)))</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp2</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">exp2</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="n">x</span><span class="p">,</span> <span class="o">=</span> <span class="n">_promote_dtypes_inexact</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">_constant_like</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)),</span> <span class="n">x</span><span class="p">))</span>

<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">signbit</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">signbit</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="n">x</span><span class="p">,</span> <span class="o">=</span> <span class="n">_promote_shapes</span><span class="p">(</span><span class="s2">&quot;signbit&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
  <span class="n">dtype</span> <span class="o">=</span> <span class="n">_dtype</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">integer</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">lt</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">_constant_like</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
  <span class="k">elif</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">bool_</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">full_like</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">bool_</span><span class="p">)</span>
  <span class="k">elif</span> <span class="ow">not</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">floating</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
        <span class="s2">&quot;jax.numpy.signbit is not well defined for </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">dtype</span><span class="p">)</span>

  <span class="c1"># TPU supports BF16 but not S16 types, so as a workaround, convert BF16 to</span>
  <span class="c1"># F32.</span>
  <span class="k">if</span> <span class="n">dtype</span> <span class="o">==</span> <span class="n">bfloat16</span><span class="p">:</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">float32</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">convert_element_type</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">float32</span><span class="p">)</span>

  <span class="n">info</span> <span class="o">=</span> <span class="n">finfo</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">info</span><span class="o">.</span><span class="n">bits</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_INT_DTYPES</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
        <span class="s2">&quot;jax.numpy.signbit only supports 16, 32, and 64-bit types.&quot;</span><span class="p">)</span>
  <span class="n">int_type</span> <span class="o">=</span> <span class="n">_INT_DTYPES</span><span class="p">[</span><span class="n">info</span><span class="o">.</span><span class="n">bits</span><span class="p">]</span>
  <span class="n">x</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">bitcast_convert_type</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">int_type</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">convert_element_type</span><span class="p">(</span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">info</span><span class="o">.</span><span class="n">nexp</span> <span class="o">+</span> <span class="n">info</span><span class="o">.</span><span class="n">nmant</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">trapz</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dx</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s1">&#39;trapz&#39;</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
  <span class="n">y</span> <span class="o">=</span> <span class="n">moveaxis</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">ndim</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
      <span class="n">dx</span> <span class="o">=</span> <span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">dx</span> <span class="o">=</span> <span class="n">moveaxis</span><span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">),</span> <span class="n">axis</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
  <span class="k">return</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">dx</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">trunc</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">trunc</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s1">&#39;trunc&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">where</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">lt</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">_const</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)),</span> <span class="n">ceil</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">floor</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_conv</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">precision</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">_dtype</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">complexfloating</span><span class="p">)</span> <span class="ow">or</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">_dtype</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">complexfloating</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">op</span><span class="si">}</span><span class="s2">() does not support complex inputs&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">ndim</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">ndim</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">op</span><span class="si">}</span><span class="s2">() only support 1-dimensional inputs.&quot;</span><span class="p">)</span>
  <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">_promote_dtypes_inexact</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">op</span><span class="si">}</span><span class="s2">: inputs cannot be empty, got shapes </span><span class="si">{</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

  <span class="n">out_order</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span>
    <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;correlate&quot;</span><span class="p">:</span>
      <span class="n">out_order</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;convolve&#39;</span><span class="p">:</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

  <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;valid&#39;</span><span class="p">:</span>
    <span class="n">padding</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span>
  <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;same&#39;</span><span class="p">:</span>
    <span class="n">padding</span> <span class="o">=</span> <span class="p">[(</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
  <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;full&#39;</span><span class="p">:</span>
    <span class="n">padding</span> <span class="o">=</span> <span class="p">[(</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;mode must be one of [&#39;full&#39;, &#39;same&#39;, &#39;valid&#39;]&quot;</span><span class="p">)</span>

  <span class="n">result</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">conv_general_dilated</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">:],</span> <span class="n">y</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">:],</span> <span class="p">(</span><span class="mi">1</span><span class="p">,),</span>
                                    <span class="n">padding</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="n">precision</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">out_order</span><span class="p">]</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_PRECISION_DOC</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">convolve</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;convolve&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">_conv</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="s1">&#39;convolve&#39;</span><span class="p">,</span> <span class="n">precision</span><span class="p">)</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">correlate</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_PRECISION_DOC</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">correlate</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;valid&#39;</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;correlate&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">_conv</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="s1">&#39;correlate&#39;</span><span class="p">,</span> <span class="n">precision</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_normalize_float</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="n">info</span> <span class="o">=</span> <span class="n">finfo</span><span class="p">(</span><span class="n">_dtype</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
  <span class="n">cond</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">info</span><span class="o">.</span><span class="n">tiny</span>
  <span class="n">x1</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="n">x</span> <span class="o">*</span> <span class="n">lax</span><span class="o">.</span><span class="n">_const</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">info</span><span class="o">.</span><span class="n">nmant</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span>
  <span class="n">x2</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">_const</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="o">-</span><span class="n">info</span><span class="o">.</span><span class="n">nmant</span><span class="p">),</span> <span class="n">lax</span><span class="o">.</span><span class="n">_const</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
  <span class="n">int_type</span> <span class="o">=</span> <span class="n">_INT_DTYPES</span><span class="p">[</span><span class="n">info</span><span class="o">.</span><span class="n">bits</span><span class="p">]</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">bitcast_convert_type</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">int_type</span><span class="p">),</span> <span class="n">x2</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ldexp</span><span class="p">)</span>
<span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">ldexp</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">):</span>
  <span class="n">dtype</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">canonicalize_dtype</span><span class="p">(</span><span class="n">_result_dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ldexp</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">))</span>
  <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">_promote_shapes</span><span class="p">(</span><span class="s2">&quot;ldexp&quot;</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span>
  <span class="n">x1</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">convert_element_type</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>

  <span class="n">info</span> <span class="o">=</span> <span class="n">finfo</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
  <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">info</span><span class="o">.</span><span class="n">nexp</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
  <span class="n">bias</span> <span class="o">=</span> <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">info</span><span class="o">.</span><span class="n">nexp</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span>

  <span class="n">int_type</span> <span class="o">=</span> <span class="n">_INT_DTYPES</span><span class="p">[</span><span class="n">info</span><span class="o">.</span><span class="n">bits</span><span class="p">]</span>

  <span class="n">x</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">_normalize_float</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span>
  <span class="n">x2</span> <span class="o">+=</span> <span class="n">e</span> <span class="o">+</span> <span class="p">((</span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="n">info</span><span class="o">.</span><span class="n">nmant</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">-</span> <span class="n">bias</span>

  <span class="c1"># find underflow/overflow before denormalization</span>
  <span class="n">underflow_cond</span> <span class="o">=</span> <span class="n">x2</span> <span class="o">&lt;</span> <span class="o">-</span><span class="p">(</span><span class="n">bias</span> <span class="o">+</span> <span class="n">info</span><span class="o">.</span><span class="n">nmant</span><span class="p">)</span>
  <span class="n">overflow_cond</span> <span class="o">=</span> <span class="n">x2</span> <span class="o">&gt;</span> <span class="n">bias</span>

  <span class="n">m</span> <span class="o">=</span> <span class="n">ones_like</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

  <span class="c1"># denormals</span>
  <span class="n">cond</span> <span class="o">=</span> <span class="n">x2</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">bias</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="n">x2</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="n">x2</span> <span class="o">+</span> <span class="n">info</span><span class="o">.</span><span class="n">nmant</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span>
  <span class="n">m</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="n">m</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">info</span><span class="o">.</span><span class="n">nmant</span><span class="p">),</span> <span class="n">m</span><span class="p">)</span>

  <span class="n">x2</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">convert_element_type</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
  <span class="n">x</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">mask</span> <span class="o">&lt;&lt;</span> <span class="n">info</span><span class="o">.</span><span class="n">nmant</span><span class="p">)</span>
  <span class="n">x</span> <span class="o">|=</span> <span class="p">((</span><span class="n">lax</span><span class="o">.</span><span class="n">convert_element_type</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">int_type</span><span class="p">)</span> <span class="o">+</span> <span class="n">bias</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">info</span><span class="o">.</span><span class="n">nmant</span><span class="p">)</span>

  <span class="n">x</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">convert_element_type</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span> <span class="o">*</span> <span class="n">lax</span><span class="o">.</span><span class="n">bitcast_convert_type</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>

  <span class="c1"># underflow</span>
  <span class="n">x</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">underflow_cond</span><span class="p">,</span> <span class="n">zeros_like</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span>
  <span class="c1"># overflow</span>
  <span class="n">x</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">overflow_cond</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span> <span class="o">*</span> <span class="n">full_like</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span>
  <span class="c1"># ldexp(x1, x2) = x1 for x1 = inf, -inf, nan, 0</span>
  <span class="k">return</span> <span class="n">where</span><span class="p">(</span><span class="n">isinf</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span> <span class="o">|</span> <span class="n">isnan</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">x1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">),</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">frexp</span><span class="p">)</span>
<span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">frexp</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="n">x</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">complexfloating</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;frexp does not support complex-valued inputs&quot;</span><span class="p">)</span>
  <span class="k">elif</span> <span class="ow">not</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">floating</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">convert_element_type</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">float_</span><span class="p">)</span>

  <span class="n">dtype</span> <span class="o">=</span> <span class="n">_dtype</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="n">info</span> <span class="o">=</span> <span class="n">finfo</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
  <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">info</span><span class="o">.</span><span class="n">nexp</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
  <span class="n">bias</span> <span class="o">=</span> <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">info</span><span class="o">.</span><span class="n">nexp</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span>

  <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">_normalize_float</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="n">x2</span> <span class="o">+=</span> <span class="p">((</span><span class="n">x1</span> <span class="o">&gt;&gt;</span> <span class="n">info</span><span class="o">.</span><span class="n">nmant</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">-</span> <span class="n">bias</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="n">x1</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">mask</span> <span class="o">&lt;&lt;</span> <span class="n">info</span><span class="o">.</span><span class="n">nmant</span><span class="p">)</span>
  <span class="n">x1</span> <span class="o">|=</span> <span class="p">(</span><span class="n">bias</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">info</span><span class="o">.</span><span class="n">nmant</span>
  <span class="n">x1</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">bitcast_convert_type</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>

  <span class="n">cond</span> <span class="o">=</span> <span class="n">isinf</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">|</span> <span class="n">isnan</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
  <span class="n">x2</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="n">zeros_like</span><span class="p">(</span><span class="n">x2</span><span class="p">),</span> <span class="n">x2</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">where</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">x1</span><span class="p">),</span> <span class="n">lax</span><span class="o">.</span><span class="n">convert_element_type</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">int32</span><span class="p">)</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">remainder</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">remainder</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">):</span>
  <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">_promote_args</span><span class="p">(</span><span class="s2">&quot;remainder&quot;</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span>
  <span class="n">zero</span> <span class="o">=</span> <span class="n">_constant_like</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
  <span class="n">trunc_mod</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">rem</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span>
  <span class="n">trunc_mod_not_zero</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">ne</span><span class="p">(</span><span class="n">trunc_mod</span><span class="p">,</span> <span class="n">zero</span><span class="p">)</span>
  <span class="n">do_plus</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">bitwise_and</span><span class="p">(</span>
      <span class="n">lax</span><span class="o">.</span><span class="n">ne</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">lt</span><span class="p">(</span><span class="n">trunc_mod</span><span class="p">,</span> <span class="n">zero</span><span class="p">),</span> <span class="n">lax</span><span class="o">.</span><span class="n">lt</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">zero</span><span class="p">)),</span> <span class="n">trunc_mod_not_zero</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">do_plus</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">trunc_mod</span><span class="p">,</span> <span class="n">x2</span><span class="p">),</span> <span class="n">trunc_mod</span><span class="p">)</span>
<span class="n">mod</span> <span class="o">=</span> <span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">)(</span><span class="n">remainder</span><span class="p">)</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fmod</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">fmod</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;fmod&quot;</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">_dtype</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">),</span> <span class="n">integer</span><span class="p">):</span>
    <span class="n">x2</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">x2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">rem</span><span class="p">(</span><span class="o">*</span><span class="n">_promote_args</span><span class="p">(</span><span class="s2">&quot;fmod&quot;</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">))</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cbrt</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">cbrt</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;cbrt&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
  <span class="n">x</span><span class="p">,</span> <span class="o">=</span> <span class="n">_promote_dtypes_inexact</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">power</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">_constant_like</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mf">1.</span> <span class="o">/</span> <span class="mf">3.</span><span class="p">))</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">square</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;square&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">integer_pow</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">deg2rad</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;deg2rad&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
  <span class="n">x</span><span class="p">,</span> <span class="o">=</span> <span class="n">_promote_dtypes_inexact</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">_const</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">pi</span> <span class="o">/</span> <span class="mi">180</span><span class="p">))</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">rad2deg</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;rad2deg&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
  <span class="n">x</span><span class="p">,</span> <span class="o">=</span> <span class="n">_promote_dtypes_inexact</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">_const</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">180</span> <span class="o">/</span> <span class="n">pi</span><span class="p">))</span>


<span class="n">degrees</span> <span class="o">=</span> <span class="n">rad2deg</span>
<span class="n">radians</span> <span class="o">=</span> <span class="n">deg2rad</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">histogram_bin_edges</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">histogram_bin_edges</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bins</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;string values for `bins` not implemented.&quot;</span><span class="p">)</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">ravel</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
  <span class="n">b</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">b</span>
  <span class="k">if</span> <span class="nb">range</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="nb">range</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
  <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="nb">range</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
  <span class="nb">range</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="nb">range</span><span class="p">)</span>
  <span class="nb">range</span> <span class="o">=</span> <span class="p">(</span><span class="n">where</span><span class="p">(</span><span class="n">ptp</span><span class="p">(</span><span class="nb">range</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">,</span> <span class="nb">range</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
           <span class="n">where</span><span class="p">(</span><span class="n">ptp</span><span class="p">(</span><span class="nb">range</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">,</span> <span class="nb">range</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
  <span class="n">dtype</span> <span class="o">=</span> <span class="n">_dtype</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">integer</span><span class="p">):</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">promote_types</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">float32</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">linspace</span><span class="p">(</span><span class="nb">range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">range</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">bins</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">histogram</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">weights</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;weights should have the same shape as a.&quot;</span><span class="p">)</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">ravel</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">ravel</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">ones_like</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
  <span class="n">bin_edges</span> <span class="o">=</span> <span class="n">histogram_bin_edges</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="nb">range</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>
  <span class="n">bin_idx</span> <span class="o">=</span> <span class="n">searchsorted</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">)</span>
  <span class="n">bin_idx</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">bin_edges</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">bin_idx</span><span class="p">)</span>
  <span class="n">counts</span> <span class="o">=</span> <span class="n">bincount</span><span class="p">(</span><span class="n">bin_idx</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">))[</span><span class="mi">1</span><span class="p">:]</span>
  <span class="k">if</span> <span class="n">density</span><span class="p">:</span>
    <span class="n">bin_widths</span> <span class="o">=</span> <span class="n">diff</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">)</span>
    <span class="n">counts</span> <span class="o">=</span> <span class="n">counts</span> <span class="o">/</span> <span class="n">bin_widths</span> <span class="o">/</span> <span class="n">counts</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
  <span class="k">return</span> <span class="n">counts</span><span class="p">,</span> <span class="n">bin_edges</span>

<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">histogram2d</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">histogram2d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

  <span class="k">try</span><span class="p">:</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span>
  <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
    <span class="n">N</span> <span class="o">=</span> <span class="mi">1</span>

  <span class="k">if</span> <span class="n">N</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">N</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
    <span class="n">x_edges</span> <span class="o">=</span> <span class="n">y_edges</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span>
    <span class="n">bins</span> <span class="o">=</span> <span class="p">[</span><span class="n">x_edges</span><span class="p">,</span> <span class="n">y_edges</span><span class="p">]</span>

  <span class="n">sample</span> <span class="o">=</span> <span class="n">transpose</span><span class="p">(</span><span class="n">asarray</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]))</span>
  <span class="n">hist</span><span class="p">,</span> <span class="n">edges</span> <span class="o">=</span> <span class="n">histogramdd</span><span class="p">(</span><span class="n">sample</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="nb">range</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">density</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">hist</span><span class="p">,</span> <span class="n">edges</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">edges</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">histogramdd</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">histogramdd</span><span class="p">(</span><span class="n">sample</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;histogramdd&quot;</span><span class="p">,</span> <span class="n">sample</span><span class="p">)</span>
  <span class="n">N</span><span class="p">,</span> <span class="n">D</span> <span class="o">=</span> <span class="n">shape</span><span class="p">(</span><span class="n">sample</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">weights</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">N</span><span class="p">,):</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;should have one weight for each sample.&quot;</span><span class="p">)</span>

  <span class="k">try</span><span class="p">:</span>
    <span class="n">num_bins</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">num_bins</span> <span class="o">!=</span> <span class="n">D</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;should be a bin for each dimension.&quot;</span><span class="p">)</span>
  <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
    <span class="c1"># when bin_size is integer, the same bin is used for each dimension</span>
    <span class="n">bins</span> <span class="o">=</span> <span class="n">D</span> <span class="o">*</span> <span class="p">[</span><span class="n">bins</span><span class="p">]</span>

  <span class="n">bin_idx_by_dim</span> <span class="o">=</span> <span class="n">D</span><span class="o">*</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span>
  <span class="n">nbins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
  <span class="n">bin_edges_by_dim</span> <span class="o">=</span> <span class="n">D</span><span class="o">*</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span>
  <span class="n">dedges</span> <span class="o">=</span> <span class="n">D</span><span class="o">*</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span>

  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">builtins</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="n">D</span><span class="p">):</span>
    <span class="n">bin_edges</span> <span class="o">=</span> <span class="n">histogram_bin_edges</span><span class="p">(</span><span class="n">sample</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">bins</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">range</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>
    <span class="n">bin_idx</span> <span class="o">=</span> <span class="n">searchsorted</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">,</span> <span class="n">sample</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">side</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">)</span>
    <span class="n">bin_idx</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">sample</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">bin_edges</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">bin_idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">bin_idx</span><span class="p">)</span>
    <span class="n">bin_idx_by_dim</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">bin_idx</span>
    <span class="n">nbins</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">bin_edges_by_dim</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">bin_edges</span>
    <span class="n">dedges</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">diff</span><span class="p">(</span><span class="n">bin_edges_by_dim</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

  <span class="n">xy</span> <span class="o">=</span> <span class="n">ravel_multi_index</span><span class="p">(</span><span class="n">bin_idx_by_dim</span><span class="p">,</span> <span class="n">nbins</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;clip&#39;</span><span class="p">)</span>
  <span class="n">hist</span> <span class="o">=</span> <span class="n">bincount</span><span class="p">(</span><span class="n">xy</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="n">nbins</span><span class="o">.</span><span class="n">prod</span><span class="p">())</span>
  <span class="n">hist</span> <span class="o">=</span> <span class="n">reshape</span><span class="p">(</span><span class="n">hist</span><span class="p">,</span> <span class="n">nbins</span><span class="p">)</span>
  <span class="n">core</span> <span class="o">=</span> <span class="n">D</span><span class="o">*</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),)</span>
  <span class="n">hist</span> <span class="o">=</span> <span class="n">hist</span><span class="p">[</span><span class="n">core</span><span class="p">]</span>

  <span class="k">if</span> <span class="n">density</span><span class="p">:</span>
    <span class="n">s</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">hist</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">builtins</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="n">D</span><span class="p">):</span>
      <span class="n">_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
      <span class="n">_shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">nbins</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span>
      <span class="n">hist</span> <span class="o">=</span> <span class="n">hist</span> <span class="o">/</span> <span class="n">reshape</span><span class="p">(</span><span class="n">dedges</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">_shape</span><span class="p">)</span>

    <span class="n">hist</span> <span class="o">/=</span> <span class="n">s</span>

  <span class="k">return</span> <span class="n">hist</span><span class="p">,</span> <span class="n">bin_edges_by_dim</span>

<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">heaviside</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">heaviside</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;heaviside&quot;</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span>
  <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">_promote_dtypes_inexact</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span>
  <span class="n">zero</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">_const</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">where</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">lt</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">zero</span><span class="p">),</span> <span class="n">zero</span><span class="p">,</span>
               <span class="n">where</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">gt</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">zero</span><span class="p">),</span> <span class="n">lax</span><span class="o">.</span><span class="n">_const</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">x2</span><span class="p">))</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hypot</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">hypot</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;hypot&quot;</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span>
  <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">_promote_dtypes_inexact</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span>
  <span class="n">x1</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span>
  <span class="n">x2</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span>
  <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">maximum</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">),</span> <span class="n">minimum</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">x1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x1</span> <span class="o">*</span> <span class="n">lax</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">lax</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">div</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">x1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ones_like</span><span class="p">(</span><span class="n">x1</span><span class="p">),</span> <span class="n">x1</span><span class="p">)))))</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">reciprocal</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">reciprocal</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;reciprocal&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
  <span class="n">x</span><span class="p">,</span> <span class="o">=</span> <span class="n">_promote_dtypes_inexact</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">integer_pow</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sinc</span><span class="p">,</span> <span class="n">update_doc</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">sinc</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;sinc&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
  <span class="n">x</span><span class="p">,</span> <span class="o">=</span> <span class="n">_promote_dtypes_inexact</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="n">eq_zero</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">_const</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
  <span class="n">pi_x</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">_const</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">pi</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span>
  <span class="n">safe_pi_x</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">eq_zero</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">_const</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">pi_x</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">where</span><span class="p">(</span><span class="n">eq_zero</span><span class="p">,</span> <span class="n">_sinc_maclaurin</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">pi_x</span><span class="p">),</span>
               <span class="n">lax</span><span class="o">.</span><span class="n">div</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">safe_pi_x</span><span class="p">),</span> <span class="n">safe_pi_x</span><span class="p">))</span>

<span class="nd">@partial</span><span class="p">(</span><span class="n">custom_jvp</span><span class="p">,</span> <span class="n">nondiff_argnums</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,))</span>
<span class="k">def</span> <span class="nf">_sinc_maclaurin</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
  <span class="c1"># compute the kth derivative of x -&gt; sin(x)/x evaluated at zero (since we</span>
  <span class="c1"># compute the monomial term in the jvp rule)</span>
  <span class="k">if</span> <span class="n">k</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="n">k</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>

<span class="nd">@_sinc_maclaurin</span><span class="o">.</span><span class="n">defjvp</span>
<span class="k">def</span> <span class="nf">_sinc_maclaurin_jvp</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">primals</span><span class="p">,</span> <span class="n">tangents</span><span class="p">):</span>
  <span class="p">(</span><span class="n">x</span><span class="p">,),</span> <span class="p">(</span><span class="n">t</span><span class="p">,)</span> <span class="o">=</span> <span class="n">primals</span><span class="p">,</span> <span class="n">tangents</span>
  <span class="k">return</span> <span class="n">_sinc_maclaurin</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="n">_sinc_maclaurin</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">t</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">transpose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;transpose&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="n">axes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">))[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">axes</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">axes</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axes</span><span class="p">)</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">rot90</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">rot90</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;rot90&quot;</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
  <span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span> <span class="o">=</span> <span class="n">axes</span>
  <span class="n">ax1</span> <span class="o">=</span> <span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">ax1</span><span class="p">,</span> <span class="n">ndim</span><span class="p">(</span><span class="n">m</span><span class="p">))</span>
  <span class="n">ax2</span> <span class="o">=</span> <span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">ax2</span><span class="p">,</span> <span class="n">ndim</span><span class="p">(</span><span class="n">m</span><span class="p">))</span>
  <span class="k">if</span> <span class="n">ax1</span> <span class="o">==</span> <span class="n">ax2</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Axes must be different&quot;</span><span class="p">)</span>  <span class="c1"># same as numpy error</span>
  <span class="n">k</span> <span class="o">=</span> <span class="n">k</span> <span class="o">%</span> <span class="mi">4</span>
  <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">m</span>
  <span class="k">elif</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">flip</span><span class="p">(</span><span class="n">flip</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">ax1</span><span class="p">),</span> <span class="n">ax2</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">perm</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
    <span class="n">perm</span><span class="p">[</span><span class="n">ax1</span><span class="p">],</span> <span class="n">perm</span><span class="p">[</span><span class="n">ax2</span><span class="p">]</span> <span class="o">=</span> <span class="n">perm</span><span class="p">[</span><span class="n">ax2</span><span class="p">],</span> <span class="n">perm</span><span class="p">[</span><span class="n">ax1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">transpose</span><span class="p">(</span><span class="n">flip</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">ax2</span><span class="p">),</span> <span class="n">perm</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">flip</span><span class="p">(</span><span class="n">transpose</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">perm</span><span class="p">),</span> <span class="n">ax2</span><span class="p">)</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">flip</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;flip&quot;</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">rev</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">(</span><span class="n">m</span><span class="p">)))))</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">rev</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="p">[</span><span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">ndim</span><span class="p">(</span><span class="n">m</span><span class="p">))])</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fliplr</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">fliplr</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">flip</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">flipud</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">flipud</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">flip</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">conjugate</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">conjugate</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;conjugate&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">if</span> <span class="n">iscomplexobj</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">else</span> <span class="n">x</span>
<span class="n">conj</span> <span class="o">=</span> <span class="n">conjugate</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">imag</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;imag&quot;</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">if</span> <span class="n">iscomplexobj</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">else</span> <span class="n">zeros_like</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">real</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;real&quot;</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">if</span> <span class="n">iscomplexobj</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">else</span> <span class="n">val</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">iscomplex</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">iscomplex</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="n">i</span> <span class="o">=</span> <span class="n">imag</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">ne</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">_const</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isreal</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">isreal</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="n">i</span> <span class="o">=</span> <span class="n">imag</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">_const</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">angle</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
  <span class="n">re</span> <span class="o">=</span> <span class="n">real</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
  <span class="n">im</span> <span class="o">=</span> <span class="n">imag</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
  <span class="n">dtype</span> <span class="o">=</span> <span class="n">_dtype</span><span class="p">(</span><span class="n">re</span><span class="p">)</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">inexact</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
      <span class="n">issubdtype</span><span class="p">(</span><span class="n">_dtype</span><span class="p">(</span><span class="n">z</span><span class="p">),</span> <span class="n">floating</span><span class="p">)</span> <span class="ow">and</span> <span class="n">ndim</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">canonicalize_dtype</span><span class="p">(</span><span class="n">float_</span><span class="p">)</span>
    <span class="n">re</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">convert_element_type</span><span class="p">(</span><span class="n">re</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
    <span class="n">im</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">convert_element_type</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">atan2</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">re</span><span class="p">)</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">diff</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">prepend</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;diff&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">a</span>
  <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;order must be non-negative but got </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;diff requires input that is at least one dimensional; got </span><span class="si">{</span><span class="n">a</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

  <span class="n">nd</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span>

  <span class="n">combined</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">if</span> <span class="n">prepend</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;diff&quot;</span><span class="p">,</span> <span class="n">prepend</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">prepend</span><span class="p">):</span>
      <span class="n">shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
      <span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="n">prepend</span> <span class="o">=</span> <span class="n">broadcast_to</span><span class="p">(</span><span class="n">prepend</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">shape</span><span class="p">))</span>
    <span class="n">combined</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">prepend</span><span class="p">)</span>

  <span class="n">combined</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">append</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;diff&quot;</span><span class="p">,</span> <span class="n">append</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">append</span><span class="p">):</span>
      <span class="n">shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
      <span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="n">append</span> <span class="o">=</span> <span class="n">broadcast_to</span><span class="p">(</span><span class="n">append</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">shape</span><span class="p">))</span>
    <span class="n">combined</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">append</span><span class="p">)</span>

  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">combined</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">(</span><span class="n">combined</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

  <span class="n">slice1</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">nd</span>
  <span class="n">slice2</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">nd</span>
  <span class="n">slice1</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
  <span class="n">slice2</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
  <span class="n">slice1_tuple</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">slice1</span><span class="p">)</span>
  <span class="n">slice2_tuple</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">slice2</span><span class="p">)</span>

  <span class="n">op</span> <span class="o">=</span> <span class="n">not_equal</span> <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span> <span class="k">else</span> <span class="n">subtract</span>
  <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">slice1_tuple</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="n">slice2_tuple</span><span class="p">])</span>

  <span class="k">return</span> <span class="n">a</span>

<span class="n">_EDIFF1D_DOC</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">Unlike NumPy&#39;s implementation of ediff1d, :py:func:`jax.numpy.ediff1d` will not</span>
<span class="s2">issue an error if casting ``to_end`` or ``to_begin`` to the type of ``ary``</span>
<span class="s2">loses precision.</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ediff1d</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_EDIFF1D_DOC</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">ediff1d</span><span class="p">(</span><span class="n">ary</span><span class="p">,</span> <span class="n">to_end</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">to_begin</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="n">ary</span> <span class="o">=</span> <span class="n">ravel</span><span class="p">(</span><span class="n">asarray</span><span class="p">(</span><span class="n">ary</span><span class="p">))</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">ary</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">ary</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
  <span class="k">if</span> <span class="n">to_begin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">((</span><span class="n">ravel</span><span class="p">(</span><span class="n">asarray</span><span class="p">(</span><span class="n">to_begin</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">ary</span><span class="o">.</span><span class="n">dtype</span><span class="p">)),</span> <span class="n">result</span><span class="p">))</span>
  <span class="k">if</span> <span class="n">to_end</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">((</span><span class="n">result</span><span class="p">,</span> <span class="n">ravel</span><span class="p">(</span><span class="n">asarray</span><span class="p">(</span><span class="n">to_end</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">ary</span><span class="o">.</span><span class="n">dtype</span><span class="p">))))</span>
  <span class="k">return</span> <span class="n">result</span>


<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnums</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_gradient</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">varargs</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">gradient_along_axis</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
    <span class="n">sliced</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">slice_in_dim</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="n">a_grad</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">((</span>
      <span class="p">(</span><span class="n">sliced</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">sliced</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span>  <span class="c1"># upper edge</span>
      <span class="p">(</span><span class="n">sliced</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-</span> <span class="n">sliced</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">))</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span>  <span class="c1"># inner</span>
      <span class="p">(</span><span class="n">sliced</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-</span> <span class="n">sliced</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)),</span>  <span class="c1"># lower edge</span>
    <span class="p">),</span> <span class="n">axis</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">a_grad</span> <span class="o">/</span> <span class="n">h</span>

  <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">axis</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
      <span class="n">axis</span> <span class="o">=</span> <span class="p">(</span><span class="n">axis</span><span class="p">,)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Give `axis` either as int or iterable&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
      <span class="k">return</span> <span class="p">[]</span>
    <span class="n">axis</span> <span class="o">=</span> <span class="p">[</span><span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">axis</span><span class="p">]</span>

  <span class="k">if</span> <span class="n">_min</span><span class="p">([</span><span class="n">s</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">axis</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Shape of array too small to calculate &quot;</span>
                     <span class="s2">&quot;a numerical gradient, &quot;</span>
                     <span class="s2">&quot;at least 2 elements are required.&quot;</span><span class="p">)</span>
  <span class="n">len_axes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
  <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">varargs</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">varargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="c1"># no spacing</span>
    <span class="n">dx</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">]</span> <span class="o">*</span> <span class="n">len_axes</span>
  <span class="k">elif</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
    <span class="c1"># single value for all axes</span>
    <span class="n">dx</span> <span class="o">=</span> <span class="n">varargs</span> <span class="o">*</span> <span class="n">len_axes</span>
  <span class="k">elif</span> <span class="n">n</span> <span class="o">==</span> <span class="n">len_axes</span><span class="p">:</span>
    <span class="n">dx</span> <span class="o">=</span> <span class="n">varargs</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid number of spacing arguments </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">n</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">ndim</span><span class="p">(</span><span class="n">dx</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Non-constant spacing not implemented&quot;</span><span class="p">)</span>

  <span class="c1"># TODO: use jax.lax loop tools if possible</span>
  <span class="n">a_grad</span> <span class="o">=</span> <span class="p">[</span><span class="n">gradient_along_axis</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">ax</span><span class="p">)</span> <span class="k">for</span> <span class="n">ax</span><span class="p">,</span> <span class="n">h</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">dx</span><span class="p">)]</span>

  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">a_grad</span> <span class="o">=</span> <span class="n">a_grad</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

  <span class="k">return</span> <span class="n">a_grad</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">gradient</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">varargs</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
             <span class="n">edge_order</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">edge_order</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;The &#39;edge_order&#39; argument to jnp.gradient is not supported.&quot;</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">_gradient</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">varargs</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isrealobj</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">isrealobj</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="k">return</span> <span class="ow">not</span> <span class="n">iscomplexobj</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">reshape</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">newshape</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">):</span>
  <span class="k">try</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">newshape</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>  <span class="c1"># forward to method for ndarrays</span>
  <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">_reshape</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">newshape</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_compute_newshape</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">newshape</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Fixes a -1 value in newshape, if present.&quot;&quot;&quot;</span>
  <span class="c1"># other errors, like having more than one -1, are caught downstream</span>
  <span class="k">try</span><span class="p">:</span> <span class="nb">iter</span><span class="p">(</span><span class="n">newshape</span><span class="p">)</span>
  <span class="k">except</span><span class="p">:</span> <span class="n">iterable</span> <span class="o">=</span> <span class="kc">False</span>
  <span class="k">else</span><span class="p">:</span> <span class="n">iterable</span> <span class="o">=</span> <span class="kc">True</span>
  <span class="k">def</span> <span class="nf">check</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">size</span> <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="ow">is</span> <span class="n">Poly</span> <span class="k">else</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span>
      <span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="s2">&quot;The error arose in jax.numpy.reshape.&quot;</span><span class="p">)</span>
  <span class="n">newshape</span> <span class="o">=</span> <span class="p">[</span><span class="n">check</span><span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="k">for</span> <span class="n">size</span> <span class="ow">in</span> <span class="n">newshape</span><span class="p">]</span> <span class="k">if</span> <span class="n">iterable</span> <span class="k">else</span> <span class="p">[</span><span class="n">check</span><span class="p">(</span><span class="n">newshape</span><span class="p">)]</span>
  <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">newshape</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)):</span>
    <span class="n">fix</span> <span class="o">=</span> <span class="o">-</span><span class="n">a</span><span class="o">.</span><span class="n">size</span> <span class="o">//</span> <span class="p">(</span><span class="n">newshape</span> <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">newshape</span><span class="p">)</span> <span class="ow">is</span> <span class="n">Poly</span> <span class="k">else</span> <span class="n">_prod</span><span class="p">(</span><span class="n">newshape</span><span class="p">))</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">d</span> <span class="k">if</span> <span class="n">d</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="k">else</span> <span class="n">fix</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">newshape</span><span class="p">]</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">newshape</span>

<span class="k">def</span> <span class="nf">_reshape</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">):</span>
  <span class="n">newshape</span> <span class="o">=</span> <span class="n">_compute_newshape</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">args</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">order</span> <span class="o">==</span> <span class="s2">&quot;C&quot;</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">newshape</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
  <span class="k">elif</span> <span class="n">order</span> <span class="o">==</span> <span class="s2">&quot;F&quot;</span><span class="p">:</span>
    <span class="n">dims</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">))[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">newshape</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">dims</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
  <span class="k">elif</span> <span class="n">order</span> <span class="o">==</span> <span class="s2">&quot;A&quot;</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;np.reshape order=A is not implemented.&quot;</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unexpected value for &#39;order&#39; argument: </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">order</span><span class="p">))</span>

<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">ravel</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">order</span> <span class="o">==</span> <span class="s2">&quot;K&quot;</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Ravel not implemented for order=&#39;K&#39;.&quot;</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">reshape</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="n">size</span><span class="p">(</span><span class="n">a</span><span class="p">),),</span> <span class="n">order</span><span class="p">)</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ravel_multi_index</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">ravel_multi_index</span><span class="p">(</span><span class="n">multi_index</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;raise&#39;</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">):</span>
  <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">multi_index</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;len(multi_index)=</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">multi_index</span><span class="p">)</span><span class="si">}</span><span class="s2"> != len(dims)=</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
  <span class="n">dims</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="s2">&quot;in `dims` argument of ravel_multi_index().&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">)</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;ravel_multi_index&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">multi_index</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">multi_index</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;raise&#39;</span><span class="p">:</span>
      <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span>
        <span class="s2">&quot;The error occurred because ravel_multi_index was jit-compiled&quot;</span>
        <span class="s2">&quot; with mode=&#39;raise&#39;. Use mode=&#39;wrap&#39; or mode=&#39;clip&#39; instead.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">_dtype</span><span class="p">(</span><span class="n">index</span><span class="p">),</span> <span class="n">integer</span><span class="p">):</span>
      <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;only int indices permitted&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;raise&quot;</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">_any</span><span class="p">(</span><span class="nb">any</span><span class="p">((</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">d</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">multi_index</span><span class="p">,</span> <span class="n">dims</span><span class="p">)):</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid entry in coordinates array&quot;</span><span class="p">)</span>
  <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;clip&quot;</span><span class="p">:</span>
    <span class="n">multi_index</span> <span class="o">=</span> <span class="p">[</span><span class="n">clip</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">d</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">multi_index</span><span class="p">,</span> <span class="n">dims</span><span class="p">)]</span>
  <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;wrap&quot;</span><span class="p">:</span>
    <span class="n">multi_index</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="o">%</span> <span class="n">d</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">multi_index</span><span class="p">,</span> <span class="n">dims</span><span class="p">)]</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;invalid mode=</span><span class="si">{</span><span class="n">mode</span><span class="si">!r}</span><span class="s2">. Expected &#39;raise&#39;, &#39;wrap&#39;, or &#39;clip&#39;&quot;</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">order</span> <span class="o">==</span> <span class="s2">&quot;F&quot;</span><span class="p">:</span>
    <span class="n">strides</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumprod</span><span class="p">((</span><span class="mi">1</span><span class="p">,)</span> <span class="o">+</span> <span class="n">dims</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
  <span class="k">elif</span> <span class="n">order</span> <span class="o">==</span> <span class="s2">&quot;C&quot;</span><span class="p">:</span>
    <span class="n">strides</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumprod</span><span class="p">((</span><span class="mi">1</span><span class="p">,)</span> <span class="o">+</span> <span class="n">dims</span><span class="p">[</span><span class="mi">1</span><span class="p">:][::</span><span class="o">-</span><span class="mi">1</span><span class="p">])[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;invalid order=</span><span class="si">{</span><span class="n">order</span><span class="si">!r}</span><span class="s2">. Expected &#39;C&#39; or &#39;F&#39;&quot;</span><span class="p">)</span>

  <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">multi_index</span><span class="p">,</span> <span class="n">strides</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">result</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">s</span>
  <span class="k">return</span> <span class="n">result</span>


<span class="n">_UNRAVEL_INDEX_DOC</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">Unlike numpy&#39;s implementation of unravel_index, negative indices are accepted</span>
<span class="s2">and out-of-bounds indices are clipped.</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_UNRAVEL_INDEX_DOC</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">unravel_index</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">shape</span><span class="p">):</span>
  <span class="n">indices</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
  <span class="n">sizes</span> <span class="o">=</span> <span class="n">pad</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">constant_values</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
  <span class="n">cumulative_sizes</span> <span class="o">=</span> <span class="n">cumprod</span><span class="p">(</span><span class="n">sizes</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
  <span class="n">total_size</span> <span class="o">=</span> <span class="n">cumulative_sizes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="c1"># Clip so raveling and unraveling an oob index will not change the behavior</span>
  <span class="n">clipped_indices</span> <span class="o">=</span> <span class="n">clip</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="o">-</span><span class="n">total_size</span><span class="p">,</span> <span class="n">total_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
  <span class="c1"># Add enough trailing dims to avoid conflict with flat_index</span>
  <span class="n">cumulative_sizes</span> <span class="o">=</span> <span class="n">cumulative_sizes</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">indices</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
  <span class="n">idx</span> <span class="o">=</span> <span class="n">clipped_indices</span> <span class="o">%</span> <span class="n">cumulative_sizes</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">//</span> <span class="n">cumulative_sizes</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
  <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">squeeze</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;squeeze&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">a_shape</span> <span class="o">=</span> <span class="n">shape</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">axis</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">a_shape</span><span class="p">)</span> <span class="k">if</span> <span class="n">d</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
  <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
    <span class="n">axis</span> <span class="o">=</span> <span class="p">(</span><span class="n">axis</span><span class="p">,)</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">expand_dims</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]]):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;expand_dims&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
    <span class="n">axis</span> <span class="o">=</span> <span class="p">(</span><span class="n">axis</span><span class="p">,)</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">swapaxes</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis1</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">axis2</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;swapaxes&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="n">perm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
  <span class="n">perm</span><span class="p">[</span><span class="n">axis1</span><span class="p">],</span> <span class="n">perm</span><span class="p">[</span><span class="n">axis2</span><span class="p">]</span> <span class="o">=</span> <span class="n">perm</span><span class="p">[</span><span class="n">axis2</span><span class="p">],</span> <span class="n">perm</span><span class="p">[</span><span class="n">axis1</span><span class="p">]</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">perm</span><span class="p">)</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">moveaxis</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">source</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
             <span class="n">destination</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;moveaxis&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="n">source_axes</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
  <span class="n">destination_axes</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
  <span class="k">try</span><span class="p">:</span>
    <span class="n">source_axes</span> <span class="o">=</span> <span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">source</span><span class="p">),)</span>
  <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
    <span class="n">source_axes</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">cast</span><span class="p">(</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">source</span><span class="p">))</span>
  <span class="k">try</span><span class="p">:</span>
    <span class="n">destination_axes</span> <span class="o">=</span> <span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">destination</span><span class="p">),)</span>
  <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
    <span class="n">destination_axes</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">cast</span><span class="p">(</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">destination</span><span class="p">))</span>
  <span class="n">source_axes</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">source_axes</span><span class="p">)</span>
  <span class="n">destination_axes</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
                           <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">destination_axes</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">source_axes</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">destination_axes</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Inconsistent number of elements: </span><span class="si">{}</span><span class="s2"> vs </span><span class="si">{}</span><span class="s2">&quot;</span>
                     <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">source_axes</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">destination_axes</span><span class="p">)))</span>
  <span class="n">perm</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">))</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">source_axes</span><span class="p">]</span>
  <span class="k">for</span> <span class="n">dest</span><span class="p">,</span> <span class="n">src</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">destination_axes</span><span class="p">,</span> <span class="n">source_axes</span><span class="p">)):</span>
    <span class="n">perm</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="n">src</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">perm</span><span class="p">)</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">isclose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">1e-05</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-08</span><span class="p">,</span> <span class="n">equal_nan</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
  <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">_promote_args</span><span class="p">(</span><span class="s2">&quot;isclose&quot;</span><span class="p">,</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">asarray</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
  <span class="n">dtype</span> <span class="o">=</span> <span class="n">_dtype</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">inexact</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">complexfloating</span><span class="p">):</span>
      <span class="n">dtype</span> <span class="o">=</span> <span class="n">_complex_elem_type</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">rtol</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">convert_element_type</span><span class="p">(</span><span class="n">rtol</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
    <span class="n">atol</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">convert_element_type</span><span class="p">(</span><span class="n">atol</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">le</span><span class="p">(</span>
      <span class="n">lax</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)),</span>
      <span class="n">lax</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">atol</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">rtol</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">b</span><span class="p">))))</span>
    <span class="c1"># This corrects the comparisons for infinite and nan values</span>
    <span class="n">a_inf</span> <span class="o">=</span> <span class="n">isinf</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">b_inf</span> <span class="o">=</span> <span class="n">isinf</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="n">any_inf</span> <span class="o">=</span> <span class="n">logical_or</span><span class="p">(</span><span class="n">a_inf</span><span class="p">,</span> <span class="n">b_inf</span><span class="p">)</span>
    <span class="n">both_inf</span> <span class="o">=</span> <span class="n">logical_and</span><span class="p">(</span><span class="n">a_inf</span><span class="p">,</span> <span class="n">b_inf</span><span class="p">)</span>
    <span class="c1"># Make all elements where either a or b are infinite to False</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">logical_and</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">logical_not</span><span class="p">(</span><span class="n">any_inf</span><span class="p">))</span>
    <span class="c1"># Make all elements where both a or b are the same inf to True</span>
    <span class="n">same_value</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="n">same_inf</span> <span class="o">=</span> <span class="n">logical_and</span><span class="p">(</span><span class="n">both_inf</span><span class="p">,</span> <span class="n">same_value</span><span class="p">)</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">logical_or</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">same_inf</span><span class="p">)</span>

    <span class="c1"># Make all elements where either a or b is NaN to False</span>
    <span class="n">a_nan</span> <span class="o">=</span> <span class="n">isnan</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">b_nan</span> <span class="o">=</span> <span class="n">isnan</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="n">any_nan</span> <span class="o">=</span> <span class="n">logical_or</span><span class="p">(</span><span class="n">a_nan</span><span class="p">,</span> <span class="n">b_nan</span><span class="p">)</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">logical_and</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">logical_not</span><span class="p">(</span><span class="n">any_nan</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">equal_nan</span><span class="p">:</span>
      <span class="c1"># Make all elements where both a and b is NaN to True</span>
      <span class="n">both_nan</span> <span class="o">=</span> <span class="n">logical_and</span><span class="p">(</span><span class="n">a_nan</span><span class="p">,</span> <span class="n">b_nan</span><span class="p">)</span>
      <span class="n">out</span> <span class="o">=</span> <span class="n">logical_or</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">both_nan</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_maybe_numpy_1_13_isclose_behavior</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

<span class="n">numpy_version</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">version</span><span class="o">.</span><span class="n">version</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[:</span><span class="mi">2</span><span class="p">]))</span>
<span class="k">if</span> <span class="n">numpy_version</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">14</span><span class="p">):</span>
  <span class="c1"># see discussion at https://github.com/numpy/numpy/pull/9720</span>
  <span class="k">def</span> <span class="nf">_maybe_numpy_1_13_isclose_behavior</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">out</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">size</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">_dtype</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">complexfloating</span><span class="p">):</span>
      <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,))</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">out</span>
<span class="k">else</span><span class="p">:</span>
  <span class="k">def</span> <span class="nf">_maybe_numpy_1_13_isclose_behavior</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">out</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">out</span>

<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">interp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xp</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">period</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">shape</span><span class="p">(</span><span class="n">xp</span><span class="p">)</span> <span class="o">!=</span> <span class="n">shape</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span> <span class="ow">or</span> <span class="n">ndim</span><span class="p">(</span><span class="n">xp</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;xp and fp must be one-dimensional arrays of equal size&quot;</span><span class="p">)</span>
  <span class="n">x</span><span class="p">,</span> <span class="n">xp</span><span class="p">,</span> <span class="n">fp</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">asarray</span><span class="p">,</span> <span class="n">_promote_dtypes_inexact</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xp</span><span class="p">,</span> <span class="n">fp</span><span class="p">))</span>
  <span class="k">if</span> <span class="n">period</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">period</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;period must be a non-zero value; got </span><span class="si">{</span><span class="n">period</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">period</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">period</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">%</span> <span class="n">period</span>
    <span class="n">xp</span> <span class="o">=</span> <span class="n">xp</span> <span class="o">%</span> <span class="n">period</span>
    <span class="n">xp</span><span class="p">,</span> <span class="n">fp</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">sort_key_val</span><span class="p">(</span><span class="n">xp</span><span class="p">,</span> <span class="n">fp</span><span class="p">)</span>
    <span class="n">xp</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">([</span><span class="n">xp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">period</span><span class="p">,</span> <span class="n">xp</span><span class="p">,</span> <span class="n">xp</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">period</span><span class="p">])</span>
    <span class="n">fp</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">([</span><span class="n">fp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:],</span> <span class="n">fp</span><span class="p">,</span> <span class="n">fp</span><span class="p">[:</span><span class="mi">1</span><span class="p">]])</span>

  <span class="n">i</span> <span class="o">=</span> <span class="n">clip</span><span class="p">(</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">xp</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">xp</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
  <span class="n">df</span> <span class="o">=</span> <span class="n">fp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">fp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
  <span class="n">dx</span> <span class="o">=</span> <span class="n">xp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">xp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
  <span class="n">delta</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">xp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
  <span class="n">f</span> <span class="o">=</span> <span class="n">where</span><span class="p">((</span><span class="n">dx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">),</span> <span class="n">fp</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">fp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">delta</span> <span class="o">/</span> <span class="n">dx</span><span class="p">)</span> <span class="o">*</span> <span class="n">df</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">period</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">xp</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">fp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">left</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">left</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">xp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">fp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">right</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">right</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">f</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">In the JAX version, the `assume_unique` argument is not referenced.</span>
<span class="s2">&quot;&quot;&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">in1d</span><span class="p">(</span><span class="n">ar1</span><span class="p">,</span> <span class="n">ar2</span><span class="p">,</span> <span class="n">assume_unique</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">invert</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
  <span class="n">ar1</span> <span class="o">=</span> <span class="n">ravel</span><span class="p">(</span><span class="n">ar1</span><span class="p">)</span>
  <span class="n">ar2</span> <span class="o">=</span> <span class="n">ravel</span><span class="p">(</span><span class="n">ar2</span><span class="p">)</span>
  <span class="c1"># Note: an algorithm based on searchsorted has better scaling, but in practice</span>
  <span class="c1"># is very slow on accelerators because it relies on lax control flow. If XLA</span>
  <span class="c1"># ever supports binary search natively, we should switch to this:</span>
  <span class="c1">#   ar2 = jnp.sort(ar2)</span>
  <span class="c1">#   ind = jnp.searchsorted(ar2, ar1)</span>
  <span class="c1">#   if invert:</span>
  <span class="c1">#     return ar1 != ar2[ind]</span>
  <span class="c1">#   else:</span>
  <span class="c1">#     return ar1 == ar2[ind]</span>
  <span class="k">if</span> <span class="n">invert</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">ar1</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ar2</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">ar1</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">==</span> <span class="n">ar2</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">In the JAX version, the `assume_unique` argument is not referenced.</span>
<span class="s2">&quot;&quot;&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">setdiff1d</span><span class="p">(</span><span class="n">ar1</span><span class="p">,</span> <span class="n">ar2</span><span class="p">,</span> <span class="n">assume_unique</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
  <span class="n">ar1</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="n">asarray</span><span class="p">,</span> <span class="n">ar1</span><span class="p">,</span> <span class="s2">&quot;The error arose in setdiff1d()&quot;</span><span class="p">)</span>
  <span class="n">ar2</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="n">asarray</span><span class="p">,</span> <span class="n">ar2</span><span class="p">,</span> <span class="s2">&quot;The error arose in setdiff1d()&quot;</span><span class="p">)</span>

  <span class="n">ar1</span> <span class="o">=</span> <span class="n">unique</span><span class="p">(</span><span class="n">ar1</span><span class="p">)</span>
  <span class="n">ar2</span> <span class="o">=</span> <span class="n">unique</span><span class="p">(</span><span class="n">ar2</span><span class="p">)</span>

  <span class="n">idx</span> <span class="o">=</span> <span class="n">in1d</span><span class="p">(</span><span class="n">ar1</span><span class="p">,</span> <span class="n">ar2</span><span class="p">,</span> <span class="n">invert</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">ar1</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnums</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_intersect1d_sorted_mask</span><span class="p">(</span><span class="n">ar1</span><span class="p">,</span> <span class="n">ar2</span><span class="p">,</span> <span class="n">return_indices</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Helper function for intersect1d which is jit-able</span>
<span class="sd">    &quot;&quot;&quot;</span>
  <span class="n">ar</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">((</span><span class="n">ar1</span><span class="p">,</span> <span class="n">ar2</span><span class="p">))</span>
  <span class="k">if</span> <span class="n">return_indices</span><span class="p">:</span>
    <span class="n">iota</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">broadcasted_iota</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">shape</span><span class="p">(</span><span class="n">ar</span><span class="p">),</span> <span class="n">dimension</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">aux</span><span class="p">,</span> <span class="n">indices</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">sort_key_val</span><span class="p">(</span><span class="n">ar</span><span class="p">,</span> <span class="n">iota</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">aux</span> <span class="o">=</span> <span class="n">sort</span><span class="p">(</span><span class="n">ar</span><span class="p">)</span>

  <span class="n">mask</span> <span class="o">=</span> <span class="n">aux</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">==</span> <span class="n">aux</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
  <span class="k">if</span> <span class="n">return_indices</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">aux</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">indices</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">aux</span><span class="p">,</span> <span class="n">mask</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">intersect1d</span><span class="p">(</span><span class="n">ar1</span><span class="p">,</span> <span class="n">ar2</span><span class="p">,</span> <span class="n">assume_unique</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">return_indices</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
  <span class="n">ar1</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="n">asarray</span><span class="p">,</span> <span class="n">ar1</span><span class="p">,</span> <span class="s2">&quot;The error arose in intersect1d()&quot;</span><span class="p">)</span>
  <span class="n">ar2</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="n">asarray</span><span class="p">,</span> <span class="n">ar2</span><span class="p">,</span> <span class="s2">&quot;The error arose in intersect1d()&quot;</span><span class="p">)</span>

  <span class="k">if</span> <span class="ow">not</span> <span class="n">assume_unique</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">return_indices</span><span class="p">:</span>
      <span class="n">ar1</span><span class="p">,</span> <span class="n">ind1</span> <span class="o">=</span> <span class="n">unique</span><span class="p">(</span><span class="n">ar1</span><span class="p">,</span> <span class="n">return_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="n">ar2</span><span class="p">,</span> <span class="n">ind2</span> <span class="o">=</span> <span class="n">unique</span><span class="p">(</span><span class="n">ar2</span><span class="p">,</span> <span class="n">return_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">ar1</span> <span class="o">=</span> <span class="n">unique</span><span class="p">(</span><span class="n">ar1</span><span class="p">)</span>
      <span class="n">ar2</span> <span class="o">=</span> <span class="n">unique</span><span class="p">(</span><span class="n">ar2</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">ar1</span> <span class="o">=</span> <span class="n">ravel</span><span class="p">(</span><span class="n">ar1</span><span class="p">)</span>
    <span class="n">ar2</span> <span class="o">=</span> <span class="n">ravel</span><span class="p">(</span><span class="n">ar2</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">return_indices</span><span class="p">:</span>
    <span class="n">aux</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">aux_sort_indices</span> <span class="o">=</span> <span class="n">_intersect1d_sorted_mask</span><span class="p">(</span><span class="n">ar1</span><span class="p">,</span> <span class="n">ar2</span><span class="p">,</span> <span class="n">return_indices</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">aux</span><span class="p">,</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">_intersect1d_sorted_mask</span><span class="p">(</span><span class="n">ar1</span><span class="p">,</span> <span class="n">ar2</span><span class="p">,</span> <span class="n">return_indices</span><span class="p">)</span>

  <span class="n">int1d</span> <span class="o">=</span> <span class="n">aux</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">mask</span><span class="p">]</span>

  <span class="k">if</span> <span class="n">return_indices</span><span class="p">:</span>
    <span class="n">ar1_indices</span> <span class="o">=</span> <span class="n">aux_sort_indices</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">mask</span><span class="p">]</span>
    <span class="n">ar2_indices</span> <span class="o">=</span> <span class="n">aux_sort_indices</span><span class="p">[</span><span class="mi">1</span><span class="p">:][</span><span class="n">mask</span><span class="p">]</span> <span class="o">-</span> <span class="n">ar1</span><span class="o">.</span><span class="n">size</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">assume_unique</span><span class="p">:</span>
      <span class="n">ar1_indices</span> <span class="o">=</span> <span class="n">ind1</span><span class="p">[</span><span class="n">ar1_indices</span><span class="p">]</span>
      <span class="n">ar2_indices</span> <span class="o">=</span> <span class="n">ind2</span><span class="p">[</span><span class="n">ar2_indices</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">int1d</span><span class="p">,</span> <span class="n">ar1_indices</span><span class="p">,</span> <span class="n">ar2_indices</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">int1d</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">In the JAX version, the `assume_unique` argument is not referenced.</span>
<span class="s2">&quot;&quot;&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">isin</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">test_elements</span><span class="p">,</span> <span class="n">assume_unique</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">invert</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">in1d</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">test_elements</span><span class="p">,</span> <span class="n">assume_unique</span><span class="o">=</span><span class="n">assume_unique</span><span class="p">,</span> <span class="n">invert</span><span class="o">=</span><span class="n">invert</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">(</span><span class="n">element</span><span class="p">))</span>


<span class="c1"># The `jit` on `where` exists to avoid materializing constants in cases like</span>
<span class="c1"># `np.where(np.zeros(1000), 7, 4)`. In op-by-op mode, we don&#39;t want to</span>
<span class="c1"># materialize the broadcast forms of scalar arguments.</span>
<span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">_where</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Either both or neither of the x and y arguments should &quot;</span>
                     <span class="s2">&quot;be provided to jax.numpy.where, got </span><span class="si">{}</span><span class="s2"> and </span><span class="si">{}</span><span class="s2">.&quot;</span>
                     <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">_dtype</span><span class="p">(</span><span class="n">condition</span><span class="p">),</span> <span class="n">bool_</span><span class="p">):</span>
    <span class="n">condition</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">ne</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="n">zeros_like</span><span class="p">(</span><span class="n">condition</span><span class="p">))</span>
  <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">_promote_dtypes</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
  <span class="n">condition</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">broadcast_arrays</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">else</span> <span class="n">x</span>


<span class="n">_WHERE_DOC</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">At present, JAX does not support JIT-compilation of the single-argument form</span>
<span class="s2">of :py:func:`jax.numpy.where` because its output shape is data-dependent. The</span>
<span class="s2">three-argument form does not have a data-dependent shape and can be JIT-compiled</span>
<span class="s2">successfully.</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">,</span> <span class="n">update_doc</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_WHERE_DOC</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">where</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">nonzero</span><span class="p">(</span><span class="n">asarray</span><span class="p">(</span><span class="n">condition</span><span class="p">))</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">_where</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">select</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">select</span><span class="p">(</span><span class="n">condlist</span><span class="p">,</span> <span class="n">choicelist</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">condlist</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">choicelist</span><span class="p">):</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;condlist must have length equal to choicelist (</span><span class="si">{}</span><span class="s2"> vs </span><span class="si">{}</span><span class="s2">)&quot;</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">condlist</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">choicelist</span><span class="p">)))</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">condlist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;condlist must be non-empty&quot;</span><span class="p">)</span>
  <span class="n">choices</span> <span class="o">=</span> <span class="n">_promote_dtypes</span><span class="p">(</span><span class="n">default</span><span class="p">,</span> <span class="o">*</span><span class="n">choicelist</span><span class="p">)</span>
  <span class="n">choicelist</span> <span class="o">=</span> <span class="n">choices</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
  <span class="n">output</span> <span class="o">=</span> <span class="n">choices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="k">for</span> <span class="n">cond</span><span class="p">,</span> <span class="n">choice</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">condlist</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">choicelist</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
    <span class="n">output</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="n">choice</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">output</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">Jax adds the optional `length` parameter which specifies the output length, and</span>
<span class="s2">defaults to ``x.max() + 1``. It must be specified for bincount to be compilable.</span>
<span class="s2">Values larger than the specified length will be discarded.</span>

<span class="s2">Additionally, while ``np.bincount`` raises an error if the input array contains</span>
<span class="s2">negative values, ``jax.numpy.bincount`` treats negative values as zero.</span>
<span class="s2">&quot;&quot;&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">bincount</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">minlength</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;bincount&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">_dtype</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">integer</span><span class="p">):</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;x argument to bincount must have an integer type; got </span><span class="si">{</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="n">asarray</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span>
      <span class="s2">&quot;The error occured because of argument &#39;x&#39; of jnp.bincount. &quot;</span>
      <span class="s2">&quot;To avoid this error, pass a static `length` argument.&quot;</span><span class="p">)</span>
    <span class="n">length</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="n">length</span> <span class="o">=</span> <span class="n">_max</span><span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="n">minlength</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">ndim</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;only 1-dimensional input supported.&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">int32</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">shape</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="n">shape</span><span class="p">(</span><span class="n">weights</span><span class="p">):</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;shape of weights must match shape of x.&quot;</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">ops</span><span class="o">.</span><span class="n">index_add</span><span class="p">(</span><span class="n">zeros</span><span class="p">((</span><span class="n">length</span><span class="p">,),</span> <span class="n">_dtype</span><span class="p">(</span><span class="n">weights</span><span class="p">)),</span> <span class="n">ops</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">clip</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span> <span class="n">weights</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">broadcast_arrays</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Like Numpy&#39;s broadcast_arrays but doesn&#39;t return views.&quot;&quot;&quot;</span>
  <span class="n">shapes</span> <span class="o">=</span> <span class="p">[</span><span class="n">shape</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">shapes</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">arg</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">)</span> <span class="ow">or</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="k">else</span> <span class="n">array</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>
  <span class="n">result_shape</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">broadcast_shapes</span><span class="p">(</span><span class="o">*</span><span class="n">shapes</span><span class="p">)</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">result_shape</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">The JAX version does not necessarily return a view of the input.</span>
<span class="s2">&quot;&quot;&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">broadcast_to</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">shape</span><span class="p">):</span>
  <span class="n">arr</span> <span class="o">=</span> <span class="n">arr</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">)</span> <span class="k">else</span> <span class="n">array</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
  <span class="n">shape</span> <span class="o">=</span> <span class="n">canonicalize_shape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>  <span class="c1"># check that shape is concrete</span>
  <span class="n">arr_shape</span> <span class="o">=</span> <span class="n">_shape</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">arr_shape</span> <span class="o">==</span> <span class="n">shape</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">arr</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">nlead</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr_shape</span><span class="p">)</span>
    <span class="n">compatible</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">arr_shape</span><span class="p">,</span> <span class="n">shape</span><span class="p">[</span><span class="n">nlead</span><span class="p">:])</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">arr_shape</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">nlead</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">compatible</span><span class="p">):</span>
      <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Incompatible shapes for broadcasting: </span><span class="si">{}</span><span class="s2"> and requested shape </span><span class="si">{}</span><span class="s2">&quot;</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">arr_shape</span><span class="p">,</span> <span class="n">shape</span><span class="p">))</span>
    <span class="n">diff</span><span class="p">,</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">not_equal</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="n">nlead</span><span class="p">:],</span> <span class="n">arr_shape</span><span class="p">))</span>
    <span class="n">new_dims</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">nlead</span><span class="p">))</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">nlead</span> <span class="o">+</span> <span class="n">diff</span><span class="p">)</span>
    <span class="n">kept_dims</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)),</span> <span class="n">new_dims</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">broadcast_in_dim</span><span class="p">(</span><span class="n">squeeze</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">diff</span><span class="p">)),</span> <span class="n">shape</span><span class="p">,</span> <span class="n">kept_dims</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_split</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">ary</span><span class="p">,</span> <span class="n">indices_or_sections</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
  <span class="n">axis</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;in jax.numpy.</span><span class="si">{</span><span class="n">op</span><span class="si">}</span><span class="s2"> argument `axis`&quot;</span><span class="p">)</span>
  <span class="n">size</span> <span class="o">=</span> <span class="n">ary</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indices_or_sections</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="o">+</span> <span class="n">_arraylike_types</span><span class="p">):</span>
    <span class="n">indices_or_sections</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">[</span><span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">i_s</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;in jax.numpy.</span><span class="si">{</span><span class="n">op</span><span class="si">}</span><span class="s2"> argument 1&quot;</span><span class="p">)</span>
         <span class="k">for</span> <span class="n">i_s</span> <span class="ow">in</span> <span class="n">indices_or_sections</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
    <span class="n">split_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([[</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="mi">0</span><span class="p">)],</span> <span class="n">indices_or_sections</span><span class="p">,</span>
                                    <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="n">size</span><span class="p">)]])</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">indices_or_sections</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">indices_or_sections</span><span class="p">,</span>
                                                 <span class="sa">f</span><span class="s2">&quot;in jax.numpy.</span><span class="si">{</span><span class="n">op</span><span class="si">}</span><span class="s2"> argument 1&quot;</span><span class="p">)</span>
    <span class="n">part_size</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">_divmod</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">indices_or_sections</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">r</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
      <span class="n">split_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">indices_or_sections</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                                <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span> <span class="o">*</span> <span class="n">part_size</span>
    <span class="k">elif</span> <span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;array_split&quot;</span><span class="p">:</span>
      <span class="n">split_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
          <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">part_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
           <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">indices_or_sections</span> <span class="o">-</span> <span class="n">r</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span> <span class="o">*</span> <span class="n">part_size</span>
           <span class="o">+</span> <span class="p">((</span><span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">part_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)])</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;array split does not result in an equal division&quot;</span><span class="p">)</span>
  <span class="n">starts</span><span class="p">,</span> <span class="n">ends</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">ndim</span><span class="p">(</span><span class="n">ary</span><span class="p">),</span> <span class="n">shape</span><span class="p">(</span><span class="n">ary</span><span class="p">)</span>
  <span class="n">_subval</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">subvals</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">v</span><span class="p">)])</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">lax</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="n">ary</span><span class="p">,</span> <span class="n">_subval</span><span class="p">(</span><span class="n">starts</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">start</span><span class="p">),</span> <span class="n">_subval</span><span class="p">(</span><span class="n">ends</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">end</span><span class="p">))</span>
          <span class="k">for</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">split_indices</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">split_indices</span><span class="p">[</span><span class="mi">1</span><span class="p">:])]</span>

<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">split</span><span class="p">(</span><span class="n">ary</span><span class="p">,</span> <span class="n">indices_or_sections</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">_split</span><span class="p">(</span><span class="s2">&quot;split&quot;</span><span class="p">,</span> <span class="n">ary</span><span class="p">,</span> <span class="n">indices_or_sections</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_split_on_axis</span><span class="p">(</span><span class="n">np_fun</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
  <span class="nd">@_wraps</span><span class="p">(</span><span class="n">np_fun</span><span class="p">,</span> <span class="n">update_doc</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
  <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">ary</span><span class="p">,</span> <span class="n">indices_or_sections</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">split</span><span class="p">(</span><span class="n">ary</span><span class="p">,</span> <span class="n">indices_or_sections</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">f</span>

<span class="n">vsplit</span> <span class="o">=</span> <span class="n">_split_on_axis</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vsplit</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">hsplit</span> <span class="o">=</span> <span class="n">_split_on_axis</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hsplit</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">dsplit</span> <span class="o">=</span> <span class="n">_split_on_axis</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dsplit</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array_split</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">array_split</span><span class="p">(</span><span class="n">ary</span><span class="p">,</span> <span class="n">indices_or_sections</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">_split</span><span class="p">(</span><span class="s2">&quot;array_split&quot;</span><span class="p">,</span> <span class="n">ary</span><span class="p">,</span> <span class="n">indices_or_sections</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">clip</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a_min</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">a_max</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;clip&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;The &#39;out&#39; argument to jnp.clip is not supported.&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">a_min</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">a_max</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;At most one of a_min and a_max may be None&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">a_min</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">maximum</span><span class="p">(</span><span class="n">a_min</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">a_max</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">minimum</span><span class="p">(</span><span class="n">a_max</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">a</span>

<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">,</span> <span class="n">update_doc</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">round</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">decimals</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;round&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;The &#39;out&#39; argument to jnp.round is not supported.&quot;</span><span class="p">)</span>
  <span class="n">dtype</span> <span class="o">=</span> <span class="n">_dtype</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">integer</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">decimals</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
        <span class="s2">&quot;integer np.round not implemented for decimals &lt; 0&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">a</span>  <span class="c1"># no-op on integer types</span>

  <span class="k">def</span> <span class="nf">_round_float</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">decimals</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">RoundingMethod</span><span class="o">.</span><span class="n">TO_NEAREST_EVEN</span><span class="p">)</span>

    <span class="c1"># TODO(phawkins): the strategy of rescaling the value isn&#39;t necessarily a</span>
    <span class="c1"># good one since we may be left with an incorrectly rounded value at the</span>
    <span class="c1"># end due to precision problems. As a workaround for float16, convert to</span>
    <span class="c1"># float32,</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">convert_element_type</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span> <span class="k">if</span> <span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">float16</span> <span class="k">else</span> <span class="n">x</span>
    <span class="n">factor</span> <span class="o">=</span> <span class="n">_constant_like</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">10</span> <span class="o">**</span> <span class="n">decimals</span><span class="p">)</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">div</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">factor</span><span class="p">),</span>
                            <span class="n">lax</span><span class="o">.</span><span class="n">RoundingMethod</span><span class="o">.</span><span class="n">TO_NEAREST_EVEN</span><span class="p">),</span> <span class="n">factor</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">convert_element_type</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span> <span class="k">if</span> <span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">float16</span> <span class="k">else</span> <span class="n">out</span>

  <span class="k">if</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">complexfloating</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">complex</span><span class="p">(</span><span class="n">_round_float</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">a</span><span class="p">)),</span> <span class="n">_round_float</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">a</span><span class="p">)))</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">_round_float</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="n">around</span> <span class="o">=</span> <span class="nb">round</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fix</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">fix</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;fix&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;The &#39;out&#39; argument to jnp.fix is not supported.&quot;</span><span class="p">)</span>
  <span class="n">zero</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">_const</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">where</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">ge</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">zero</span><span class="p">),</span> <span class="n">floor</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">ceil</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">modf</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">modf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;modf&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;The &#39;out&#39; argument to jnp.modf is not supported.&quot;</span><span class="p">)</span>
  <span class="n">whole</span> <span class="o">=</span> <span class="n">fix</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">x</span> <span class="o">-</span> <span class="n">whole</span><span class="p">,</span> <span class="n">whole</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">isfinite</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;isfinite&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
  <span class="n">dtype</span> <span class="o">=</span> <span class="n">_dtype</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">floating</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">is_finite</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="k">elif</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">complexfloating</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">bitwise_and</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">is_finite</span><span class="p">(</span><span class="n">real</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span> <span class="n">lax</span><span class="o">.</span><span class="n">is_finite</span><span class="p">(</span><span class="n">imag</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">full_like</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">bool_</span><span class="p">)</span>

<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">isinf</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;isinf&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
  <span class="n">dtype</span> <span class="o">=</span> <span class="n">_dtype</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">floating</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">_constant_like</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">inf</span><span class="p">))</span>
  <span class="k">elif</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">complexfloating</span><span class="p">):</span>
    <span class="n">re</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">im</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">bitwise_or</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">re</span><span class="p">),</span> <span class="n">_constant_like</span><span class="p">(</span><span class="n">re</span><span class="p">,</span> <span class="n">inf</span><span class="p">)),</span>
                          <span class="n">lax</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">im</span><span class="p">),</span> <span class="n">_constant_like</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">inf</span><span class="p">)))</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">full_like</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">bool_</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_isposneginf</span><span class="p">(</span><span class="n">infinity</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">out</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;The &#39;out&#39; argument to isneginf/isposinf is not supported.&quot;</span><span class="p">)</span>
  <span class="n">dtype</span> <span class="o">=</span> <span class="n">_dtype</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">floating</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">_constant_like</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">infinity</span><span class="p">))</span>
  <span class="k">elif</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">complexfloating</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;isposinf/isneginf are not well defined for complex types&quot;</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">full_like</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">bool_</span><span class="p">)</span>

<span class="n">isposinf</span> <span class="o">=</span> <span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isposinf</span><span class="p">)(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">:</span> <span class="n">_isposneginf</span><span class="p">(</span><span class="n">inf</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">out</span><span class="p">))</span>

<span class="n">isneginf</span> <span class="o">=</span> <span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isneginf</span><span class="p">)(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">:</span> <span class="n">_isposneginf</span><span class="p">(</span><span class="o">-</span><span class="n">inf</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">out</span><span class="p">))</span>

<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">isnan</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;isnan&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">ne</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">nan_to_num</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nan</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">posinf</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">neginf</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="k">del</span> <span class="n">copy</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;nan_to_num&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
  <span class="n">dtype</span> <span class="o">=</span> <span class="n">_dtype</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">complexfloating</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">complex</span><span class="p">(</span>
      <span class="n">nan_to_num</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">nan</span><span class="o">=</span><span class="n">nan</span><span class="p">,</span> <span class="n">posinf</span><span class="o">=</span><span class="n">posinf</span><span class="p">,</span> <span class="n">neginf</span><span class="o">=</span><span class="n">neginf</span><span class="p">),</span>
      <span class="n">nan_to_num</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">nan</span><span class="o">=</span><span class="n">nan</span><span class="p">,</span> <span class="n">posinf</span><span class="o">=</span><span class="n">posinf</span><span class="p">,</span> <span class="n">neginf</span><span class="o">=</span><span class="n">neginf</span><span class="p">))</span>
  <span class="n">info</span> <span class="o">=</span> <span class="n">finfo</span><span class="p">(</span><span class="n">dtypes</span><span class="o">.</span><span class="n">canonicalize_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">))</span>
  <span class="n">posinf</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">max</span> <span class="k">if</span> <span class="n">posinf</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">posinf</span>
  <span class="n">neginf</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">min</span> <span class="k">if</span> <span class="n">neginf</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">neginf</span>
  <span class="n">x</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">isnan</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">_constant_like</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">nan</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span>
  <span class="n">x</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">isposinf</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">_constant_like</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">posinf</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span>
  <span class="n">x</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">isneginf</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">_constant_like</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">neginf</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">x</span>

<span class="c1">### Reducers</span>

<span class="k">def</span> <span class="nf">_reduction</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">np_fun</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">init_val</span><span class="p">,</span> <span class="n">has_identity</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
               <span class="n">preproc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bool_op</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">upcast_f16_for_computation</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
               <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">initial</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">where_</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="n">bool_op</span> <span class="o">=</span> <span class="n">bool_op</span> <span class="ow">or</span> <span class="n">op</span>
  <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The &#39;out&#39; argument to jnp.</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> is not supported.&quot;</span><span class="p">)</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="n">lax</span><span class="o">.</span><span class="n">_check_user_dtype_supported</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
  <span class="n">axis</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;axis argument to jnp.</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">().&quot;</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">initial</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">has_identity</span><span class="p">:</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">size</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;zero-size array to reduction operation </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> which has no identity&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">where_</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;reduction operation </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> does not have an identity, so to use a &quot;</span>
                       <span class="sa">f</span><span class="s2">&quot;where mask one has to specify &#39;initial&#39;&quot;</span><span class="p">)</span>

  <span class="n">a</span> <span class="o">=</span> <span class="n">a</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">)</span> <span class="k">else</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">preproc</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">if</span> <span class="n">preproc</span> <span class="k">else</span> <span class="n">a</span>
  <span class="n">dims</span> <span class="o">=</span> <span class="n">_reduction_dims</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
  <span class="n">result_dtype</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">canonicalize_dtype</span><span class="p">(</span><span class="n">dtype</span> <span class="ow">or</span> <span class="n">_dtype</span><span class="p">(</span><span class="n">np_fun</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">_dtype</span><span class="p">(</span><span class="n">a</span><span class="p">)))))</span>
  <span class="k">if</span> <span class="n">upcast_f16_for_computation</span> <span class="ow">and</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">result_dtype</span><span class="p">,</span> <span class="n">inexact</span><span class="p">):</span>
    <span class="n">computation_dtype</span> <span class="o">=</span> <span class="n">promote_types</span><span class="p">(</span><span class="n">result_dtype</span><span class="p">,</span> <span class="n">float32</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">computation_dtype</span> <span class="o">=</span> <span class="n">result_dtype</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">convert_element_type</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">computation_dtype</span><span class="p">)</span>
  <span class="n">op</span> <span class="o">=</span> <span class="n">op</span> <span class="k">if</span> <span class="n">computation_dtype</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span> <span class="k">else</span> <span class="n">bool_op</span>
  <span class="c1"># NB: in XLA, init_val must be an identity for the op, so the user-specified</span>
  <span class="c1"># initial value must be applied afterward.</span>
  <span class="n">init_val</span> <span class="o">=</span> <span class="n">_reduction_init_val</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">init_val</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">where_</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">where_</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">init_val</span><span class="p">)</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">init_val</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">dims</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">initial</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">_reduction_init_val</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">initial</span><span class="p">),</span> <span class="n">result</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">keepdims</span><span class="p">:</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">expand_dims</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">dims</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">convert_element_type</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">dtype</span> <span class="ow">or</span> <span class="n">result_dtype</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_reduction_dims</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">)))</span>
  <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
    <span class="n">axis</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">axis</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">axis</span><span class="p">)):</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;duplicate value in &#39;axis&#39;: </span><span class="si">{</span><span class="n">axis</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">axis</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">)),)</span>

<span class="k">def</span> <span class="nf">_reduction_init_val</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">init_val</span><span class="p">):</span>
  <span class="n">a_dtype</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">canonicalize_dtype</span><span class="p">(</span><span class="n">_dtype</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
  <span class="k">if</span> <span class="n">a_dtype</span> <span class="o">==</span> <span class="s1">&#39;bool&#39;</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">init_val</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">a_dtype</span><span class="p">)</span>
  <span class="k">try</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">init_val</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">a_dtype</span><span class="p">)</span>
  <span class="k">except</span> <span class="ne">OverflowError</span><span class="p">:</span>
    <span class="k">assert</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">a_dtype</span><span class="p">,</span> <span class="n">integer</span><span class="p">)</span>
    <span class="n">sign</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">init_val</span><span class="p">),</span> <span class="n">iinfo</span><span class="p">(</span><span class="n">a_dtype</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">info</span><span class="o">.</span><span class="n">min</span> <span class="k">if</span> <span class="n">sign</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">info</span><span class="o">.</span><span class="n">max</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">a_dtype</span><span class="p">)</span>

<span class="n">_cast_to_bool</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">convert_element_type</span><span class="p">,</span> <span class="n">new_dtype</span><span class="o">=</span><span class="n">bool_</span><span class="p">)</span>

<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">sum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">initial</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">_reduction</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s2">&quot;sum&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">add</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
                    <span class="n">bool_op</span><span class="o">=</span><span class="n">lax</span><span class="o">.</span><span class="n">bitwise_or</span><span class="p">,</span> <span class="n">upcast_f16_for_computation</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">,</span> <span class="n">initial</span><span class="o">=</span><span class="n">initial</span><span class="p">,</span> <span class="n">where_</span><span class="o">=</span><span class="n">where</span><span class="p">)</span>

<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">prod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
         <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">initial</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">_reduction</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s2">&quot;prod&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">mul</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
                    <span class="n">bool_op</span><span class="o">=</span><span class="n">lax</span><span class="o">.</span><span class="n">bitwise_and</span><span class="p">,</span> <span class="n">upcast_f16_for_computation</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">,</span> <span class="n">initial</span><span class="o">=</span><span class="n">initial</span><span class="p">,</span> <span class="n">where_</span><span class="o">=</span><span class="n">where</span><span class="p">)</span>

<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">max</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">keepdims</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">initial</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">_reduction</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s2">&quot;max&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">max</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">has_identity</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">,</span> <span class="n">initial</span><span class="o">=</span><span class="n">initial</span><span class="p">,</span> <span class="n">where_</span><span class="o">=</span><span class="n">where</span><span class="p">)</span>

<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">min</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">keepdims</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">initial</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">_reduction</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s2">&quot;min&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">min</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">has_identity</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">,</span> <span class="n">initial</span><span class="o">=</span><span class="n">initial</span><span class="p">,</span> <span class="n">where_</span><span class="o">=</span><span class="n">where</span><span class="p">)</span>

<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">all</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">keepdims</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">_reduction</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s2">&quot;all&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">bitwise_and</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">preproc</span><span class="o">=</span><span class="n">_cast_to_bool</span><span class="p">,</span>
                    <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span>

<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">any</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">keepdims</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">_reduction</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s2">&quot;any&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">bitwise_or</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">preproc</span><span class="o">=</span><span class="n">_cast_to_bool</span><span class="p">,</span>
                    <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span>

<span class="n">product</span> <span class="o">=</span> <span class="n">prod</span>
<span class="n">amin</span> <span class="o">=</span> <span class="nb">min</span>
<span class="n">amax</span> <span class="o">=</span> <span class="nb">max</span>
<span class="n">alltrue</span> <span class="o">=</span> <span class="nb">all</span>
<span class="n">sometrue</span> <span class="o">=</span> <span class="nb">any</span>

<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">mean</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
         <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;mean&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="n">lax</span><span class="o">.</span><span class="n">_check_user_dtype_supported</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="s2">&quot;mean&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;The &#39;out&#39; argument to jnp.mean is not supported.&quot;</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">normalizer</span> <span class="o">=</span> <span class="n">size</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">normalizer</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">shape</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">axis</span><span class="p">))</span>
  <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">_dtype</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">bool_</span><span class="p">)</span> <span class="ow">or</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">_dtype</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">integer</span><span class="p">):</span>
      <span class="n">dtype</span> <span class="o">=</span> <span class="n">float_</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">dtype</span> <span class="o">=</span> <span class="n">_dtype</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
  <span class="n">dtype</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">canonicalize_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>

  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">div</span><span class="p">(</span>
      <span class="nb">sum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">),</span>
      <span class="n">lax</span><span class="o">.</span><span class="n">convert_element_type</span><span class="p">(</span><span class="n">normalizer</span><span class="p">,</span> <span class="n">dtype</span><span class="p">))</span>

<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">average</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">returned</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># Treat all weights as 1</span>
    <span class="n">avg</span> <span class="o">=</span> <span class="n">mean</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
      <span class="n">weights_sum</span> <span class="o">=</span> <span class="n">full</span><span class="p">((),</span> <span class="n">size</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">avg</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">weights_sum</span> <span class="o">=</span> <span class="n">full_like</span><span class="p">(</span><span class="n">avg</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">avg</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">inexact</span><span class="p">):</span>
      <span class="n">out_dtype</span> <span class="o">=</span> <span class="n">result_type</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">weights</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">out_dtype</span> <span class="o">=</span> <span class="n">result_type</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">weights</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">float_</span><span class="p">)</span>
    <span class="n">out_dtype</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">canonicalize_dtype</span><span class="p">(</span><span class="n">out_dtype</span><span class="p">)</span>

    <span class="n">a_shape</span> <span class="o">=</span> <span class="n">shape</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">a_ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a_shape</span><span class="p">)</span>
    <span class="n">weights_shape</span> <span class="o">=</span> <span class="n">shape</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
    <span class="n">axis</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">a_ndim</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">a_shape</span> <span class="o">!=</span> <span class="n">weights_shape</span><span class="p">:</span>
      <span class="c1"># Make sure the dimensions work out</span>
      <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Axis must be specified when shapes of a and &quot;</span>
                         <span class="s2">&quot;weights differ.&quot;</span><span class="p">)</span>
      <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">weights_shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;1D weights expected when shapes of a and &quot;</span>
                         <span class="s2">&quot;weights differ.&quot;</span><span class="p">)</span>
      <span class="k">if</span> <span class="n">weights_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">a_shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Length of weights not &quot;</span>
                         <span class="s2">&quot;compatible with specified axis.&quot;</span><span class="p">)</span>

      <span class="n">weights</span> <span class="o">=</span> <span class="n">broadcast_to</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="p">(</span><span class="n">a_ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">+</span> <span class="n">weights_shape</span><span class="p">)</span>
      <span class="n">weights</span> <span class="o">=</span> <span class="n">moveaxis</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

    <span class="n">weights_sum</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">out_dtype</span><span class="p">)</span>
    <span class="n">avg</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">multiply</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">weights</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">out_dtype</span><span class="p">)</span> <span class="o">/</span> <span class="n">weights_sum</span>

  <span class="k">if</span> <span class="n">returned</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">avg</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">weights_sum</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
      <span class="n">weights_sum</span> <span class="o">=</span> <span class="n">broadcast_to</span><span class="p">(</span><span class="n">weights_sum</span><span class="p">,</span> <span class="n">avg</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">avg</span><span class="p">,</span> <span class="n">weights_sum</span>
  <span class="k">return</span> <span class="n">avg</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">var</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;var&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="n">lax</span><span class="o">.</span><span class="n">_check_user_dtype_supported</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="s2">&quot;var&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;The &#39;out&#39; argument to jnp.var is not supported.&quot;</span><span class="p">)</span>

  <span class="n">a_dtype</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">_var_promote_types</span><span class="p">(</span><span class="n">_dtype</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">dtype</span><span class="p">)</span>
  <span class="n">a_mean</span> <span class="o">=</span> <span class="n">mean</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">a_dtype</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
  <span class="n">centered</span> <span class="o">=</span> <span class="n">a</span> <span class="o">-</span> <span class="n">a_mean</span>
  <span class="k">if</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">centered</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">complexfloating</span><span class="p">):</span>
    <span class="n">centered</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">centered</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">centered</span><span class="p">)))</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">centered</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">centered</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">normalizer</span> <span class="o">=</span> <span class="n">size</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">normalizer</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">shape</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">axis</span><span class="p">))</span>
  <span class="n">normalizer</span> <span class="o">=</span> <span class="n">normalizer</span> <span class="o">-</span> <span class="n">ddof</span>

  <span class="n">result</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">centered</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span>
  <span class="n">out</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">div</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">convert_element_type</span><span class="p">(</span><span class="n">normalizer</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">convert_element_type</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_var_promote_types</span><span class="p">(</span><span class="n">a_dtype</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">dtype</span><span class="p">:</span>
    <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">complexfloating</span><span class="p">)</span> <span class="ow">and</span>
        <span class="n">issubdtype</span><span class="p">(</span><span class="n">a_dtype</span><span class="p">,</span> <span class="n">complexfloating</span><span class="p">)):</span>
      <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;jax.numpy.var does not yet support real dtype parameters when &quot;</span>
             <span class="s2">&quot;computing the variance of an array of complex values. The &quot;</span>
             <span class="s2">&quot;semantics of numpy.var seem unclear in this case. Please comment &quot;</span>
             <span class="s2">&quot;on https://github.com/google/jax/issues/2283 if this behavior is &quot;</span>
             <span class="s2">&quot;important to you.&quot;</span><span class="p">)</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="n">a_dtype</span> <span class="o">=</span> <span class="n">promote_types</span><span class="p">(</span><span class="n">a_dtype</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">a_dtype</span><span class="p">,</span> <span class="n">inexact</span><span class="p">):</span>
      <span class="n">dtype</span> <span class="o">=</span> <span class="n">a_dtype</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">canonicalize_dtype</span><span class="p">(</span><span class="n">float_</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">dtype</span> <span class="o">=</span> <span class="n">_complex_elem_type</span><span class="p">(</span><span class="n">a_dtype</span><span class="p">)</span>
      <span class="n">a_dtype</span> <span class="o">=</span> <span class="n">promote_types</span><span class="p">(</span><span class="n">a_dtype</span><span class="p">,</span> <span class="n">float32</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">a_dtype</span><span class="p">,</span> <span class="n">dtype</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">std</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;std&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="n">lax</span><span class="o">.</span><span class="n">_check_user_dtype_supported</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="s2">&quot;std&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;The &#39;out&#39; argument to jnp.std is not supported.&quot;</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">var</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="n">ddof</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">))</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ptp</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">ptp</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;ptp&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;The &#39;out&#39; argument to jnp.ptp is not supported.&quot;</span><span class="p">)</span>
  <span class="n">x</span> <span class="o">=</span> <span class="n">amax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span>
  <span class="n">y</span> <span class="o">=</span> <span class="n">amin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">allclose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">1e-05</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-08</span><span class="p">,</span> <span class="n">equal_nan</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
  <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">isclose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">rtol</span><span class="p">,</span> <span class="n">atol</span><span class="p">,</span> <span class="n">equal_nan</span><span class="p">))</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">count_nonzero</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                  <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;count_nonzero&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">ne</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">_constant_like</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
             <span class="n">dtype</span><span class="o">=</span><span class="n">dtypes</span><span class="o">.</span><span class="n">canonicalize_dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int_</span><span class="p">),</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span>


<span class="n">_NONZERO_DOC</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">At present, JAX does not support JIT-compilation of :py:func:`jax.numpy.nonzero`</span>
<span class="s2">because its output shape is data-dependent.</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_NONZERO_DOC</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">nonzero</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
  <span class="c1"># Note: this function cannot be jitted because its output has a dynamic</span>
  <span class="c1"># shape.</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="n">atleast_1d</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="s2">&quot;The error arose in jnp.nonzero&quot;</span><span class="p">)</span>
  <span class="n">dims</span> <span class="o">=</span> <span class="n">shape</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
  <span class="n">ndims</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span>
  <span class="n">ds</span> <span class="o">=</span> <span class="p">[</span><span class="n">lax</span><span class="o">.</span><span class="n">broadcasted_iota</span><span class="p">(</span><span class="n">int_</span><span class="p">,</span> <span class="n">dims</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="p">,),</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndims</span><span class="p">)]</span>
  <span class="n">d</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
  <span class="n">indexes</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">a</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>
  <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">indexes</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndims</span><span class="p">))</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">flatnonzero</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">nonzero</span><span class="p">(</span><span class="n">ravel</span><span class="p">(</span><span class="n">a</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_nan_reduction</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">jnp_reduction</span><span class="p">,</span> <span class="n">init_val</span><span class="p">,</span> <span class="n">nan_if_all_nan</span><span class="p">,</span>
                   <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="n">out</span> <span class="o">=</span> <span class="n">jnp_reduction</span><span class="p">(</span><span class="n">where</span><span class="p">(</span><span class="n">isnan</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">_reduction_init_val</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">init_val</span><span class="p">),</span> <span class="n">a</span><span class="p">),</span>
                      <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">nan_if_all_nan</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">where</span><span class="p">(</span><span class="nb">all</span><span class="p">(</span><span class="n">isnan</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">),</span>
                  <span class="n">_constant_like</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">nan</span><span class="p">),</span> <span class="n">out</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">out</span>

<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">nanmin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
           <span class="n">keepdims</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">_nan_reduction</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;nanmin&#39;</span><span class="p">,</span> <span class="nb">min</span><span class="p">,</span> <span class="n">inf</span><span class="p">,</span> <span class="n">nan_if_all_nan</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span>

<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">nanmax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
           <span class="n">keepdims</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">_nan_reduction</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;nanmax&#39;</span><span class="p">,</span> <span class="nb">max</span><span class="p">,</span> <span class="o">-</span><span class="n">inf</span><span class="p">,</span> <span class="n">nan_if_all_nan</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span>

<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">nansum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
           <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">_nan_reduction</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;nansum&#39;</span><span class="p">,</span> <span class="nb">sum</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nan_if_all_nan</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span>

<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanprod</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">nanprod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">_nan_reduction</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;nanprod&#39;</span><span class="p">,</span> <span class="n">prod</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nan_if_all_nan</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span>

<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">nanmean</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;nanmean&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="n">lax</span><span class="o">.</span><span class="n">_check_user_dtype_supported</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="s2">&quot;nanmean&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;The &#39;out&#39; argument to jnp.nanmean is not supported.&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">_dtype</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">bool_</span><span class="p">)</span> <span class="ow">or</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">_dtype</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">integer</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">mean</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">keepdims</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">_dtype</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
  <span class="n">nan_mask</span> <span class="o">=</span> <span class="n">logical_not</span><span class="p">(</span><span class="n">isnan</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
  <span class="n">normalizer</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">nan_mask</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">int32</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span>
  <span class="n">normalizer</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">convert_element_type</span><span class="p">(</span><span class="n">normalizer</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
  <span class="n">td</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">div</span><span class="p">(</span><span class="n">nansum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">),</span> <span class="n">normalizer</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">td</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanvar</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">nanvar</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
           <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;nanvar&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="n">lax</span><span class="o">.</span><span class="n">_check_user_dtype_supported</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="s2">&quot;nanvar&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;The &#39;out&#39; argument to jnp.nanvar is not supported.&quot;</span><span class="p">)</span>

  <span class="n">a_dtype</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">_var_promote_types</span><span class="p">(</span><span class="n">_dtype</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">dtype</span><span class="p">)</span>
  <span class="n">a_mean</span> <span class="o">=</span> <span class="n">nanmean</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">a_dtype</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
  <span class="n">centered</span> <span class="o">=</span> <span class="n">a</span> <span class="o">-</span> <span class="n">a_mean</span>
  <span class="k">if</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">centered</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">complexfloating</span><span class="p">):</span>
    <span class="n">centered</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">centered</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">centered</span><span class="p">)))</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">centered</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">centered</span><span class="p">)</span>

  <span class="n">normalizer</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">logical_not</span><span class="p">(</span><span class="n">isnan</span><span class="p">(</span><span class="n">a</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span>
  <span class="n">normalizer</span> <span class="o">=</span> <span class="n">normalizer</span> <span class="o">-</span> <span class="n">ddof</span>
  <span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">omnistaging_enabled</span><span class="p">:</span>
    <span class="n">normalizer_mask</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">le</span><span class="p">(</span><span class="n">normalizer</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">zero</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">normalizer</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">())</span>
    <span class="n">normalizer_mask</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">le</span><span class="p">(</span><span class="n">normalizer</span><span class="p">,</span> <span class="n">zero</span><span class="p">)</span>

  <span class="n">result</span> <span class="o">=</span> <span class="n">nansum</span><span class="p">(</span><span class="n">centered</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">normalizer_mask</span><span class="p">,</span> <span class="n">nan</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
  <span class="n">divisor</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">normalizer_mask</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">normalizer</span><span class="p">)</span>
  <span class="n">out</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">div</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">convert_element_type</span><span class="p">(</span><span class="n">divisor</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">convert_element_type</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">nanstd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
           <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;nanstd&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="n">lax</span><span class="o">.</span><span class="n">_check_user_dtype_supported</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="s2">&quot;nanstd&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;The &#39;out&#39; argument to jnp.nanstd is not supported.&quot;</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">nanvar</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="n">ddof</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_make_cumulative_reduction</span><span class="p">(</span><span class="n">np_reduction</span><span class="p">,</span> <span class="n">reduction</span><span class="p">,</span> <span class="n">fill_nan</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
  <span class="c1"># We want to allow XLA to fuse the pad and reduce-window operators to</span>
  <span class="c1"># avoid materializing the padded output.</span>
  <span class="c1"># Consider removing `jit` once again if reduce-window is generalized to</span>
  <span class="c1"># support arbitrary padding.</span>
  <span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnums</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
  <span class="k">def</span> <span class="nf">_cumulative_reduction</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
      <span class="n">a</span> <span class="o">=</span> <span class="n">ravel</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
      <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">a_shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">shape</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
    <span class="n">num_dims</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a_shape</span><span class="p">)</span>
    <span class="n">axis</span> <span class="o">=</span> <span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">num_dims</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">fill_nan</span><span class="p">:</span>
      <span class="n">a</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">isnan</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">_constant_like</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">),</span> <span class="n">a</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">dtype</span> <span class="ow">and</span> <span class="n">_dtype</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="n">bool_</span><span class="p">:</span>
      <span class="n">dtype</span> <span class="o">=</span> <span class="n">int_</span>
    <span class="k">if</span> <span class="n">dtype</span><span class="p">:</span>
      <span class="n">a</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">convert_element_type</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">reduction</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

  <span class="nd">@_wraps</span><span class="p">(</span><span class="n">np_reduction</span><span class="p">)</span>
  <span class="k">def</span> <span class="nf">cumulative_reduction</span><span class="p">(</span><span class="n">a</span><span class="p">,</span>
                           <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                           <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">_check_arraylike</span><span class="p">(</span><span class="n">np_reduction</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The &#39;out&#39; argument to jnp.</span><span class="si">{</span><span class="n">np_reduction</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;is not supported.&quot;</span><span class="p">)</span>
    <span class="n">lax</span><span class="o">.</span><span class="n">_check_user_dtype_supported</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np_reduction</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
    <span class="c1"># jit doesn&#39;t support kwargs as static_args.</span>
    <span class="k">return</span> <span class="n">_cumulative_reduction</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">cumulative_reduction</span>


<span class="n">cumsum</span> <span class="o">=</span> <span class="n">_make_cumulative_reduction</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">cumsum</span><span class="p">,</span> <span class="n">fill_nan</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">cumprod</span> <span class="o">=</span> <span class="n">_make_cumulative_reduction</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cumprod</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">cumprod</span><span class="p">,</span> <span class="n">fill_nan</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">cumproduct</span> <span class="o">=</span> <span class="n">cumprod</span>
<span class="n">nancumsum</span> <span class="o">=</span> <span class="n">_make_cumulative_reduction</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nancumsum</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">cumsum</span><span class="p">,</span>
                                       <span class="n">fill_nan</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">nancumprod</span> <span class="o">=</span> <span class="n">_make_cumulative_reduction</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nancumprod</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">cumprod</span><span class="p">,</span>
                                        <span class="n">fill_nan</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unwrap</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">unwrap</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">discont</span><span class="o">=</span><span class="n">pi</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;unwrap&quot;</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
  <span class="n">dd</span> <span class="o">=</span> <span class="n">diff</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
  <span class="n">ddmod</span> <span class="o">=</span> <span class="n">mod</span><span class="p">(</span><span class="n">dd</span> <span class="o">+</span> <span class="n">pi</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">pi</span><span class="p">)</span> <span class="o">-</span> <span class="n">pi</span>
  <span class="n">ddmod</span> <span class="o">=</span> <span class="n">where</span><span class="p">((</span><span class="n">ddmod</span> <span class="o">==</span> <span class="o">-</span><span class="n">pi</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">dd</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">),</span> <span class="n">pi</span><span class="p">,</span> <span class="n">ddmod</span><span class="p">)</span>

  <span class="n">ph_correct</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">dd</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">discont</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ddmod</span> <span class="o">-</span> <span class="n">dd</span><span class="p">)</span>

  <span class="n">up</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">((</span>
    <span class="n">lax</span><span class="o">.</span><span class="n">slice_in_dim</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">),</span>
    <span class="n">lax</span><span class="o">.</span><span class="n">slice_in_dim</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span> <span class="o">+</span> <span class="n">cumsum</span><span class="p">(</span><span class="n">ph_correct</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
  <span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

  <span class="k">return</span> <span class="n">up</span>


<span class="c1">### Array-creation functions</span>

<span class="k">def</span> <span class="nf">_check_no_padding</span><span class="p">(</span><span class="n">axis_padding</span><span class="p">,</span> <span class="n">mode</span><span class="p">):</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">axis_padding</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">axis_padding</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Cannot apply &#39;</span><span class="si">{}</span><span class="s2">&#39; padding to empty axis&quot;</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_pad_constant</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">,</span> <span class="n">constant_values</span><span class="p">):</span>
  <span class="n">nd</span> <span class="o">=</span> <span class="n">ndim</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
  <span class="n">constant_values</span> <span class="o">=</span> <span class="n">broadcast_to</span><span class="p">(</span><span class="n">asarray</span><span class="p">(</span><span class="n">constant_values</span><span class="p">),</span> <span class="p">(</span><span class="n">nd</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
  <span class="n">constant_values</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">convert_element_type</span><span class="p">(</span><span class="n">constant_values</span><span class="p">,</span> <span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nd</span><span class="p">):</span>
    <span class="n">widths</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span> <span class="o">*</span> <span class="n">nd</span>
    <span class="n">widths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">pad_width</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">array</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">constant_values</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">widths</span><span class="p">)</span>
    <span class="n">widths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">array</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">constant_values</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">widths</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">array</span>


<span class="k">def</span> <span class="nf">_pad_wrap</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">):</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndim</span><span class="p">(</span><span class="n">array</span><span class="p">)):</span>
    <span class="k">if</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
      <span class="n">_check_no_padding</span><span class="p">(</span><span class="n">pad_width</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="s2">&quot;wrap&quot;</span><span class="p">)</span>
      <span class="k">continue</span>
    <span class="n">size</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="n">repeats</span><span class="p">,</span> <span class="p">(</span><span class="n">left_remainder</span><span class="p">,</span> <span class="n">right_remainder</span><span class="p">)</span> <span class="o">=</span> <span class="n">_divmod</span><span class="p">(</span><span class="n">pad_width</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">size</span><span class="p">)</span>
    <span class="n">total_repeats</span> <span class="o">=</span> <span class="n">repeats</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">parts</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">left_remainder</span><span class="p">:</span>
      <span class="n">parts</span> <span class="o">+=</span> <span class="p">[</span><span class="n">lax</span><span class="o">.</span><span class="n">slice_in_dim</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">size</span> <span class="o">-</span> <span class="n">left_remainder</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">i</span><span class="p">)]</span>
    <span class="n">parts</span> <span class="o">+=</span> <span class="n">total_repeats</span> <span class="o">*</span> <span class="p">[</span><span class="n">array</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">right_remainder</span><span class="p">:</span>
      <span class="n">parts</span> <span class="o">+=</span> <span class="p">[</span><span class="n">lax</span><span class="o">.</span><span class="n">slice_in_dim</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">right_remainder</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">i</span><span class="p">)]</span>
    <span class="n">array</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">parts</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">array</span>


<span class="k">def</span> <span class="nf">_pad_symmetric_or_reflect</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">reflect_type</span><span class="p">):</span>
  <span class="k">assert</span> <span class="n">mode</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;symmetric&quot;</span><span class="p">,</span> <span class="s2">&quot;reflect&quot;</span><span class="p">)</span>
  <span class="k">assert</span> <span class="n">reflect_type</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;even&quot;</span><span class="p">,</span> <span class="s2">&quot;odd&quot;</span><span class="p">)</span>

  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndim</span><span class="p">(</span><span class="n">array</span><span class="p">)):</span>
    <span class="k">if</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
      <span class="n">_check_no_padding</span><span class="p">(</span><span class="n">pad_width</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">mode</span><span class="p">)</span>
      <span class="k">continue</span>

    <span class="n">n</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="n">offset</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;reflect&quot;</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="k">else</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">build_padding</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">before</span><span class="p">):</span>
      <span class="k">if</span> <span class="n">before</span><span class="p">:</span>
        <span class="n">edge</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">slice_in_dim</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">edge</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">slice_in_dim</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>

      <span class="k">while</span> <span class="n">padding</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">curr_pad</span> <span class="o">=</span> <span class="n">_min</span><span class="p">(</span><span class="n">padding</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="n">offset</span><span class="p">)</span>
        <span class="n">padding</span> <span class="o">-=</span> <span class="n">curr_pad</span>

        <span class="k">if</span> <span class="n">before</span><span class="p">:</span>
          <span class="n">start</span> <span class="o">=</span> <span class="n">offset</span>
          <span class="n">stop</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">curr_pad</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="n">start</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">curr_pad</span> <span class="o">+</span> <span class="n">offset</span><span class="p">)</span>
          <span class="n">stop</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;symmetric&quot;</span> <span class="ow">or</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">slice_in_dim</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">flip</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">reflect_type</span> <span class="o">==</span> <span class="s1">&#39;odd&#39;</span><span class="p">:</span>
          <span class="n">x</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">edge</span> <span class="o">-</span> <span class="n">x</span>
          <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">before</span><span class="p">:</span>
              <span class="n">edge</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">slice_in_dim</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
              <span class="n">edge</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">slice_in_dim</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">before</span><span class="p">:</span>
          <span class="n">array</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">array</span><span class="p">],</span> <span class="n">dimension</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="n">array</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">array</span><span class="p">,</span> <span class="n">x</span><span class="p">],</span> <span class="n">dimension</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">array</span>

    <span class="n">array</span> <span class="o">=</span> <span class="n">build_padding</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">before</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">array</span> <span class="o">=</span> <span class="n">build_padding</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">before</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">array</span>


<span class="k">def</span> <span class="nf">_pad_edge</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">):</span>
  <span class="n">nd</span> <span class="o">=</span> <span class="n">ndim</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nd</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
      <span class="n">_check_no_padding</span><span class="p">(</span><span class="n">pad_width</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="s2">&quot;edge&quot;</span><span class="p">)</span>
      <span class="k">continue</span>

    <span class="n">n</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="n">npad_before</span><span class="p">,</span> <span class="n">npad_after</span> <span class="o">=</span> <span class="n">pad_width</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="n">edge_before</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">slice_in_dim</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
    <span class="n">pad_before</span> <span class="o">=</span> <span class="n">repeat</span><span class="p">(</span><span class="n">edge_before</span><span class="p">,</span> <span class="n">npad_before</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>

    <span class="n">edge_after</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">slice_in_dim</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
    <span class="n">pad_after</span> <span class="o">=</span> <span class="n">repeat</span><span class="p">(</span><span class="n">edge_after</span><span class="p">,</span> <span class="n">npad_after</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>

    <span class="n">array</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">pad_before</span><span class="p">,</span> <span class="n">array</span><span class="p">,</span> <span class="n">pad_after</span><span class="p">],</span> <span class="n">dimension</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">array</span>


<span class="k">def</span> <span class="nf">_pad_linear_ramp</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">,</span> <span class="n">end_values</span><span class="p">):</span>
  <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndim</span><span class="p">(</span><span class="n">array</span><span class="p">)):</span>
    <span class="n">edge_before</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">slice_in_dim</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="n">edge_after</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">slice_in_dim</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="n">ramp_before</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span>
        <span class="n">start</span><span class="o">=</span><span class="n">end_values</span><span class="p">[</span><span class="n">axis</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
        <span class="n">stop</span><span class="o">=</span><span class="n">edge_before</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">axis</span><span class="p">),</span> <span class="c1"># Dimension is replaced by linspace</span>
        <span class="n">num</span><span class="o">=</span><span class="n">pad_width</span><span class="p">[</span><span class="n">axis</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
        <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="n">axis</span>
    <span class="p">)</span>
    <span class="n">ramp_after</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span>
        <span class="n">start</span><span class="o">=</span><span class="n">end_values</span><span class="p">[</span><span class="n">axis</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span>
        <span class="n">stop</span><span class="o">=</span><span class="n">edge_after</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">axis</span><span class="p">),</span> <span class="c1"># Dimension is replaced by linspace</span>
        <span class="n">num</span><span class="o">=</span><span class="n">pad_width</span><span class="p">[</span><span class="n">axis</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span>
        <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="n">axis</span>
    <span class="p">)</span>

    <span class="c1"># Reverse linear space in appropriate dimension</span>
    <span class="n">ramp_after</span> <span class="o">=</span> <span class="n">flip</span><span class="p">(</span><span class="n">ramp_after</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

    <span class="n">array</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">ramp_before</span><span class="p">,</span> <span class="n">array</span><span class="p">,</span> <span class="n">ramp_after</span><span class="p">],</span> <span class="n">dimension</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">array</span>


<span class="k">def</span> <span class="nf">_pad_stats</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">,</span> <span class="n">stat_length</span><span class="p">,</span> <span class="n">stat_func</span><span class="p">):</span>
  <span class="n">nd</span> <span class="o">=</span> <span class="n">ndim</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nd</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">stat_length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
      <span class="n">stat_before</span> <span class="o">=</span> <span class="n">stat_func</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="n">stat_after</span> <span class="o">=</span> <span class="n">stat_before</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">array_length</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
      <span class="n">length_before</span><span class="p">,</span> <span class="n">length_after</span> <span class="o">=</span> <span class="n">stat_length</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
      <span class="k">if</span> <span class="n">length_before</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">length_after</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;stat_length of 0 yields no value for padding&quot;</span><span class="p">)</span>

      <span class="c1"># Limit stat_length to length of array.</span>
      <span class="n">length_before</span> <span class="o">=</span> <span class="n">_min</span><span class="p">(</span><span class="n">length_before</span><span class="p">,</span> <span class="n">array_length</span><span class="p">)</span>
      <span class="n">length_after</span> <span class="o">=</span> <span class="n">_min</span><span class="p">(</span><span class="n">length_after</span><span class="p">,</span> <span class="n">array_length</span><span class="p">)</span>

      <span class="n">slice_before</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">slice_in_dim</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">length_before</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
      <span class="n">slice_after</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">slice_in_dim</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="o">-</span><span class="n">length_after</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
      <span class="n">stat_before</span> <span class="o">=</span> <span class="n">stat_func</span><span class="p">(</span><span class="n">slice_before</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="n">stat_after</span> <span class="o">=</span> <span class="n">stat_func</span><span class="p">(</span><span class="n">slice_after</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
      <span class="n">stat_before</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">stat_before</span><span class="p">)</span>
      <span class="n">stat_after</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">stat_after</span><span class="p">)</span>

    <span class="n">stat_before</span> <span class="o">=</span> <span class="n">stat_before</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">stat_after</span> <span class="o">=</span> <span class="n">stat_after</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="n">npad_before</span><span class="p">,</span> <span class="n">npad_after</span> <span class="o">=</span> <span class="n">pad_width</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="n">pad_before</span> <span class="o">=</span> <span class="n">repeat</span><span class="p">(</span><span class="n">stat_before</span><span class="p">,</span> <span class="n">npad_before</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
    <span class="n">pad_after</span> <span class="o">=</span> <span class="n">repeat</span><span class="p">(</span><span class="n">stat_after</span><span class="p">,</span> <span class="n">npad_after</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>

    <span class="n">array</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">pad_before</span><span class="p">,</span> <span class="n">array</span><span class="p">,</span> <span class="n">pad_after</span><span class="p">],</span> <span class="n">dimension</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">array</span>


<span class="k">def</span> <span class="nf">_pad_empty</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">):</span>
  <span class="c1"># Note: jax.numpy.empty = jax.numpy.zeros</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndim</span><span class="p">(</span><span class="n">array</span><span class="p">)):</span>
    <span class="n">shape_before</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">pad_width</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],)</span> <span class="o">+</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span>
    <span class="n">pad_before</span> <span class="o">=</span> <span class="n">empty</span><span class="p">(</span><span class="n">shape_before</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="n">shape_after</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">pad_width</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">],)</span> <span class="o">+</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span>
    <span class="n">pad_after</span> <span class="o">=</span> <span class="n">empty</span><span class="p">(</span><span class="n">shape_after</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">array</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">pad_before</span><span class="p">,</span> <span class="n">array</span><span class="p">,</span> <span class="n">pad_after</span><span class="p">],</span> <span class="n">dimension</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">array</span>


<span class="k">def</span> <span class="nf">_pad_func</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
  <span class="n">pad_width</span> <span class="o">=</span> <span class="n">_broadcast_to_pairs</span><span class="p">(</span><span class="n">pad_width</span><span class="p">,</span> <span class="n">ndim</span><span class="p">(</span><span class="n">array</span><span class="p">),</span> <span class="s2">&quot;pad_width&quot;</span><span class="p">)</span>
  <span class="n">padded</span> <span class="o">=</span> <span class="n">_pad_constant</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pad_width</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndim</span><span class="p">(</span><span class="n">padded</span><span class="p">)):</span>
    <span class="n">padded</span> <span class="o">=</span> <span class="n">apply_along_axis</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">padded</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">[</span><span class="n">axis</span><span class="p">],</span> <span class="n">axis</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">padded</span>


<span class="k">def</span> <span class="nf">_broadcast_to_pairs</span><span class="p">(</span><span class="n">nvals</span><span class="p">,</span> <span class="n">nd</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
  <span class="n">nvals_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">nvals</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">nvals_shape</span> <span class="o">==</span> <span class="p">(</span><span class="n">nd</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
    <span class="c1"># ((before_1, after_1), ..., (before_N, after_N))</span>
    <span class="k">pass</span>
  <span class="k">elif</span> <span class="n">nvals_shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
    <span class="c1"># ((before, after),)</span>
    <span class="n">nvals</span> <span class="o">=</span> <span class="n">nvals</span> <span class="o">*</span> <span class="n">nd</span>
  <span class="k">elif</span> <span class="n">nvals_shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">2</span><span class="p">,):</span>
    <span class="c1"># (before, after)  (not in the numpy docstring but works anyway)</span>
    <span class="n">before</span><span class="p">,</span> <span class="n">after</span> <span class="o">=</span> <span class="n">nvals</span>
    <span class="n">nvals</span> <span class="o">=</span> <span class="p">(</span><span class="n">nvals</span><span class="p">,)</span> <span class="o">*</span> <span class="n">nd</span>
  <span class="k">elif</span> <span class="n">nvals_shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,):</span>
    <span class="c1"># (pad,)</span>
    <span class="n">nvals</span><span class="p">,</span> <span class="o">=</span> <span class="n">nvals</span>
    <span class="n">nvals</span> <span class="o">=</span> <span class="p">((</span><span class="n">nvals</span><span class="p">,</span> <span class="n">nvals</span><span class="p">),)</span> <span class="o">*</span> <span class="n">nd</span>
  <span class="k">elif</span> <span class="n">nvals_shape</span> <span class="o">==</span> <span class="p">():</span>
    <span class="c1"># pad</span>
    <span class="n">nvals</span> <span class="o">=</span> <span class="p">((</span><span class="n">nvals</span><span class="p">,</span> <span class="n">nvals</span><span class="p">),)</span> <span class="o">*</span> <span class="n">nd</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> given unexpected structure: </span><span class="si">{</span><span class="n">nvals</span><span class="si">}</span><span class="s2">. &quot;</span>
                     <span class="s2">&quot;See docstring for valid </span><span class="si">{name}</span><span class="s2"> formats.&quot;</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">nvals</span>


<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnums</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">_pad</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">constant_values</span><span class="p">,</span> <span class="n">stat_length</span><span class="p">,</span> <span class="n">end_values</span><span class="p">,</span> <span class="n">reflect_type</span><span class="p">):</span>
  <span class="n">array</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
  <span class="n">nd</span> <span class="o">=</span> <span class="n">ndim</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">nd</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">array</span>

  <span class="n">stat_funcs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;maximum&quot;</span><span class="p">:</span> <span class="n">amax</span><span class="p">,</span> <span class="s2">&quot;minimum&quot;</span><span class="p">:</span> <span class="n">amin</span><span class="p">,</span>
                <span class="s2">&quot;mean&quot;</span><span class="p">:</span> <span class="n">mean</span><span class="p">,</span> <span class="s2">&quot;median&quot;</span><span class="p">:</span> <span class="n">median</span><span class="p">}</span>

  <span class="n">pad_width</span> <span class="o">=</span> <span class="n">_broadcast_to_pairs</span><span class="p">(</span><span class="n">pad_width</span><span class="p">,</span> <span class="n">nd</span><span class="p">,</span> <span class="s2">&quot;pad_width&quot;</span><span class="p">)</span>
  <span class="n">pad_width</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pad_width</span><span class="p">)</span>
  <span class="k">assert</span> <span class="n">pad_width</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="n">nd</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">pad_width</span>

  <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">pad_width</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;index can&#39;t contain negative values&quot;</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;constant&quot;</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">_pad_constant</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">,</span> <span class="n">constant_values</span><span class="p">)</span>

  <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;wrap&quot;</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">_pad_wrap</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">)</span>

  <span class="k">elif</span> <span class="n">mode</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;symmetric&quot;</span><span class="p">,</span> <span class="s2">&quot;reflect&quot;</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">_pad_symmetric_or_reflect</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">reflect_type</span><span class="p">)</span>

  <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;edge&quot;</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">_pad_edge</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">)</span>

  <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;linear_ramp&quot;</span><span class="p">:</span>
    <span class="n">end_values</span> <span class="o">=</span> <span class="n">_broadcast_to_pairs</span><span class="p">(</span><span class="n">end_values</span><span class="p">,</span> <span class="n">nd</span><span class="p">,</span> <span class="s2">&quot;end_values&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_pad_linear_ramp</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">,</span> <span class="n">end_values</span><span class="p">)</span>

  <span class="k">elif</span> <span class="n">mode</span> <span class="ow">in</span> <span class="n">stat_funcs</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">stat_length</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
      <span class="n">stat_length</span> <span class="o">=</span> <span class="n">_broadcast_to_pairs</span><span class="p">(</span><span class="n">stat_length</span><span class="p">,</span> <span class="n">nd</span><span class="p">,</span> <span class="s2">&quot;stat_length&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_pad_stats</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">,</span> <span class="n">stat_length</span><span class="p">,</span> <span class="n">stat_funcs</span><span class="p">[</span><span class="n">mode</span><span class="p">])</span>

  <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;empty&quot;</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">_pad_empty</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">)</span>

  <span class="k">else</span><span class="p">:</span>
    <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;Should not be reached since pad already handled unsupported and&quot;</span>
                   <span class="s2">&quot;not implemented modes&quot;</span><span class="p">)</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">Unlike numpy, JAX &quot;function&quot; mode&#39;s argument (which is another function) should return</span>
<span class="s2">the modified array. This is because Jax arrays are immutable.</span>
<span class="s2">(In numpy, &quot;function&quot; mode&#39;s argument should modify a rank 1 array in-place.)</span>
<span class="s2">&quot;&quot;&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">pad</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;constant&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pad_width</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
    <span class="n">pad_width</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
        <span class="nb">tuple</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">x</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">)</span> <span class="k">else</span> <span class="n">x</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">pad_width</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">mode</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">_pad_func</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

  <span class="n">allowed_kwargs</span> <span class="o">=</span> <span class="p">{</span>
      <span class="s1">&#39;empty&#39;</span><span class="p">:</span> <span class="p">[],</span> <span class="s1">&#39;edge&#39;</span><span class="p">:</span> <span class="p">[],</span> <span class="s1">&#39;wrap&#39;</span><span class="p">:</span> <span class="p">[],</span>
      <span class="s1">&#39;constant&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;constant_values&#39;</span><span class="p">],</span>
      <span class="s1">&#39;linear_ramp&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;end_values&#39;</span><span class="p">],</span>
      <span class="s1">&#39;maximum&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;stat_length&#39;</span><span class="p">],</span>
      <span class="s1">&#39;mean&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;stat_length&#39;</span><span class="p">],</span>
      <span class="s1">&#39;median&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;stat_length&#39;</span><span class="p">],</span>
      <span class="s1">&#39;minimum&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;stat_length&#39;</span><span class="p">],</span>
      <span class="s1">&#39;reflect&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;reflect_type&#39;</span><span class="p">],</span>
      <span class="s1">&#39;symmetric&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;reflect_type&#39;</span><span class="p">],</span>
  <span class="p">}</span>
  <span class="k">try</span><span class="p">:</span>
    <span class="n">unsupported_kwargs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">allowed_kwargs</span><span class="p">[</span><span class="n">mode</span><span class="p">])</span>
  <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Unimplemented padding mode &#39;</span><span class="si">{}</span><span class="s2">&#39; for np.pad.&quot;</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span>
  <span class="k">if</span> <span class="n">unsupported_kwargs</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;unsupported keyword arguments for mode &#39;</span><span class="si">{}</span><span class="s2">&#39;: </span><span class="si">{}</span><span class="s2">&quot;</span>
                     <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">unsupported_kwargs</span><span class="p">))</span>
  <span class="c1"># Set default value if not given.</span>
  <span class="n">constant_values</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;constant_values&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
  <span class="n">stat_length</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;stat_length&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
  <span class="n">end_values</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;end_values&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
  <span class="n">reflect_type</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;reflect_type&#39;</span><span class="p">,</span> <span class="s2">&quot;even&quot;</span><span class="p">)</span>

  <span class="k">return</span> <span class="n">_pad</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">constant_values</span><span class="p">,</span> <span class="n">stat_length</span><span class="p">,</span> <span class="n">end_values</span><span class="p">,</span> <span class="n">reflect_type</span><span class="p">)</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">stack</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">arrays</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Need at least one array to stack.&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;The &#39;out&#39; argument to jnp.stack is not supported.&quot;</span><span class="p">)</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;stack&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">arrays</span><span class="p">)</span>
  <span class="n">shape0</span> <span class="o">=</span> <span class="n">shape</span><span class="p">(</span><span class="n">arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
  <span class="n">axis</span> <span class="o">=</span> <span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
  <span class="n">new_arrays</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">arrays</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">shape</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">!=</span> <span class="n">shape0</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;All input arrays must have the same shape.&quot;</span><span class="p">)</span>
    <span class="n">new_arrays</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">concatenate</span><span class="p">(</span><span class="n">new_arrays</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">tile</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">reps</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;tile&quot;</span><span class="p">,</span> <span class="n">A</span><span class="p">)</span>
  <span class="k">try</span><span class="p">:</span>
    <span class="nb">iter</span><span class="p">(</span><span class="n">reps</span><span class="p">)</span>
  <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
    <span class="n">reps</span> <span class="o">=</span> <span class="p">(</span><span class="n">reps</span><span class="p">,)</span>
  <span class="n">reps</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">rep</span><span class="p">)</span> <span class="k">for</span> <span class="n">rep</span> <span class="ow">in</span> <span class="n">reps</span><span class="p">)</span>
  <span class="n">A_shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">reps</span><span class="p">)</span> <span class="o">-</span> <span class="n">ndim</span><span class="p">(</span><span class="n">A</span><span class="p">))</span> <span class="o">+</span> <span class="n">shape</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
  <span class="n">reps</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">A_shape</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">reps</span><span class="p">))</span> <span class="o">+</span> <span class="n">reps</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">broadcast_to</span><span class="p">(</span><span class="n">reshape</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="p">[</span><span class="n">j</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">A_shape</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]]),</span>
                        <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">reps</span><span class="p">,</span> <span class="n">A_shape</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">pair</span><span class="p">])</span>
  <span class="k">return</span> <span class="n">reshape</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">A_shape</span><span class="p">,</span> <span class="n">reps</span><span class="p">)))</span>

<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">concatenate</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;concatenate&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">arrays</span><span class="p">)</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">arrays</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Need at least one array to concatenate.&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">ndim</span><span class="p">(</span><span class="n">arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Zero-dimensional arrays cannot be concatenated.&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">concatenate</span><span class="p">([</span><span class="n">ravel</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">arrays</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
  <span class="n">axis</span> <span class="o">=</span> <span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">ndim</span><span class="p">(</span><span class="n">arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
  <span class="n">arrays</span> <span class="o">=</span> <span class="n">_promote_dtypes</span><span class="p">(</span><span class="o">*</span><span class="n">arrays</span><span class="p">)</span>
  <span class="c1"># lax.concatenate can be slow to compile for wide concatenations, so form a</span>
  <span class="c1"># tree of concatenations as a workaround especially for op-by-op mode.</span>
  <span class="c1"># (https://github.com/google/jax/issues/653).</span>
  <span class="n">k</span> <span class="o">=</span> <span class="mi">16</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arrays</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">asarray</span><span class="p">(</span><span class="n">arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">arrays</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
      <span class="n">arrays</span> <span class="o">=</span> <span class="p">[</span><span class="n">lax</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">arrays</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="n">k</span><span class="p">],</span> <span class="n">axis</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">arrays</span><span class="p">),</span> <span class="n">k</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">vstack</span><span class="p">(</span><span class="n">tup</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">concatenate</span><span class="p">([</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">tup</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">row_stack</span> <span class="o">=</span> <span class="n">vstack</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">hstack</span><span class="p">(</span><span class="n">tup</span><span class="p">):</span>
  <span class="n">arrs</span> <span class="o">=</span> <span class="p">[</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">tup</span><span class="p">]</span>
  <span class="k">if</span> <span class="n">arrs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">concatenate</span><span class="p">(</span><span class="n">arrs</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">concatenate</span><span class="p">(</span><span class="n">arrs</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">dstack</span><span class="p">(</span><span class="n">tup</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">concatenate</span><span class="p">([</span><span class="n">atleast_3d</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">tup</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">column_stack</span><span class="p">(</span><span class="n">tup</span><span class="p">):</span>
  <span class="n">arrays</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">tup</span><span class="p">:</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">arr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
      <span class="n">arr</span> <span class="o">=</span> <span class="n">atleast_2d</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
    <span class="n">arrays</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">concatenate</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">choose</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">choose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">choices</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;raise&#39;</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;The &#39;out&#39; argument to jnp.choose is not supported.&quot;</span><span class="p">)</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s1">&#39;choose&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="o">*</span><span class="n">choices</span><span class="p">)</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">_dtype</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">integer</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`a` array must be integer typed&quot;</span><span class="p">)</span>
  <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">choices</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;raise&#39;</span><span class="p">:</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="n">asarray</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span>
      <span class="s2">&quot;The error occurred because jnp.choose was jit-compiled&quot;</span>
      <span class="s2">&quot; with mode=&#39;raise&#39;. Use mode=&#39;wrap&#39; or mode=&#39;clip&#39; instead.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">((</span><span class="n">a</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;=</span> <span class="n">N</span><span class="p">)):</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid entry in choice array&quot;</span><span class="p">)</span>
  <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;wrap&#39;</span><span class="p">:</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">a</span> <span class="o">%</span> <span class="n">N</span>
  <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;clip&#39;</span><span class="p">:</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">clip</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;mode=</span><span class="si">{</span><span class="n">mode</span><span class="si">!r}</span><span class="s2"> not understood. Must be &#39;raise&#39;, &#39;wrap&#39;, or &#39;clip&#39;&quot;</span><span class="p">)</span>

  <span class="n">a</span><span class="p">,</span> <span class="o">*</span><span class="n">choices</span> <span class="o">=</span> <span class="n">broadcast_arrays</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">*</span><span class="n">choices</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">array</span><span class="p">(</span><span class="n">choices</span><span class="p">)[(</span><span class="n">a</span><span class="p">,)</span> <span class="o">+</span> <span class="n">indices</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)]</span>


<span class="k">def</span> <span class="nf">_atleast_nd</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
  <span class="n">m</span> <span class="o">=</span> <span class="n">ndim</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">broadcast</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">m</span><span class="p">))</span> <span class="k">if</span> <span class="n">m</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="k">else</span> <span class="n">x</span>

<span class="k">def</span> <span class="nf">_block</span><span class="p">(</span><span class="n">xs</span><span class="p">):</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;jax.numpy.block does not allow tuples, got </span><span class="si">{}</span><span class="s2">&quot;</span>
                     <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">xs</span><span class="p">))</span>
  <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;jax.numpy.block does not allow empty list arguments&quot;</span><span class="p">)</span>
    <span class="n">xs</span><span class="p">,</span> <span class="n">depths</span> <span class="o">=</span> <span class="n">unzip2</span><span class="p">([</span><span class="n">_block</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xs</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">_any</span><span class="p">(</span><span class="n">d</span> <span class="o">!=</span> <span class="n">depths</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">depths</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Mismatched list depths in jax.numpy.block&quot;</span><span class="p">)</span>
    <span class="n">rank</span> <span class="o">=</span> <span class="n">_max</span><span class="p">(</span><span class="n">depths</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">_max</span><span class="p">(</span><span class="n">ndim</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xs</span><span class="p">))</span>
    <span class="n">xs</span> <span class="o">=</span> <span class="p">[</span><span class="n">_atleast_nd</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">rank</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xs</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">concatenate</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="n">depths</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">depths</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">asarray</span><span class="p">(</span><span class="n">xs</span><span class="p">),</span> <span class="mi">1</span>

<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">block</span><span class="p">)</span>
<span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">block</span><span class="p">(</span><span class="n">arrays</span><span class="p">):</span>
  <span class="n">out</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_block</span><span class="p">(</span><span class="n">arrays</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">out</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">,</span> <span class="n">update_doc</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">atleast_1d</span><span class="p">(</span><span class="o">*</span><span class="n">arys</span><span class="p">):</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arys</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">arys</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">arr</span> <span class="k">if</span> <span class="n">ndim</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">reshape</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="n">arys</span><span class="p">]</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">,</span> <span class="n">update_doc</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">atleast_2d</span><span class="p">(</span><span class="o">*</span><span class="n">arys</span><span class="p">):</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arys</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">arys</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">ndim</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">arr</span>
    <span class="k">elif</span> <span class="n">ndim</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">expand_dims</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">expand_dims</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="n">arys</span><span class="p">]</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_3d</span><span class="p">,</span> <span class="n">update_doc</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">atleast_3d</span><span class="p">(</span><span class="o">*</span><span class="n">arys</span><span class="p">):</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arys</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">arys</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">ndim</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
      <span class="n">arr</span> <span class="o">=</span> <span class="n">expand_dims</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">ndim</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
      <span class="n">arr</span> <span class="o">=</span> <span class="n">expand_dims</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">ndim</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
      <span class="n">arr</span> <span class="o">=</span> <span class="n">expand_dims</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">arr</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">atleast_3d</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="n">arys</span><span class="p">]</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">array</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;K&quot;</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">order</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">order</span> <span class="o">!=</span> <span class="s2">&quot;K&quot;</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Only implemented for order=&#39;K&#39;&quot;</span><span class="p">)</span>
  <span class="n">lax</span><span class="o">.</span><span class="n">_check_user_dtype_supported</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="s2">&quot;array&quot;</span><span class="p">)</span>
  <span class="n">dtype</span> <span class="o">=</span> <span class="n">dtype</span> <span class="ow">and</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">canonicalize_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">_can_call_numpy_array</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="nb">object</span> <span class="o">=</span> <span class="n">_np_array</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="n">ndmin</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
  <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">python_scalar_dtypes</span>

  <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">_device_put_raw</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">dtype</span><span class="p">:</span> <span class="k">assert</span> <span class="n">_dtype</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="o">==</span> <span class="n">dtype</span>
  <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="p">(</span><span class="n">DeviceArray</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Tracer</span><span class="p">)):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">DeviceArray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">copy</span><span class="p">:</span>
      <span class="c1"># We perform a copy by bouncing back to the host</span>
      <span class="c1"># TODO(phawkins): add a device runtime function to copy a buffer</span>
      <span class="n">out</span> <span class="o">=</span> <span class="n">_device_put_raw</span><span class="p">(</span><span class="n">_np_asarray</span><span class="p">(</span><span class="nb">object</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">out</span> <span class="o">=</span> <span class="nb">object</span>
  <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
    <span class="k">if</span> <span class="nb">object</span><span class="p">:</span>
      <span class="n">out</span> <span class="o">=</span> <span class="n">stack</span><span class="p">([</span><span class="n">asarray</span><span class="p">(</span><span class="n">elt</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span> <span class="k">for</span> <span class="n">elt</span> <span class="ow">in</span> <span class="nb">object</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">out</span> <span class="o">=</span> <span class="n">_device_put_raw</span><span class="p">(</span><span class="n">_np_array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">))</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
      <span class="n">view</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
      <span class="k">pass</span>  <span class="c1"># `object` does not support the buffer interface.</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">array</span><span class="p">(</span><span class="n">_np_asarray</span><span class="p">(</span><span class="n">view</span><span class="p">),</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="p">)</span>

    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Unexpected input type for array: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="nb">object</span><span class="p">)))</span>

  <span class="k">if</span> <span class="n">dtype</span> <span class="ow">and</span> <span class="n">_dtype</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="o">!=</span> <span class="n">dtype</span><span class="p">:</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">convert_element_type</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">ndmin</span> <span class="o">&gt;</span> <span class="n">ndim</span><span class="p">(</span><span class="n">out</span><span class="p">):</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">broadcast</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">*</span> <span class="p">(</span><span class="n">ndmin</span> <span class="o">-</span> <span class="n">ndim</span><span class="p">(</span><span class="n">out</span><span class="p">)))</span>
  <span class="k">return</span> <span class="n">out</span>

<span class="k">def</span> <span class="nf">_can_call_numpy_array</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">_all</span><span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">Tracer</span><span class="p">,</span> <span class="n">DeviceArray</span><span class="p">))</span>
              <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">tree_leaves</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="n">lax</span><span class="o">.</span><span class="n">_check_user_dtype_supported</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="s2">&quot;asarray&quot;</span><span class="p">)</span>
  <span class="n">dtype</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">canonicalize_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span> <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">dtype</span>
  <span class="k">return</span> <span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">zeros_like</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;zeros_like&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="n">lax</span><span class="o">.</span><span class="n">_check_user_dtype_supported</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="s2">&quot;zeros_like&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">shape</span><span class="p">):</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">shape</span><span class="p">,)</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">ones_like</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;ones_like&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="n">lax</span><span class="o">.</span><span class="n">_check_user_dtype_supported</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="s2">&quot;ones_like&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">shape</span><span class="p">):</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">shape</span><span class="p">,)</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">full</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="n">lax</span><span class="o">.</span><span class="n">_check_user_dtype_supported</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="s2">&quot;full&quot;</span><span class="p">)</span>
  <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">shape</span><span class="p">,)</span> <span class="k">if</span> <span class="n">ndim</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">shape</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">full_like</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;full_like&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="n">lax</span><span class="o">.</span><span class="n">_check_user_dtype_supported</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="s2">&quot;full_like&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">shape</span><span class="p">):</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">shape</span><span class="p">,)</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">GeneratorType</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;expected sequence object with len &gt;= 0 or a single integer&quot;</span><span class="p">)</span>
  <span class="n">lax</span><span class="o">.</span><span class="n">_check_user_dtype_supported</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="s2">&quot;zeros&quot;</span><span class="p">)</span>
  <span class="n">dtype</span> <span class="o">=</span> <span class="n">float_</span> <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">dtype</span>
  <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">shape</span><span class="p">,)</span> <span class="k">if</span> <span class="n">ndim</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">shape</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>

<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">ones</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">GeneratorType</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;expected sequence object with len &gt;= 0 or a single integer&quot;</span><span class="p">)</span>
  <span class="n">lax</span><span class="o">.</span><span class="n">_check_user_dtype_supported</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="s2">&quot;ones&quot;</span><span class="p">)</span>
  <span class="n">dtype</span> <span class="o">=</span> <span class="n">float_</span> <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">dtype</span>
  <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">shape</span><span class="p">,)</span> <span class="k">if</span> <span class="n">ndim</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">shape</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">array_equal</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">equal_nan</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
  <span class="k">try</span><span class="p">:</span>
    <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a1</span><span class="p">),</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a2</span><span class="p">)</span>
  <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
    <span class="k">return</span> <span class="kc">False</span>
  <span class="k">if</span> <span class="n">shape</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span> <span class="o">!=</span> <span class="n">shape</span><span class="p">(</span><span class="n">a2</span><span class="p">):</span>
    <span class="k">return</span> <span class="kc">False</span>
  <span class="n">eq</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a1</span> <span class="o">==</span> <span class="n">a2</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">equal_nan</span><span class="p">:</span>
    <span class="n">eq</span> <span class="o">=</span> <span class="n">logical_or</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">logical_and</span><span class="p">(</span><span class="n">isnan</span><span class="p">(</span><span class="n">a1</span><span class="p">),</span> <span class="n">isnan</span><span class="p">(</span><span class="n">a2</span><span class="p">)))</span>
  <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array_equiv</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">array_equiv</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">):</span>
  <span class="k">try</span><span class="p">:</span>
    <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a1</span><span class="p">),</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a2</span><span class="p">)</span>
  <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
    <span class="k">return</span> <span class="kc">False</span>
  <span class="k">try</span><span class="p">:</span>
    <span class="n">eq</span> <span class="o">=</span> <span class="n">equal</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">)</span>
  <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
    <span class="c1"># shapes are not broadcastable</span>
    <span class="k">return</span> <span class="kc">False</span>
  <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>


<span class="c1"># We can&#39;t create uninitialized arrays in XLA; use zeros for empty.</span>
<span class="n">empty_like</span> <span class="o">=</span> <span class="n">zeros_like</span>
<span class="n">empty</span> <span class="o">=</span> <span class="n">zeros</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">eye</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">M</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="n">lax</span><span class="o">.</span><span class="n">_check_user_dtype_supported</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="s2">&quot;eye&quot;</span><span class="p">)</span>
  <span class="n">dtype</span> <span class="o">=</span> <span class="n">float_</span> <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">dtype</span>
  <span class="n">N</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
  <span class="n">M</span> <span class="o">=</span> <span class="n">N</span> <span class="k">if</span> <span class="n">M</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">N</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">M</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;negative dimensions are not allowed, got </span><span class="si">{</span><span class="n">N</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">M</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
  <span class="n">k</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">_eye</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">M</span><span class="p">),</span> <span class="n">k</span><span class="p">)</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">identity</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="n">lax</span><span class="o">.</span><span class="n">_check_user_dtype_supported</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="s2">&quot;identity&quot;</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">eye</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">arange</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="n">lax</span><span class="o">.</span><span class="n">_check_user_dtype_supported</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="s2">&quot;arange&quot;</span><span class="p">)</span>
  <span class="n">require</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">,</span> <span class="n">_np_asarray</span><span class="p">)</span>
  <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;It arose in jax.numpy.arange argument `</span><span class="si">{}</span><span class="s2">`.&quot;</span><span class="o">.</span><span class="n">format</span>
  <span class="k">if</span> <span class="n">stop</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">step</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">require</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">msg</span><span class="p">(</span><span class="s2">&quot;stop&quot;</span><span class="p">))</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">dtype</span> <span class="ow">or</span> <span class="n">_dtype</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">iota</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">start</span><span class="p">))</span> <span class="c1"># avoids materializing</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">require</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">msg</span><span class="p">(</span><span class="s2">&quot;start&quot;</span><span class="p">))</span>
    <span class="n">stop</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">stop</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">require</span><span class="p">(</span><span class="n">stop</span><span class="p">,</span> <span class="n">msg</span><span class="p">(</span><span class="s2">&quot;stop&quot;</span><span class="p">))</span>
    <span class="n">step</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">step</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">require</span><span class="p">(</span><span class="n">step</span><span class="p">,</span> <span class="n">msg</span><span class="p">(</span><span class="s2">&quot;step&quot;</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
      <span class="n">dtype</span> <span class="o">=</span> <span class="n">_dtype</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">]</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="n">step</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_wrap_numpy_nullary_function</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Adapts `f` to return a DeviceArray instead of an np.ndarray.</span>

<span class="sd">  `f` cannot have any non-static array arguments.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="nd">@_wraps</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">update_doc</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
  <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">asarray</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">wrapper</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">linspace</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">retstep</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Implementation of linspace differentiable in start and stop args.&quot;&quot;&quot;</span>
  <span class="n">lax</span><span class="o">.</span><span class="n">_check_user_dtype_supported</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="s2">&quot;linspace&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">num</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Number of samples, </span><span class="si">%s</span><span class="s2">, must be non-negative.&quot;</span> <span class="o">%</span> <span class="n">num</span><span class="p">)</span>

  <span class="n">dtype</span> <span class="o">=</span> <span class="n">dtype</span> <span class="ow">or</span> <span class="n">result_type</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">canonicalize_dtype</span><span class="p">(</span><span class="n">float_</span><span class="p">))</span>
  <span class="n">computation_dtype</span> <span class="o">=</span> <span class="n">promote_types</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">canonicalize_dtype</span><span class="p">(</span><span class="n">float_</span><span class="p">))</span>
  <span class="n">start</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">computation_dtype</span><span class="p">)</span>
  <span class="n">stop</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">stop</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">computation_dtype</span><span class="p">)</span>

  <span class="n">bounds_shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">broadcast_shapes</span><span class="p">(</span><span class="n">shape</span><span class="p">(</span><span class="n">start</span><span class="p">),</span> <span class="n">shape</span><span class="p">(</span><span class="n">stop</span><span class="p">)))</span>
  <span class="n">broadcast_start</span> <span class="o">=</span> <span class="n">broadcast_to</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">bounds_shape</span><span class="p">)</span>
  <span class="n">broadcast_stop</span> <span class="o">=</span> <span class="n">broadcast_to</span><span class="p">(</span><span class="n">stop</span><span class="p">,</span> <span class="n">bounds_shape</span><span class="p">)</span>
  <span class="n">axis</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bounds_shape</span><span class="p">)</span> <span class="o">+</span> <span class="n">axis</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">axis</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">axis</span>
  <span class="n">bounds_shape</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
  <span class="n">iota_shape</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">bounds_shape</span><span class="p">)</span>
  <span class="n">iota_shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">num</span>
  <span class="n">div</span> <span class="o">=</span> <span class="p">(</span><span class="n">num</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="n">endpoint</span> <span class="k">else</span> <span class="n">num</span>
  <span class="k">if</span> <span class="n">num</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">delta</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">convert_element_type</span><span class="p">(</span><span class="n">stop</span> <span class="o">-</span> <span class="n">start</span><span class="p">,</span> <span class="n">computation_dtype</span><span class="p">)</span> <span class="o">/</span> <span class="n">div</span>
    <span class="k">if</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">integer</span><span class="p">):</span>
      <span class="c1"># This is similar to how numpy computes linspace, but it</span>
      <span class="c1"># can fail to recover the endpoints in float32 arithmetic.</span>
      <span class="n">out</span> <span class="o">=</span> <span class="p">(</span><span class="n">reshape</span><span class="p">(</span><span class="n">broadcast_start</span><span class="p">,</span> <span class="n">bounds_shape</span><span class="p">)</span> <span class="o">+</span>
        <span class="n">reshape</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">iota</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">num</span><span class="p">),</span> <span class="n">iota_shape</span><span class="p">)</span> <span class="o">*</span>
        <span class="n">reshape</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="n">bounds_shape</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="c1"># This approach recovers the endpoints with float32 arithmetic,</span>
      <span class="c1"># but can lead to rounding errors for integer outputs.</span>
      <span class="n">step</span> <span class="o">=</span> <span class="n">reshape</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">iota</span><span class="p">(</span><span class="n">computation_dtype</span><span class="p">,</span> <span class="n">num</span><span class="p">),</span> <span class="n">iota_shape</span><span class="p">)</span> <span class="o">/</span> <span class="n">div</span>
      <span class="n">out</span> <span class="o">=</span> <span class="p">(</span><span class="n">reshape</span><span class="p">(</span><span class="n">broadcast_start</span><span class="p">,</span> <span class="n">bounds_shape</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">step</span><span class="p">)</span> <span class="o">+</span>
        <span class="n">reshape</span><span class="p">(</span><span class="n">broadcast_stop</span><span class="p">,</span> <span class="n">bounds_shape</span><span class="p">)</span> <span class="o">*</span> <span class="n">step</span><span class="p">)</span>
  <span class="k">elif</span> <span class="n">num</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">delta</span> <span class="o">=</span> <span class="n">nan</span> <span class="k">if</span> <span class="n">endpoint</span> <span class="k">else</span> <span class="n">stop</span> <span class="o">-</span> <span class="n">start</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">reshape</span><span class="p">(</span><span class="n">broadcast_start</span><span class="p">,</span> <span class="n">bounds_shape</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span> <span class="c1"># num == 0 degenerate case, match numpy behavior</span>
    <span class="n">empty_shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">broadcast_shapes</span><span class="p">(</span><span class="n">shape</span><span class="p">(</span><span class="n">start</span><span class="p">),</span> <span class="n">shape</span><span class="p">(</span><span class="n">stop</span><span class="p">)))</span>
    <span class="n">empty_shape</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">delta</span> <span class="o">=</span> <span class="n">nan</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">reshape</span><span class="p">(</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">),</span> <span class="n">empty_shape</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">retstep</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">convert_element_type</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">dtype</span><span class="p">),</span> <span class="n">delta</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">convert_element_type</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">logspace</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="mf">10.0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Implementation of logspace differentiable in start and stop args.&quot;&quot;&quot;</span>
  <span class="n">lax</span><span class="o">.</span><span class="n">_check_user_dtype_supported</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="s2">&quot;logspace&quot;</span><span class="p">)</span>
  <span class="n">dtype</span> <span class="o">=</span> <span class="n">dtype</span> <span class="ow">or</span> <span class="n">result_type</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">canonicalize_dtype</span><span class="p">(</span><span class="n">float_</span><span class="p">))</span>
  <span class="n">computation_dtype</span> <span class="o">=</span> <span class="n">promote_types</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">canonicalize_dtype</span><span class="p">(</span><span class="n">float_</span><span class="p">))</span>
  <span class="n">start</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">computation_dtype</span><span class="p">)</span>
  <span class="n">stop</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">stop</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">computation_dtype</span><span class="p">)</span>
  <span class="n">lin</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span>
                 <span class="n">endpoint</span><span class="o">=</span><span class="n">endpoint</span><span class="p">,</span> <span class="n">retstep</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">convert_element_type</span><span class="p">(</span><span class="n">power</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">lin</span><span class="p">),</span> <span class="n">dtype</span><span class="p">)</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">geomspace</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">geomspace</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Implementation of geomspace differentiable in start and stop args.&quot;&quot;&quot;</span>
  <span class="n">lax</span><span class="o">.</span><span class="n">_check_user_dtype_supported</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="s2">&quot;geomspace&quot;</span><span class="p">)</span>
  <span class="n">dtype</span> <span class="o">=</span> <span class="n">dtype</span> <span class="ow">or</span> <span class="n">result_type</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">canonicalize_dtype</span><span class="p">(</span><span class="n">float_</span><span class="p">))</span>
  <span class="n">computation_dtype</span> <span class="o">=</span> <span class="n">promote_types</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">canonicalize_dtype</span><span class="p">(</span><span class="n">float_</span><span class="p">))</span>
  <span class="n">start</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">computation_dtype</span><span class="p">)</span>
  <span class="n">stop</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">stop</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">computation_dtype</span><span class="p">)</span>
  <span class="c1"># follow the numpy geomspace convention for negative and complex endpoints</span>
  <span class="n">signflip</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">sign</span><span class="p">(</span><span class="n">real</span><span class="p">(</span><span class="n">start</span><span class="p">)))</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">sign</span><span class="p">(</span><span class="n">real</span><span class="p">(</span><span class="n">stop</span><span class="p">)))</span> <span class="o">//</span> <span class="mi">2</span>
  <span class="n">res</span> <span class="o">=</span> <span class="n">signflip</span> <span class="o">*</span> <span class="n">logspace</span><span class="p">(</span><span class="n">log10</span><span class="p">(</span><span class="n">signflip</span> <span class="o">*</span> <span class="n">start</span><span class="p">),</span>
                            <span class="n">log10</span><span class="p">(</span><span class="n">signflip</span> <span class="o">*</span> <span class="n">stop</span><span class="p">),</span> <span class="n">num</span><span class="p">,</span>
                            <span class="n">endpoint</span><span class="o">=</span><span class="n">endpoint</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="mf">10.0</span><span class="p">,</span>
                            <span class="n">dtype</span><span class="o">=</span><span class="n">computation_dtype</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">axis</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">moveaxis</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">convert_element_type</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
  <span class="n">indexing</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;indexing&quot;</span><span class="p">,</span> <span class="s2">&quot;xy&quot;</span><span class="p">)</span>
  <span class="n">sparse</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;sparse&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
  <span class="n">copy</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;copy&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">copy</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;jax.numpy.meshgrid only supports copy=True&quot;</span><span class="p">)</span>

  <span class="n">args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">indexing</span> <span class="o">==</span> <span class="s2">&quot;xy&quot;</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
      <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="k">elif</span> <span class="n">indexing</span> <span class="o">!=</span> <span class="s2">&quot;ij&quot;</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Valid values for indexing are &#39;xy&#39; and &#39;ij&#39;, got </span><span class="si">{}</span><span class="s2">&quot;</span>
                     <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">indexing</span><span class="p">))</span>

  <span class="n">shape</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
    <span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
      <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Arguments to jax.numpy.meshgrid must be 1D, got shape </span><span class="si">{}</span><span class="s2">&quot;</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
    <span class="n">shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="n">sparse</span> <span class="k">else</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

  <span class="n">output</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">shape</span>
    <span class="k">if</span> <span class="n">sparse</span><span class="p">:</span>
      <span class="n">s</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
      <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">broadcast_in_dim</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="p">,)))</span>

  <span class="k">if</span> <span class="n">indexing</span> <span class="o">==</span> <span class="s2">&quot;xy&quot;</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
    <span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">output</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

  <span class="k">return</span> <span class="n">output</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">i0</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">i0</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="n">x</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="o">*</span><span class="n">_promote_args_inexact</span><span class="p">(</span><span class="s2">&quot;i0&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">lax</span><span class="o">.</span><span class="n">bessel_i0e</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">ix_</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
  <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
  <span class="n">output</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
      <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Arguments to jax.numpy.ix_ must be 1-dimensional, got shape </span><span class="si">{}</span><span class="s2">&quot;</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">_dtype</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="n">bool_</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
        <span class="s2">&quot;Boolean arguments to jax.numpy.ix_ are not implemented&quot;</span><span class="p">)</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>
    <span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
      <span class="c1"># Numpy uses an integer index type for empty arrays.</span>
      <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((),</span> <span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)))</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">broadcast_in_dim</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="p">,)))</span>
  <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">indices</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">indices</span><span class="p">(</span><span class="n">dimensions</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">int32</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
  <span class="n">dimensions</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
      <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="s2">&quot;dimensions argument of jnp.indices&quot;</span><span class="p">)</span>
      <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dimensions</span><span class="p">)</span>
  <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dimensions</span><span class="p">)</span>
  <span class="n">output</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="n">s</span> <span class="o">=</span> <span class="n">dimensions</span>
  <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dimensions</span><span class="p">):</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">iota</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">sparse</span><span class="p">:</span>
      <span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span><span class="o">*</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">dim</span><span class="p">,)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span><span class="o">*</span><span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">broadcast_in_dim</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="p">,)))</span>
  <span class="k">if</span> <span class="n">sparse</span><span class="p">:</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">stack</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">if</span> <span class="n">output</span> <span class="k">else</span> <span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>


<span class="n">_TOTAL_REPEAT_LENGTH_DOC</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">Jax adds the optional `total_repeat_length` parameter which specifies the total</span>
<span class="s2">number of repeat, and defaults to sum(repeats). It must be specified for repeat</span>
<span class="s2">to be compilable. If `sum(repeats)` is larger than the specified</span>
<span class="s2">`total_repeat_length` the remaining values will be discarded. In the case of</span>
<span class="s2">`sum(repeats)` being smaller than the specified target length, the final value</span>
<span class="s2">will be repeated.</span>
<span class="s2">&quot;&quot;&quot;</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_TOTAL_REPEAT_LENGTH_DOC</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">repeat</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">repeats</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">total_repeat_length</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;repeat&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">ravel</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span>

  <span class="c1"># If total_repeat_length is not given, can&#39;t compile, use a default.</span>
  <span class="k">if</span> <span class="n">total_repeat_length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">repeats</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">repeats</span><span class="p">,</span>
      <span class="s2">&quot;When jit-compiling jnp.repeat, the total number of repeats must be static. &quot;</span>
      <span class="s2">&quot;To fix this, either specify a static value for `repeats`, or pass a static &quot;</span>
      <span class="s2">&quot;value to `total_repeat_length`.&quot;</span><span class="p">)</span>

    <span class="c1"># Fast path for when repeats is a scalar.</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">repeats</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
      <span class="n">input_shape</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span>
      <span class="n">aux_axis</span> <span class="o">=</span> <span class="n">axis</span> <span class="k">if</span> <span class="n">axis</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">axis</span> <span class="o">+</span> <span class="mi">1</span>
      <span class="n">a</span> <span class="o">=</span> <span class="n">expand_dims</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">aux_axis</span><span class="p">)</span>
      <span class="n">reps</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
      <span class="n">reps</span><span class="p">[</span><span class="n">aux_axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">repeats</span>
      <span class="n">a</span> <span class="o">=</span> <span class="n">tile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">reps</span><span class="p">)</span>
      <span class="n">result_shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">input_shape</span><span class="p">)</span>
      <span class="n">result_shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">*=</span> <span class="n">repeats</span>
      <span class="k">return</span> <span class="n">reshape</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">result_shape</span><span class="p">)</span>

    <span class="n">repeats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">repeats</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
      <span class="n">repeats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">repeats</span><span class="p">,</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]])</span>
    <span class="n">total_repeat_length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">repeats</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">repeats</span> <span class="o">=</span> <span class="n">ravel</span><span class="p">(</span><span class="n">repeats</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
      <span class="n">repeats</span> <span class="o">=</span> <span class="n">broadcast_to</span><span class="p">(</span><span class="n">repeats</span><span class="p">,</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]])</span>

  <span class="c1"># Special case when a is a scalar.</span>
  <span class="k">if</span> <span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">repeats</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,):</span>
      <span class="k">return</span> <span class="n">full</span><span class="p">([</span><span class="n">total_repeat_length</span><span class="p">],</span> <span class="n">a</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`repeat` with a scalar parameter `a` is only &#39;</span>
      <span class="s1">&#39;implemented for scalar values of the parameter `repeats`.&#39;</span><span class="p">)</span>

  <span class="c1"># Special case if total_repeat_length is zero.</span>
  <span class="k">if</span> <span class="n">total_repeat_length</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">result_shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">result_shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">reshape</span><span class="p">(</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span> <span class="n">result_shape</span><span class="p">)</span>

  <span class="c1"># If repeats is on a zero sized axis, then return the array.</span>
  <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">a</span>

  <span class="c1"># This implementation of repeat avoid having to instantiate a large.</span>
  <span class="c1"># intermediate tensor.</span>

  <span class="c1"># Modify repeats from e.g. [1,2,0,5] -&gt; [0,1,2,0] for exclusive repeat.</span>
  <span class="n">exclusive_repeats</span> <span class="o">=</span> <span class="n">roll</span><span class="p">(</span><span class="n">repeats</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
  <span class="c1"># Cumsum to get indices of new number in repeated tensor, e.g. [0, 1, 3, 3]</span>
  <span class="n">scatter_indices</span> <span class="o">=</span> <span class="n">cumsum</span><span class="p">(</span><span class="n">exclusive_repeats</span><span class="p">)</span>
  <span class="c1"># Scatter these onto a zero buffer, e.g. [1,1,0,2,0,0,0,0]</span>
  <span class="n">block_split_indicators</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">index_add</span><span class="p">(</span>
      <span class="n">x</span><span class="o">=</span><span class="n">zeros</span><span class="p">([</span><span class="n">total_repeat_length</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">int32</span><span class="p">),</span>
      <span class="n">idx</span><span class="o">=</span><span class="n">scatter_indices</span><span class="p">,</span>
      <span class="n">y</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
  <span class="c1"># Cumsum again to get scatter indices for repeat, e.g. [0,1,1,3,3,3,3,3]</span>
  <span class="n">gather_indices</span> <span class="o">=</span> <span class="n">cumsum</span><span class="p">(</span><span class="n">block_split_indicators</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
  <span class="k">return</span> <span class="n">take</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">gather_indices</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">tri</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">tri</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">M</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="n">lax</span><span class="o">.</span><span class="n">_check_user_dtype_supported</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="s2">&quot;tri&quot;</span><span class="p">)</span>
  <span class="n">M</span> <span class="o">=</span> <span class="n">M</span> <span class="k">if</span> <span class="n">M</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">N</span>
  <span class="n">dtype</span> <span class="o">=</span> <span class="n">dtype</span> <span class="ow">or</span> <span class="n">float32</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">_tri</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">M</span><span class="p">),</span> <span class="n">k</span><span class="p">)</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">tril</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">tril</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;tril&quot;</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
  <span class="n">m_shape</span> <span class="o">=</span> <span class="n">shape</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">m_shape</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Argument to jax.numpy.tril must be at least 2D&quot;</span><span class="p">)</span>
  <span class="n">mask</span> <span class="o">=</span> <span class="n">tri</span><span class="p">(</span><span class="o">*</span><span class="n">m_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:],</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">broadcast</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">m_shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]),</span> <span class="n">m</span><span class="p">,</span> <span class="n">zeros_like</span><span class="p">(</span><span class="n">m</span><span class="p">))</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">triu</span><span class="p">,</span> <span class="n">update_doc</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">triu</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;triu&quot;</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
  <span class="n">m_shape</span> <span class="o">=</span> <span class="n">shape</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">m_shape</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Argument to jax.numpy.triu must be at least 2D&quot;</span><span class="p">)</span>
  <span class="n">mask</span> <span class="o">=</span> <span class="n">tri</span><span class="p">(</span><span class="o">*</span><span class="n">m_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:],</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">broadcast</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">m_shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]),</span> <span class="n">zeros_like</span><span class="p">(</span><span class="n">m</span><span class="p">),</span> <span class="n">m</span><span class="p">)</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">trace</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">axis1</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axis2</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;trace&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;The &#39;out&#39; argument to jnp.trace is not supported.&quot;</span><span class="p">)</span>
  <span class="n">lax</span><span class="o">.</span><span class="n">_check_user_dtype_supported</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="s2">&quot;trace&quot;</span><span class="p">)</span>

  <span class="n">axis1</span> <span class="o">=</span> <span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">axis1</span><span class="p">,</span> <span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
  <span class="n">axis2</span> <span class="o">=</span> <span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">axis2</span><span class="p">,</span> <span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>

  <span class="n">a_shape</span> <span class="o">=</span> <span class="n">shape</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">_dtype</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">integer</span><span class="p">):</span>
      <span class="n">default_int</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">canonicalize_dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int_</span><span class="p">)</span>
      <span class="k">if</span> <span class="n">iinfo</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">bits</span> <span class="o">&lt;</span> <span class="n">iinfo</span><span class="p">(</span><span class="n">default_int</span><span class="p">)</span><span class="o">.</span><span class="n">bits</span><span class="p">:</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">default_int</span>

  <span class="c1"># Move the axis? dimensions to the end.</span>
  <span class="n">perm</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a_shape</span><span class="p">))</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">axis1</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">axis2</span><span class="p">]</span>
  <span class="n">perm</span> <span class="o">=</span> <span class="n">perm</span> <span class="o">+</span> <span class="p">[</span><span class="n">axis1</span><span class="p">,</span> <span class="n">axis2</span><span class="p">]</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">perm</span><span class="p">)</span>

  <span class="c1"># Mask out the diagonal and reduce.</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">eye</span><span class="p">(</span><span class="n">a_shape</span><span class="p">[</span><span class="n">axis1</span><span class="p">],</span> <span class="n">a_shape</span><span class="p">[</span><span class="n">axis2</span><span class="p">],</span> <span class="n">k</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">),</span>
            <span class="n">a</span><span class="p">,</span> <span class="n">zeros_like</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
  <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_wrap_indices_function</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
  <span class="nd">@_wraps</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">update_doc</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
  <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">wrapper</span>

<span class="n">tril_indices</span> <span class="o">=</span> <span class="n">_wrap_indices_function</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">tril_indices</span><span class="p">)</span>
<span class="n">triu_indices</span> <span class="o">=</span> <span class="n">_wrap_indices_function</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">triu_indices</span><span class="p">)</span>
<span class="n">mask_indices</span> <span class="o">=</span> <span class="n">_wrap_indices_function</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mask_indices</span><span class="p">)</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">triu_indices_from</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">triu_indices_from</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">triu_indices</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">tril_indices_from</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">tril_indices_from</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">tril_indices</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag_indices</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">diag_indices</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">ndim</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;n argument to diag_indices must be nonnegative, got </span><span class="si">{}</span><span class="s2">&quot;</span>
                     <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
  <span class="k">if</span> <span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;ndim argument to diag_indices must be nonnegative, got </span><span class="si">{}</span><span class="s2">&quot;</span>
                     <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ndim</span><span class="p">))</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">iota</span><span class="p">(</span><span class="n">int_</span><span class="p">,</span> <span class="n">n</span><span class="p">),)</span> <span class="o">*</span> <span class="n">ndim</span>

<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag_indices_from</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">diag_indices_from</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;diag_indices_from&quot;</span><span class="p">,</span> <span class="n">arr</span><span class="p">)</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">arr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;input array must be at least 2-d&quot;</span><span class="p">)</span>

  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;All dimensions of input must be of equal length&quot;</span><span class="p">)</span>

  <span class="k">return</span> <span class="n">diag_indices</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ndim</span><span class="o">=</span><span class="n">arr</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>

<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diagonal</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">diagonal</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">axis1</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axis2</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;diagonal&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="n">a_shape</span> <span class="o">=</span> <span class="n">shape</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
  <span class="n">a_ndims</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a_shape</span><span class="p">)</span>

  <span class="c1"># Move the two dimensions to the end.</span>
  <span class="n">axis1</span> <span class="o">=</span> <span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">axis1</span><span class="p">,</span> <span class="n">a_ndims</span><span class="p">)</span>
  <span class="n">axis2</span> <span class="o">=</span> <span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">axis2</span><span class="p">,</span> <span class="n">a_ndims</span><span class="p">)</span>
  <span class="n">perm</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">a_ndims</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">axis1</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">axis2</span><span class="p">]</span>
  <span class="n">perm</span> <span class="o">=</span> <span class="n">perm</span> <span class="o">+</span> <span class="p">[</span><span class="n">axis1</span><span class="p">,</span> <span class="n">axis2</span><span class="p">]</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">perm</span><span class="p">)</span>

  <span class="c1"># Mask out the diagonal and reduce over one of the axes</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">eye</span><span class="p">(</span><span class="n">a_shape</span><span class="p">[</span><span class="n">axis1</span><span class="p">],</span> <span class="n">a_shape</span><span class="p">[</span><span class="n">axis2</span><span class="p">],</span> <span class="n">k</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">),</span>
            <span class="n">a</span><span class="p">,</span> <span class="n">zeros_like</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
  <span class="n">reduce_axis</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span> <span class="k">if</span> <span class="n">offset</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span>
  <span class="n">d</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">reduce_axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">_dtype</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>

  <span class="c1"># Slice out the correct diagonal size.</span>
  <span class="n">diag_size</span> <span class="o">=</span> <span class="n">_max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">_min</span><span class="p">(</span><span class="n">a_shape</span><span class="p">[</span><span class="n">axis1</span><span class="p">]</span> <span class="o">+</span> <span class="n">_min</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                           <span class="n">a_shape</span><span class="p">[</span><span class="n">axis2</span><span class="p">]</span> <span class="o">-</span> <span class="n">_max</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">slice_in_dim</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">diag_size</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">diag</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;diag&quot;</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
  <span class="n">v_shape</span> <span class="o">=</span> <span class="n">shape</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">v_shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">zero</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">lax</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(),</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">v_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">_abs</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">zero</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="p">((</span><span class="n">_max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">k</span><span class="p">),</span> <span class="n">_max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">k</span><span class="p">),</span> <span class="mi">0</span><span class="p">),))</span>
    <span class="k">return</span> <span class="n">where</span><span class="p">(</span><span class="n">eye</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">),</span> <span class="n">v</span><span class="p">,</span> <span class="n">zeros_like</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
  <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">v_shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">diagonal</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="n">k</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;diag input must be 1d or 2d&quot;</span><span class="p">)</span>

<span class="n">_SCALAR_VALUE_DOC</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">This differs from np.diagflat for some scalar values of v,</span>
<span class="s2">jax always returns a two-dimensional array, whereas numpy may</span>
<span class="s2">return a scalar depending on the type of v.</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diagflat</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_SCALAR_VALUE_DOC</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">diagflat</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;diagflat&quot;</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
  <span class="n">v</span> <span class="o">=</span> <span class="n">ravel</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
  <span class="n">v_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
  <span class="n">adj_length</span> <span class="o">=</span> <span class="n">v_length</span> <span class="o">+</span> <span class="n">_abs</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
  <span class="n">res</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">adj_length</span><span class="o">*</span><span class="n">adj_length</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">v</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
  <span class="n">i</span> <span class="o">=</span> <span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">adj_length</span><span class="o">-</span><span class="n">_abs</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">):</span>
    <span class="n">fi</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="n">k</span><span class="o">+</span><span class="n">i</span><span class="o">*</span><span class="n">adj_length</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">fi</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="n">k</span><span class="p">)</span><span class="o">*</span><span class="n">adj_length</span>
  <span class="n">res</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">index_update</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">ops</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">fi</span><span class="p">],</span> <span class="n">v</span><span class="p">)</span>
  <span class="n">res</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">adj_length</span><span class="p">,</span><span class="n">adj_length</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">res</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">polyval</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">polyval</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">poly1d</span><span class="p">):</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">poly1d</span><span class="p">):</span>
    <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">zeros_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)):</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">y</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
  <span class="k">return</span> <span class="n">y</span>

<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">polyadd</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">polyadd</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">):</span>
  <span class="n">a1</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span>
  <span class="n">a2</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a2</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">a2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">a1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
    <span class="k">return</span> <span class="n">a1</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="o">-</span><span class="n">a2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">a2</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">a2</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="o">-</span><span class="n">a1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">polyder</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">polyder</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
  <span class="n">p</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">m</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Order of derivative must be positive&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">p</span>
  <span class="k">if</span> <span class="n">m</span> <span class="o">%</span> <span class="mi">1</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;m must be an integer&quot;</span><span class="p">)</span>
  <span class="n">coeff</span> <span class="o">=</span> <span class="p">(</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="n">m</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">arange</span><span class="p">(</span><span class="n">m</span><span class="p">)[:,</span> <span class="n">newaxis</span><span class="p">])</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">p</span><span class="p">[:</span><span class="o">-</span><span class="n">m</span><span class="p">]</span> <span class="o">*</span> <span class="n">coeff</span>

<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">trim_zeros</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">trim_zeros</span><span class="p">(</span><span class="n">filt</span><span class="p">,</span> <span class="n">trim</span><span class="o">=</span><span class="s1">&#39;fb&#39;</span><span class="p">):</span>
  <span class="n">filt</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="n">asarray</span><span class="p">,</span> <span class="n">filt</span><span class="p">,</span>
    <span class="s2">&quot;Error arose in the `filt` argument of trim_zeros()&quot;</span><span class="p">)</span>
  <span class="n">nz</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">filt</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
  <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">nz</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">_dtype</span><span class="p">(</span><span class="n">filt</span><span class="p">))</span>
  <span class="n">start</span> <span class="o">=</span> <span class="n">argmin</span><span class="p">(</span><span class="n">nz</span><span class="p">)</span> <span class="k">if</span> <span class="s1">&#39;f&#39;</span> <span class="ow">in</span> <span class="n">trim</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">else</span> <span class="mi">0</span>
  <span class="n">end</span> <span class="o">=</span> <span class="n">argmin</span><span class="p">(</span><span class="n">nz</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="k">if</span> <span class="s1">&#39;b&#39;</span> <span class="ow">in</span> <span class="n">trim</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">else</span> <span class="mi">0</span>
  <span class="k">return</span> <span class="n">filt</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">filt</span><span class="p">)</span> <span class="o">-</span> <span class="n">end</span><span class="p">]</span>

<span class="n">_LEADING_ZEROS_DOC</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">Setting trim_leading_zeros=True makes the output match that of numpy.</span>
<span class="s2">But prevents the function from being able to be used in compiled code.</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">polymul</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_LEADING_ZEROS_DOC</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">polymul</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">trim_leading_zeros</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">poly1d</span><span class="p">):</span>
    <span class="n">a1</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">poly1d</span><span class="p">):</span>
    <span class="n">a2</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a2</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">trim_leading_zeros</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">a2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
    <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span> <span class="o">=</span> <span class="n">trim_zeros</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">trim</span><span class="o">=</span><span class="s1">&#39;f&#39;</span><span class="p">),</span> <span class="n">trim_zeros</span><span class="p">(</span><span class="n">a2</span><span class="p">,</span> <span class="n">trim</span><span class="o">=</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">a1</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">([</span><span class="mf">0.</span><span class="p">])</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">a2</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">([</span><span class="mf">0.</span><span class="p">])</span>
  <span class="n">val</span> <span class="o">=</span> <span class="n">convolve</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">val</span>

<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">polysub</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">polysub</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">polyadd</span><span class="p">(</span><span class="n">asarray</span><span class="p">(</span><span class="n">a1</span><span class="p">),</span> <span class="o">-</span><span class="n">asarray</span><span class="p">(</span><span class="n">a2</span><span class="p">))</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">concatenate</span><span class="p">([</span><span class="n">ravel</span><span class="p">(</span><span class="n">arr</span><span class="p">),</span> <span class="n">ravel</span><span class="p">(</span><span class="n">values</span><span class="p">)],</span> <span class="mi">0</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">concatenate</span><span class="p">([</span><span class="n">arr</span><span class="p">,</span> <span class="n">values</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">apply_along_axis</span><span class="p">(</span><span class="n">func1d</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">arr</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
  <span class="n">num_dims</span> <span class="o">=</span> <span class="n">ndim</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
  <span class="n">axis</span> <span class="o">=</span> <span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">num_dims</span><span class="p">)</span>
  <span class="n">func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">arr</span><span class="p">:</span> <span class="n">func1d</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_dims</span> <span class="o">-</span> <span class="n">axis</span><span class="p">):</span>
    <span class="n">func</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">vmap</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">in_axes</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">out_axes</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">axis</span><span class="p">):</span>
    <span class="n">func</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">vmap</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">in_axes</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">out_axes</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">apply_over_axes</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">apply_over_axes</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">axes</span><span class="p">):</span>
  <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">:</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
      <span class="n">a</span> <span class="o">=</span> <span class="n">b</span>
    <span class="k">elif</span> <span class="n">b</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
      <span class="n">a</span> <span class="o">=</span> <span class="n">expand_dims</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;function is not returning an array of the correct shape&quot;</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">a</span>


<span class="c1">### Tensor contraction operations</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_PRECISION_DOC</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>  <span class="c1"># pylint: disable=missing-docstring</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;dot&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
  <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">_promote_dtypes</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
  <span class="n">a_ndim</span><span class="p">,</span> <span class="n">b_ndim</span> <span class="o">=</span> <span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">ndim</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">a_ndim</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">b_ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">_max</span><span class="p">(</span><span class="n">a_ndim</span><span class="p">,</span> <span class="n">b_ndim</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="n">precision</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">b_ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">contract_dims</span> <span class="o">=</span> <span class="p">((</span><span class="n">a_ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,))</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">contract_dims</span> <span class="o">=</span> <span class="p">((</span><span class="n">a_ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,),</span> <span class="p">(</span><span class="n">b_ndim</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,))</span>
  <span class="n">batch_dims</span> <span class="o">=</span> <span class="p">((),</span> <span class="p">())</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">dot_general</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="p">(</span><span class="n">contract_dims</span><span class="p">,</span> <span class="n">batch_dims</span><span class="p">),</span> <span class="n">precision</span><span class="p">)</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_PRECISION_DOC</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">matmul</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>  <span class="c1"># pylint: disable=missing-docstring</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;matmul&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)):</span>
    <span class="k">if</span> <span class="n">ndim</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
      <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;matmul input operand </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> must have ndim at least 1, &quot;</span>
             <span class="sa">f</span><span class="s2">&quot;but it has ndim </span><span class="si">{</span><span class="n">ndim</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

  <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">_promote_dtypes</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

  <span class="n">a_is_mat</span><span class="p">,</span> <span class="n">b_is_mat</span> <span class="o">=</span> <span class="p">(</span><span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">ndim</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
  <span class="n">a_batch_dims</span> <span class="o">=</span> <span class="n">shape</span><span class="p">(</span><span class="n">a</span><span class="p">)[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="k">if</span> <span class="n">a_is_mat</span> <span class="k">else</span> <span class="p">()</span>
  <span class="n">b_batch_dims</span> <span class="o">=</span> <span class="n">shape</span><span class="p">(</span><span class="n">b</span><span class="p">)[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="k">if</span> <span class="n">b_is_mat</span> <span class="k">else</span> <span class="p">()</span>
  <span class="n">num_batch_dims</span> <span class="o">=</span> <span class="n">_max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a_batch_dims</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">b_batch_dims</span><span class="p">))</span>
  <span class="n">a_batch_dims</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,)</span> <span class="o">*</span> <span class="p">(</span><span class="n">num_batch_dims</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">a_batch_dims</span><span class="p">))</span> <span class="o">+</span> <span class="n">a_batch_dims</span>
  <span class="n">b_batch_dims</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,)</span> <span class="o">*</span> <span class="p">(</span><span class="n">num_batch_dims</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">b_batch_dims</span><span class="p">))</span> <span class="o">+</span> <span class="n">b_batch_dims</span>

  <span class="c1"># Dimensions to squeeze from the inputs.</span>
  <span class="n">a_squeeze</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="n">b_squeeze</span> <span class="o">=</span> <span class="p">[]</span>

  <span class="c1"># Positions of batch dimensions in squeezed inputs.</span>
  <span class="n">a_batch</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="n">b_batch</span> <span class="o">=</span> <span class="p">[]</span>

  <span class="c1"># Desired index in final output of each kind of dimension, in the order that</span>
  <span class="c1"># lax.dot_general will emit them.</span>
  <span class="n">idx_batch</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="n">idx_a_other</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># other = non-batch, non-contracting.</span>
  <span class="n">idx_b_other</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">ba</span><span class="p">,</span> <span class="n">bb</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">a_batch_dims</span><span class="p">,</span> <span class="n">b_batch_dims</span><span class="p">)):</span>
    <span class="k">if</span> <span class="n">ba</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
      <span class="n">idx_b_other</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">bb</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
      <span class="n">idx_a_other</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">ba</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
      <span class="n">idx_b_other</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
      <span class="n">a_squeeze</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">idx_batch</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx_a_other</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">a_squeeze</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">bb</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
      <span class="n">idx_a_other</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
      <span class="n">b_squeeze</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">idx_batch</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx_b_other</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">b_squeeze</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">ba</span> <span class="o">==</span> <span class="n">bb</span><span class="p">:</span>
      <span class="n">a_batch</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">idx_batch</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx_a_other</span><span class="p">))</span>
      <span class="n">b_batch</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">idx_batch</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx_b_other</span><span class="p">))</span>
      <span class="n">idx_batch</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Incompatible shapes for matmul arguments: </span><span class="si">{}</span><span class="s2"> and </span><span class="si">{}</span><span class="s2">&quot;</span>
                       <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">shape</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">shape</span><span class="p">(</span><span class="n">b</span><span class="p">)))</span>

  <span class="k">if</span> <span class="n">a_is_mat</span><span class="p">:</span> <span class="n">idx_a_other</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">num_batch_dims</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">b_is_mat</span><span class="p">:</span> <span class="n">idx_b_other</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">num_batch_dims</span> <span class="o">+</span> <span class="n">a_is_mat</span><span class="p">)</span>
  <span class="n">perm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">idx_batch</span><span class="p">,</span> <span class="n">idx_a_other</span><span class="p">,</span> <span class="n">idx_b_other</span><span class="p">]))</span>

  <span class="n">a</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">a_squeeze</span><span class="p">))</span>
  <span class="n">b</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">b_squeeze</span><span class="p">))</span>
  <span class="n">out</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">dot_general</span><span class="p">(</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="p">(((</span><span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,),</span> <span class="p">(</span><span class="n">ndim</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">b_is_mat</span><span class="p">,)),</span> <span class="p">(</span><span class="n">a_batch</span><span class="p">,</span> <span class="n">b_batch</span><span class="p">)),</span>
    <span class="n">precision</span><span class="o">=</span><span class="n">precision</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">perm</span><span class="p">)</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vdot</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_PRECISION_DOC</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">vdot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;vdot&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">_dtype</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">complexfloating</span><span class="p">):</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">conj</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">b</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">precision</span><span class="o">=</span><span class="n">precision</span><span class="p">)</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_PRECISION_DOC</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">tensordot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;tensordot&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
  <span class="n">a_ndim</span> <span class="o">=</span> <span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
  <span class="n">b_ndim</span> <span class="o">=</span> <span class="n">ndim</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>

  <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">_promote_dtypes</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">axes</span> <span class="o">&gt;</span> <span class="n">_min</span><span class="p">(</span><span class="n">a_ndim</span><span class="p">,</span> <span class="n">b_ndim</span><span class="p">):</span>
      <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Number of tensordot axes (axes </span><span class="si">{}</span><span class="s2">) exceeds input ranks (</span><span class="si">{}</span><span class="s2"> and </span><span class="si">{}</span><span class="s2">)&quot;</span>
      <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
    <span class="n">contracting_dims</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">a_ndim</span> <span class="o">-</span> <span class="n">axes</span><span class="p">,</span> <span class="n">a_ndim</span><span class="p">)),</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">axes</span><span class="p">))</span>
  <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span> <span class="ow">in</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
    <span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span> <span class="o">=</span> <span class="n">axes</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">ax1</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="n">ax2</span><span class="p">)</span> <span class="o">==</span> <span class="nb">int</span><span class="p">:</span>
      <span class="n">contracting_dims</span> <span class="o">=</span> <span class="p">((</span><span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">ax1</span><span class="p">,</span> <span class="n">a_ndim</span><span class="p">),),</span>
                          <span class="p">(</span><span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">ax2</span><span class="p">,</span> <span class="n">b_ndim</span><span class="p">),))</span>
    <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">ax1</span><span class="p">)</span> <span class="ow">in</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">ax2</span><span class="p">)</span> <span class="ow">in</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
      <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ax1</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ax2</span><span class="p">):</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;tensordot requires axes lists to have equal length, got </span><span class="si">{}</span><span class="s2"> and </span><span class="si">{}</span><span class="s2">.&quot;</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span><span class="p">))</span>
      <span class="n">contracting_dims</span> <span class="o">=</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">a_ndim</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ax1</span><span class="p">),</span>
                          <span class="nb">tuple</span><span class="p">(</span><span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">b_ndim</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ax2</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;tensordot requires both axes lists to be either ints, tuples or &quot;</span>
             <span class="s2">&quot;lists, got </span><span class="si">{}</span><span class="s2"> and </span><span class="si">{}</span><span class="s2">&quot;</span><span class="p">)</span>
      <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span><span class="p">))</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;tensordot axes argument must be an int, a pair of ints, or a pair &quot;</span>
           <span class="s2">&quot;of lists/tuples of ints.&quot;</span><span class="p">)</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">dot_general</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="p">(</span><span class="n">contracting_dims</span><span class="p">,</span> <span class="p">((),</span> <span class="p">())),</span>
                         <span class="n">precision</span><span class="o">=</span><span class="n">precision</span><span class="p">)</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_PRECISION_DOC</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">einsum</span><span class="p">(</span><span class="o">*</span><span class="n">operands</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">optimize</span><span class="o">=</span><span class="s1">&#39;greedy&#39;</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
           <span class="n">_use_xeinsum</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;The &#39;out&#39; argument to jnp.einsum is not supported.&quot;</span><span class="p">)</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">_use_xeinsum</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="s1">&#39;{&#39;</span> <span class="ow">in</span> <span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span>
      <span class="nb">len</span><span class="p">(</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="o">==</span> <span class="mi">2</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">xeinsum</span><span class="p">(</span><span class="o">*</span><span class="n">operands</span><span class="p">)</span>

  <span class="n">optimize</span> <span class="o">=</span> <span class="s1">&#39;greedy&#39;</span> <span class="k">if</span> <span class="n">optimize</span> <span class="ow">is</span> <span class="kc">True</span> <span class="k">else</span> <span class="n">optimize</span>
  <span class="c1"># using einsum_call=True here is an internal api for opt_einsum</span>
  <span class="n">operands</span><span class="p">,</span> <span class="n">contractions</span> <span class="o">=</span> <span class="n">opt_einsum</span><span class="o">.</span><span class="n">contract_path</span><span class="p">(</span>
      <span class="o">*</span><span class="n">operands</span><span class="p">,</span> <span class="n">einsum_call</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">use_blas</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">optimize</span><span class="o">=</span><span class="n">optimize</span><span class="p">)</span>
  <span class="n">contractions</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span> <span class="ow">in</span> <span class="n">contractions</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">_einsum</span><span class="p">(</span><span class="n">operands</span><span class="p">,</span> <span class="n">contractions</span><span class="p">,</span> <span class="n">precision</span><span class="p">)</span>

<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">einsum_path</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">einsum_path</span><span class="p">(</span><span class="n">subscripts</span><span class="p">,</span> <span class="o">*</span><span class="n">operands</span><span class="p">,</span> <span class="n">optimize</span><span class="o">=</span><span class="s1">&#39;greedy&#39;</span><span class="p">):</span>
  <span class="c1"># using einsum_call=True here is an internal api for opt_einsum</span>
  <span class="k">return</span> <span class="n">opt_einsum</span><span class="o">.</span><span class="n">contract_path</span><span class="p">(</span><span class="n">subscripts</span><span class="p">,</span> <span class="o">*</span><span class="n">operands</span><span class="p">,</span> <span class="n">optimize</span><span class="o">=</span><span class="n">optimize</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_removechars</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">chars</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="nb">str</span><span class="o">.</span><span class="n">maketrans</span><span class="p">(</span><span class="nb">dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="n">chars</span><span class="p">)))</span>

<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnums</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">_einsum</span><span class="p">(</span><span class="n">operands</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">,</span>
            <span class="n">contractions</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">FrozenSet</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">]],</span>
            <span class="n">precision</span><span class="p">):</span>
  <span class="n">operands</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">_promote_dtypes</span><span class="p">(</span><span class="o">*</span><span class="n">operands</span><span class="p">))</span>
  <span class="k">def</span> <span class="nf">sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axes</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span>
                      <span class="n">lax</span><span class="o">.</span><span class="n">add</span> <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">bool_</span> <span class="k">else</span> <span class="n">lax</span><span class="o">.</span><span class="n">bitwise_or</span><span class="p">,</span> <span class="n">axes</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">sum_uniques</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">uniques</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">uniques</span><span class="p">:</span>
      <span class="n">axes</span> <span class="o">=</span> <span class="p">[</span><span class="n">names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">uniques</span><span class="p">]</span>
      <span class="n">operand</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">axes</span><span class="p">)</span>
      <span class="n">names</span> <span class="o">=</span> <span class="n">_removechars</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">uniques</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">operand</span><span class="p">,</span> <span class="n">names</span>

  <span class="k">def</span> <span class="nf">sum_repeats</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">counts</span><span class="p">,</span> <span class="n">keep_names</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">counts</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
      <span class="k">if</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">names</span><span class="p">)</span> <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="n">name</span><span class="p">]</span>
        <span class="n">eye</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">_delta</span><span class="p">(</span><span class="n">operand</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">operand</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">axes</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">keep_names</span><span class="p">:</span>
          <span class="n">operand</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">operand</span> <span class="o">*</span> <span class="n">eye</span><span class="p">,</span> <span class="n">axes</span><span class="p">)</span>
          <span class="n">names</span> <span class="o">=</span> <span class="n">names</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="n">operand</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">operand</span> <span class="o">*</span> <span class="n">eye</span><span class="p">,</span> <span class="n">axes</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
          <span class="n">names</span> <span class="o">=</span> <span class="n">names</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">operand</span><span class="p">,</span> <span class="n">names</span>

  <span class="k">def</span> <span class="nf">filter_singleton_dims</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">other_shape</span><span class="p">,</span> <span class="n">other_names</span><span class="p">):</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">shape</span><span class="p">(</span><span class="n">operand</span><span class="p">)</span>
    <span class="n">new_shape</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">new_names</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">names</span><span class="p">):</span>
      <span class="n">other_i</span> <span class="o">=</span> <span class="n">other_names</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
      <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">other_i</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">other_shape</span><span class="p">[</span><span class="n">other_i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">new_shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">new_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">reshape</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">new_shape</span><span class="p">)),</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">new_names</span><span class="p">)</span>

  <span class="k">for</span> <span class="n">operand_indices</span><span class="p">,</span> <span class="n">contracted_names_set</span><span class="p">,</span> <span class="n">einstr</span> <span class="ow">in</span> <span class="n">contractions</span><span class="p">:</span>
    <span class="n">contracted_names</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">contracted_names_set</span><span class="p">)</span>
    <span class="n">input_str</span><span class="p">,</span> <span class="n">result_names</span> <span class="o">=</span> <span class="n">einstr</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;-&gt;&#39;</span><span class="p">)</span>
    <span class="n">input_names</span> <span class="o">=</span> <span class="n">input_str</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>

    <span class="c1"># switch on the number of operands to be processed in this loop iteration.</span>
    <span class="c1"># every case here sets &#39;operand&#39; and &#39;names&#39;.</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">operand_indices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
      <span class="n">operand</span> <span class="o">=</span> <span class="n">operands</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">operand_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
      <span class="n">names</span><span class="p">,</span> <span class="o">=</span> <span class="n">input_names</span>
      <span class="n">counts</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">Counter</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>

      <span class="c1"># sum out unique contracted indices with a single reduce-sum</span>
      <span class="n">uniques</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">contracted_names</span> <span class="k">if</span> <span class="n">counts</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>
      <span class="n">operand</span><span class="p">,</span> <span class="n">names</span> <span class="o">=</span> <span class="n">sum_uniques</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">uniques</span><span class="p">)</span>

      <span class="c1"># for every repeated index, do a contraction against an identity matrix</span>
      <span class="n">operand</span><span class="p">,</span> <span class="n">names</span> <span class="o">=</span> <span class="n">sum_repeats</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">counts</span><span class="p">,</span> <span class="n">result_names</span><span class="p">)</span>

    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">operand_indices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
      <span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">operands</span><span class="o">.</span><span class="n">pop</span><span class="p">,</span> <span class="n">operand_indices</span><span class="p">)</span>
      <span class="n">lhs_names</span><span class="p">,</span> <span class="n">rhs_names</span> <span class="o">=</span> <span class="n">input_names</span>

      <span class="c1"># handle cases where one side of a contracting or batch dimension is 1</span>
      <span class="c1"># but its counterpart is not.</span>
      <span class="n">lhs</span><span class="p">,</span> <span class="n">lhs_names</span> <span class="o">=</span> <span class="n">filter_singleton_dims</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">lhs_names</span><span class="p">,</span> <span class="n">shape</span><span class="p">(</span><span class="n">rhs</span><span class="p">),</span>
                                             <span class="n">rhs_names</span><span class="p">)</span>
      <span class="n">rhs</span><span class="p">,</span> <span class="n">rhs_names</span> <span class="o">=</span> <span class="n">filter_singleton_dims</span><span class="p">(</span><span class="n">rhs</span><span class="p">,</span> <span class="n">rhs_names</span><span class="p">,</span> <span class="n">shape</span><span class="p">(</span><span class="n">lhs</span><span class="p">),</span>
                                             <span class="n">lhs_names</span><span class="p">)</span>

      <span class="n">lhs_counts</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">Counter</span><span class="p">(</span><span class="n">lhs_names</span><span class="p">)</span>
      <span class="n">rhs_counts</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">Counter</span><span class="p">(</span><span class="n">rhs_names</span><span class="p">)</span>

      <span class="c1"># sum out unique contracted indices in lhs and rhs</span>
      <span class="n">lhs_uniques</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">contracted_names</span>
                     <span class="k">if</span> <span class="n">lhs_counts</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">rhs_counts</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span>
      <span class="n">lhs</span><span class="p">,</span> <span class="n">lhs_names</span> <span class="o">=</span> <span class="n">sum_uniques</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">lhs_names</span><span class="p">,</span> <span class="n">lhs_uniques</span><span class="p">)</span>

      <span class="n">rhs_uniques</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">contracted_names</span>
                     <span class="k">if</span> <span class="n">rhs_counts</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">lhs_counts</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span>
      <span class="n">rhs</span><span class="p">,</span> <span class="n">rhs_names</span> <span class="o">=</span> <span class="n">sum_uniques</span><span class="p">(</span><span class="n">rhs</span><span class="p">,</span> <span class="n">rhs_names</span><span class="p">,</span> <span class="n">rhs_uniques</span><span class="p">)</span>

      <span class="c1"># for every repeated index, contract against an identity matrix</span>
      <span class="n">lhs</span><span class="p">,</span> <span class="n">lhs_names</span> <span class="o">=</span> <span class="n">sum_repeats</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">lhs_names</span><span class="p">,</span> <span class="n">lhs_counts</span><span class="p">,</span>
                                   <span class="n">result_names</span> <span class="o">+</span> <span class="n">rhs_names</span><span class="p">)</span>
      <span class="n">rhs</span><span class="p">,</span> <span class="n">rhs_names</span> <span class="o">=</span> <span class="n">sum_repeats</span><span class="p">(</span><span class="n">rhs</span><span class="p">,</span> <span class="n">rhs_names</span><span class="p">,</span> <span class="n">rhs_counts</span><span class="p">,</span>
                                   <span class="n">result_names</span> <span class="o">+</span> <span class="n">lhs_names</span><span class="p">)</span>

      <span class="n">lhs_or_rhs_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">lhs_names</span><span class="p">)</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="n">rhs_names</span><span class="p">)</span>
      <span class="n">contracted_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">contracted_names</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">lhs_or_rhs_names</span><span class="p">]</span>
      <span class="n">lhs_and_rhs_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">lhs_names</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">rhs_names</span><span class="p">)</span>
      <span class="n">batch_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">result_names</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">lhs_and_rhs_names</span><span class="p">]</span>

      <span class="n">lhs_batch</span><span class="p">,</span> <span class="n">rhs_batch</span> <span class="o">=</span> <span class="n">unzip2</span><span class="p">((</span><span class="n">lhs_names</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">rhs_names</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
                                    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">batch_names</span><span class="p">)</span>

      <span class="c1"># NOTE(mattjj): this can fail non-deterministically in python3, maybe</span>
      <span class="c1"># due to opt_einsum</span>
      <span class="k">assert</span> <span class="n">_all</span><span class="p">(</span>
        <span class="n">name</span> <span class="ow">in</span> <span class="n">lhs_names</span> <span class="ow">and</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">rhs_names</span> <span class="ow">and</span>
        <span class="n">lhs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">lhs_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">name</span><span class="p">)]</span> <span class="o">==</span> <span class="n">rhs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">rhs_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">name</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">contracted_names</span><span class="p">)</span>

      <span class="c1"># contract using lax.dot_general</span>
      <span class="n">batch_names_str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">batch_names</span><span class="p">)</span>
      <span class="n">lhs_cont</span><span class="p">,</span> <span class="n">rhs_cont</span> <span class="o">=</span> <span class="n">unzip2</span><span class="p">((</span><span class="n">lhs_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">rhs_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
                                  <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">contracted_names</span><span class="p">)</span>
      <span class="n">dimension_numbers</span> <span class="o">=</span> <span class="p">((</span><span class="n">lhs_cont</span><span class="p">,</span> <span class="n">rhs_cont</span><span class="p">),</span> <span class="p">(</span><span class="n">lhs_batch</span><span class="p">,</span> <span class="n">rhs_batch</span><span class="p">))</span>
      <span class="n">operand</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">dot_general</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">dimension_numbers</span><span class="p">,</span> <span class="n">precision</span><span class="p">)</span>
      <span class="n">deleted_names</span> <span class="o">=</span> <span class="n">batch_names_str</span> <span class="o">+</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">contracted_names</span><span class="p">)</span>
      <span class="n">names</span> <span class="o">=</span> <span class="p">(</span><span class="n">batch_names_str</span> <span class="o">+</span> <span class="n">_removechars</span><span class="p">(</span><span class="n">lhs_names</span><span class="p">,</span> <span class="n">deleted_names</span><span class="p">)</span>
               <span class="o">+</span> <span class="n">_removechars</span><span class="p">(</span><span class="n">rhs_names</span><span class="p">,</span> <span class="n">deleted_names</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">NotImplementedError</span>  <span class="c1"># if this is actually reachable, open an issue!</span>

    <span class="c1"># the resulting &#39;operand&#39; with axis labels &#39;names&#39; should be a permutation</span>
    <span class="c1"># of the desired result</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">result_names</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">names</span><span class="p">))</span>
    <span class="k">assert</span> <span class="nb">set</span><span class="p">(</span><span class="n">names</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">result_names</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">names</span> <span class="o">!=</span> <span class="n">result_names</span><span class="p">:</span>
      <span class="n">perm</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">result_names</span><span class="p">])</span>
      <span class="n">operand</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">perm</span><span class="p">)</span>
    <span class="n">operands</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">operand</span><span class="p">)</span>  <span class="c1"># used in next iteration</span>

  <span class="k">return</span> <span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_movechars</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Helper for einsum string munging, like moveaxis on identifier strings.&quot;&quot;&quot;</span>
  <span class="n">chars</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">src</span><span class="p">]</span>
  <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">src</span><span class="p">)):</span>
    <span class="n">chars</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
  <span class="k">return</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">chars</span><span class="p">)</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_PRECISION_DOC</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">inner</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">ndim</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span>
  <span class="k">return</span> <span class="n">tensordot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">precision</span><span class="o">=</span><span class="n">precision</span><span class="p">)</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">outer</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;The &#39;out&#39; argument to jnp.outer is not supported.&quot;</span><span class="p">)</span>
  <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">_promote_dtypes</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">ravel</span><span class="p">(</span><span class="n">a</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">ravel</span><span class="p">(</span><span class="n">b</span><span class="p">)[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>

<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnums</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">_cross</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">axisa</span><span class="p">,</span> <span class="n">axisb</span><span class="p">,</span> <span class="n">axisc</span><span class="p">):</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">moveaxis</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axisa</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
  <span class="n">b</span> <span class="o">=</span> <span class="n">moveaxis</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">axisb</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="ow">or</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Dimension must be either 2 or 3 for cross product&quot;</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">b</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">a</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">b</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

  <span class="n">a0</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
  <span class="n">a1</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
  <span class="n">a2</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span> <span class="k">else</span> <span class="n">zeros_like</span><span class="p">(</span><span class="n">a0</span><span class="p">)</span>
  <span class="n">b0</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
  <span class="n">b1</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
  <span class="n">b2</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span> <span class="k">else</span> <span class="n">zeros_like</span><span class="p">(</span><span class="n">b0</span><span class="p">)</span>
  <span class="n">c</span> <span class="o">=</span> <span class="n">array</span><span class="p">([</span><span class="n">a1</span> <span class="o">*</span> <span class="n">b2</span> <span class="o">-</span> <span class="n">a2</span> <span class="o">*</span> <span class="n">b1</span><span class="p">,</span> <span class="n">a2</span> <span class="o">*</span> <span class="n">b0</span> <span class="o">-</span> <span class="n">a0</span> <span class="o">*</span> <span class="n">b2</span><span class="p">,</span> <span class="n">a0</span> <span class="o">*</span> <span class="n">b1</span> <span class="o">-</span> <span class="n">a1</span> <span class="o">*</span> <span class="n">b0</span><span class="p">])</span>
  <span class="k">return</span> <span class="n">moveaxis</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axisc</span><span class="p">)</span>

<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">cross</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">axisa</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axisb</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axisc</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
          <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">axisa</span> <span class="o">=</span> <span class="n">axis</span>
    <span class="n">axisb</span> <span class="o">=</span> <span class="n">axis</span>
    <span class="n">axisc</span> <span class="o">=</span> <span class="n">axis</span>
  <span class="k">return</span> <span class="n">_cross</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">axisa</span><span class="p">,</span> <span class="n">axisb</span><span class="p">,</span> <span class="n">axisc</span><span class="p">)</span>

<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">kron</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
  <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">_promote_dtypes</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">ndim</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">reshape</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">*</span> <span class="p">(</span><span class="n">ndim</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">-</span> <span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">))</span> <span class="o">+</span> <span class="n">shape</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
  <span class="k">elif</span> <span class="n">ndim</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">reshape</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">*</span> <span class="p">(</span><span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">-</span> <span class="n">ndim</span><span class="p">(</span><span class="n">b</span><span class="p">))</span> <span class="o">+</span> <span class="n">shape</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
  <span class="n">a_reshaped</span> <span class="o">=</span> <span class="n">reshape</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">shape</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="mi">1</span><span class="p">)])</span>
  <span class="n">b_reshaped</span> <span class="o">=</span> <span class="n">reshape</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">shape</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">d</span><span class="p">)])</span>
  <span class="n">out_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">shape</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">shape</span><span class="p">(</span><span class="n">b</span><span class="p">)))</span>
  <span class="k">return</span> <span class="n">reshape</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">a_reshaped</span><span class="p">,</span> <span class="n">b_reshaped</span><span class="p">),</span> <span class="n">out_shape</span><span class="p">)</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vander</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">vander</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">increasing</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
  <span class="n">x</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="n">dtype</span> <span class="o">=</span> <span class="n">_dtype</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">ndim</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;x must be a one-dimensional array&quot;</span><span class="p">)</span>
  <span class="n">x_shape</span> <span class="o">=</span> <span class="n">shape</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="n">N</span> <span class="o">=</span> <span class="n">N</span> <span class="ow">or</span> <span class="n">x_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="k">if</span> <span class="n">N</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;N must be nonnegative&quot;</span><span class="p">)</span>

  <span class="n">iota</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">iota</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">increasing</span><span class="p">:</span>
    <span class="n">iota</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">_const</span><span class="p">(</span><span class="n">iota</span><span class="p">,</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="n">iota</span><span class="p">)</span>

  <span class="k">return</span> <span class="n">power</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">iota</span><span class="p">)</span>


<span class="c1">### Misc</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">argwhere</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">transpose</span><span class="p">(</span><span class="n">vstack</span><span class="p">(</span><span class="n">nonzero</span><span class="p">(</span><span class="n">a</span><span class="p">)))</span>
  <span class="k">if</span> <span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">[:</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">argmax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;argmax&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;The &#39;out&#39; argument to jnp.argmax is not supported.&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">ravel</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;attempt to get argmax of an empty sequence&quot;</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span><span class="p">),</span> <span class="n">int64</span><span class="p">)</span>

<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">argmin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;argmin&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;The &#39;out&#39; argument to jnp.argmin is not supported.&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">ravel</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;attempt to get argmin of an empty sequence&quot;</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span><span class="p">),</span> <span class="n">int64</span><span class="p">)</span>


<span class="n">_NANARG_DOC</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">Warning: jax.numpy.arg</span><span class="si">{}</span><span class="s2"> returns -1 for all-NaN slices and does not raise</span>
<span class="s2">an error.</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanargmax</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_NANARG_DOC</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;max&quot;</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">nanargmax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;nanargmax&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">_dtype</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">inexact</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">argmax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
  <span class="n">nan_mask</span> <span class="o">=</span> <span class="n">isnan</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">nan_mask</span><span class="p">,</span> <span class="o">-</span><span class="n">inf</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="n">res</span> <span class="o">=</span> <span class="n">argmax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">where</span><span class="p">(</span><span class="nb">all</span><span class="p">(</span><span class="n">nan_mask</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>

<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanargmin</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_NANARG_DOC</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;min&quot;</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">nanargmin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;nanargmin&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">_dtype</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">inexact</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">argmin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
  <span class="n">nan_mask</span> <span class="o">=</span> <span class="n">isnan</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">nan_mask</span><span class="p">,</span> <span class="n">inf</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="n">res</span> <span class="o">=</span> <span class="n">argmin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">where</span><span class="p">(</span><span class="nb">all</span><span class="p">(</span><span class="n">nan_mask</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">sort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;quicksort&#39;</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;sort&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">kind</span> <span class="o">!=</span> <span class="s1">&#39;quicksort&#39;</span><span class="p">:</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;&#39;kind&#39; argument to sort is ignored.&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">order</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;order&#39; argument to sort is not supported.&quot;</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">dimension</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">)))</span>

<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort_complex</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">sort_complex</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;sort_complex&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">convert_element_type</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">result_type</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">canonicalize_dtype</span><span class="p">(</span><span class="n">complex_</span><span class="p">)))</span>

<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">lexsort</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">lexsort</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
  <span class="n">keys</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;need sequence of keys with len &gt; 0 in lexsort&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">({</span><span class="n">shape</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">})</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;all keys need to be the same shape&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">ndim</span><span class="p">(</span><span class="n">keys</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
  <span class="n">axis</span> <span class="o">=</span> <span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">ndim</span><span class="p">(</span><span class="n">keys</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
  <span class="n">iota</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">broadcasted_iota</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">shape</span><span class="p">(</span><span class="n">keys</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">axis</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">sort</span><span class="p">((</span><span class="o">*</span><span class="n">keys</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">iota</span><span class="p">),</span> <span class="n">dimension</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">num_keys</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">))[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">argsort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;quicksort&#39;</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;argsort&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">kind</span> <span class="o">!=</span> <span class="s1">&#39;quicksort&#39;</span><span class="p">:</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;&#39;kind&#39; argument to argsort is ignored.&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">order</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;order&#39; argument to argsort is not supported.&quot;</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">argsort</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="mi">0</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">axis_num</span> <span class="o">=</span> <span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
    <span class="n">iota</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">broadcasted_iota</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">shape</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">axis_num</span><span class="p">)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">perm</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">sort_key_val</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">iota</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="n">axis_num</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">perm</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">msort</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">msort</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">sort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>


<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnums</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,))</span>
<span class="k">def</span> <span class="nf">_roll</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">shift</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
  <span class="n">a_shape</span> <span class="o">=</span> <span class="n">shape</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">roll</span><span class="p">(</span><span class="n">ravel</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">shift</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">a_shape</span><span class="p">)</span>

  <span class="n">a_ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a_shape</span><span class="p">)</span>
  <span class="n">shift</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">shift</span><span class="p">)</span>
  <span class="n">axis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
  <span class="n">b_shape</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">broadcast_shapes</span><span class="p">(</span><span class="n">shift</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">axis</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,))</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">b_shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;&#39;shift&#39; and &#39;axis&#39; arguments to roll must be scalars or 1D arrays&quot;</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

  <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">shift</span><span class="p">,</span> <span class="n">b_shape</span><span class="p">),</span>
                  <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">b_shape</span><span class="p">)):</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">a_ndim</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">remainder</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">a_shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">or</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">),</span> <span class="n">i</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">dynamic_slice_in_dim</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a_shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">,</span> <span class="n">a_shape</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">a</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">roll</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">shift</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
    <span class="n">axis</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">_roll</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">shift</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">rollaxis</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;rollaxis&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="n">a_ndim</span> <span class="o">=</span> <span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
  <span class="n">axis</span> <span class="o">=</span> <span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">a_ndim</span><span class="p">)</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="o">-</span><span class="n">a_ndim</span> <span class="o">&lt;=</span> <span class="n">start</span> <span class="o">&lt;=</span> <span class="n">a_ndim</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;start=</span><span class="si">{</span><span class="n">start</span><span class="si">}</span><span class="s2"> must satisfy </span><span class="si">{</span><span class="o">-</span><span class="n">a_ndim</span><span class="si">}</span><span class="s2">&lt;=start&lt;=</span><span class="si">{</span><span class="n">a_ndim</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">start</span> <span class="o">+=</span> <span class="n">a_ndim</span>
  <span class="k">if</span> <span class="n">start</span> <span class="o">&gt;</span> <span class="n">axis</span><span class="p">:</span>
    <span class="n">start</span> <span class="o">-=</span> <span class="mi">1</span>
  <span class="k">return</span> <span class="n">moveaxis</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">start</span><span class="p">)</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">packbits</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">packbits</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">bitorder</span><span class="o">=</span><span class="s1">&#39;big&#39;</span><span class="p">):</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">integer</span><span class="p">)</span> <span class="ow">or</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">bool_</span><span class="p">)):</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Expected an input array of integer or boolean data type&#39;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">bitorder</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;little&#39;</span><span class="p">,</span> <span class="s1">&#39;big&#39;</span><span class="p">]:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;order&#39; must be either &#39;little&#39; or &#39;big&#39;&quot;</span><span class="p">)</span>
  <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;uint8&#39;</span><span class="p">)</span>
  <span class="n">bits</span> <span class="o">=</span> <span class="n">arange</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;uint8&#39;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">bitorder</span> <span class="o">==</span> <span class="s1">&#39;big&#39;</span><span class="p">:</span>
    <span class="n">bits</span> <span class="o">=</span> <span class="n">bits</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
  <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">ravel</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">swapaxes</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

  <span class="n">remainder</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">%</span> <span class="mi">8</span>
  <span class="k">if</span> <span class="n">remainder</span><span class="p">:</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">pad</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span> <span class="o">+</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">8</span> <span class="o">-</span> <span class="n">remainder</span><span class="p">)])</span>

  <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">//</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
  <span class="n">packed</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">bits</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;uint8&#39;</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">swapaxes</span><span class="p">(</span><span class="n">packed</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unpackbits</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">unpackbits</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bitorder</span><span class="o">=</span><span class="s1">&#39;big&#39;</span><span class="p">):</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">dtype</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">!=</span> <span class="n">uint8</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Expected an input array of unsigned byte data type&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">bitorder</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;little&#39;</span><span class="p">,</span> <span class="s1">&#39;big&#39;</span><span class="p">]:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;order&#39; must be either &#39;little&#39; or &#39;big&#39;&quot;</span><span class="p">)</span>
  <span class="n">bits</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">arange</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;uint8&#39;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">bitorder</span> <span class="o">==</span> <span class="s1">&#39;big&#39;</span><span class="p">:</span>
    <span class="n">bits</span> <span class="o">=</span> <span class="n">bits</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
  <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">swapaxes</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
  <span class="n">unpacked</span> <span class="o">=</span> <span class="p">((</span><span class="n">a</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">bits</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;uint8&#39;</span><span class="p">)</span>
  <span class="n">unpacked</span> <span class="o">=</span> <span class="n">unpacked</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">unpacked</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,))[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="n">count</span><span class="p">]</span>
  <span class="k">return</span> <span class="n">swapaxes</span><span class="p">(</span><span class="n">unpacked</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">take</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;The &#39;out&#39; argument to jnp.take is not supported.&quot;</span><span class="p">)</span>

  <span class="n">a</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
  <span class="n">indices</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">ravel</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">axis_idx</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">axis_idx</span> <span class="o">=</span> <span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>

  <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;raise&quot;</span><span class="p">:</span>
    <span class="c1"># TODO(phawkins): we have no way to report out of bounds errors yet.</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;The &#39;raise&#39; mode to jnp.take is not supported.&quot;</span><span class="p">)</span>
  <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;wrap&quot;</span><span class="p">:</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">mod</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">_constant_like</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis_idx</span><span class="p">]))</span>
  <span class="k">elif</span> <span class="n">mode</span> <span class="o">!=</span> <span class="s2">&quot;clip&quot;</span> <span class="ow">and</span> <span class="n">mode</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid mode &#39;</span><span class="si">{}</span><span class="s2">&#39; for np.take&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span>

  <span class="n">index_dims</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">(</span><span class="n">indices</span><span class="p">))</span>
  <span class="n">slice_sizes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">shape</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
  <span class="n">slice_sizes</span><span class="p">[</span><span class="n">axis_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">_min</span><span class="p">(</span><span class="n">indices</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
  <span class="n">dnums</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">GatherDimensionNumbers</span><span class="p">(</span>
    <span class="n">offset_dims</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span>
      <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">axis_idx</span><span class="p">))</span> <span class="o">+</span>
      <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">axis_idx</span> <span class="o">+</span> <span class="n">index_dims</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">+</span> <span class="n">index_dims</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))),</span>
    <span class="n">collapsed_slice_dims</span><span class="o">=</span><span class="p">(</span><span class="n">axis_idx</span><span class="p">,),</span>
    <span class="n">start_index_map</span><span class="o">=</span><span class="p">(</span><span class="n">axis_idx</span><span class="p">,))</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">indices</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">dimension_numbers</span><span class="o">=</span><span class="n">dnums</span><span class="p">,</span>
                    <span class="n">slice_sizes</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slice_sizes</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_normalize_index</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">axis_size</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Normalizes an index value in the range [-N, N) to the range [0, N).&quot;&quot;&quot;</span>
  <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">axis_size</span><span class="p">)</span> <span class="ow">is</span> <span class="n">Poly</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">index</span> <span class="o">+</span> <span class="n">axis_size</span> <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">index</span>

  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">select</span><span class="p">(</span>
    <span class="n">lax</span><span class="o">.</span><span class="n">lt</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">_constant_like</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="mi">0</span><span class="p">)),</span>
    <span class="n">lax</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">_constant_like</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">axis_size</span><span class="p">)),</span>
    <span class="n">index</span><span class="p">)</span>

<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnums</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,))</span>
<span class="k">def</span> <span class="nf">_take_along_axis</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">ndim</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
      <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;take_along_axis indices must be 1D if axis=None, got shape </span><span class="si">{}</span><span class="s2">&quot;</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">indices</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">take_along_axis</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">indices</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
  <span class="n">rank</span> <span class="o">=</span> <span class="n">ndim</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">rank</span> <span class="o">!=</span> <span class="n">ndim</span><span class="p">(</span><span class="n">indices</span><span class="p">):</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;indices and arr must have the same number of dimensions; </span><span class="si">{}</span><span class="s2"> vs. </span><span class="si">{}</span><span class="s2">&quot;</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ndim</span><span class="p">(</span><span class="n">indices</span><span class="p">),</span> <span class="n">ndim</span><span class="p">(</span><span class="n">arr</span><span class="p">)))</span>
  <span class="n">axis</span> <span class="o">=</span> <span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">rank</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">replace</span><span class="p">(</span><span class="n">tup</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
    <span class="n">lst</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">tup</span><span class="p">)</span>
    <span class="n">lst</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span>

  <span class="n">use_64bit_index</span> <span class="o">=</span> <span class="n">_any</span><span class="p">([</span><span class="nb">type</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="ow">is</span> <span class="n">Poly</span> <span class="ow">or</span> <span class="n">d</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">31</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">])</span>
  <span class="n">index_dtype</span> <span class="o">=</span> <span class="n">int64</span> <span class="k">if</span> <span class="n">use_64bit_index</span> <span class="k">else</span> <span class="n">int32</span>
  <span class="n">indices</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">convert_element_type</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">index_dtype</span><span class="p">)</span>

  <span class="n">bcast_shape</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">broadcast_shapes</span><span class="p">(</span><span class="n">replace</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">replace</span><span class="p">(</span><span class="n">indices</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
  <span class="n">indices</span> <span class="o">=</span> <span class="n">broadcast_to</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">replace</span><span class="p">(</span><span class="n">bcast_shape</span><span class="p">,</span> <span class="n">indices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]))</span>
  <span class="n">arr</span>     <span class="o">=</span> <span class="n">broadcast_to</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span>     <span class="n">replace</span><span class="p">(</span><span class="n">bcast_shape</span><span class="p">,</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]))</span>

  <span class="n">axis_size</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
  <span class="n">arr_shape</span> <span class="o">=</span> <span class="n">replace</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
  <span class="n">idx_shape</span> <span class="o">=</span> <span class="n">indices</span><span class="o">.</span><span class="n">shape</span>
  <span class="n">out_shape</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">broadcast_shapes</span><span class="p">(</span><span class="n">idx_shape</span><span class="p">,</span> <span class="n">arr_shape</span><span class="p">)</span>

  <span class="n">index_dims</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">idx_shape</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">axis</span> <span class="ow">or</span> <span class="n">idx</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">]</span>

  <span class="n">gather_index_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">out_shape</span><span class="p">)[</span><span class="n">index_dims</span><span class="p">])</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span>
  <span class="n">gather_indices</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="n">slice_sizes</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="n">offset_dims</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="n">start_index_map</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="n">collapsed_slice_dims</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rank</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">axis</span><span class="p">:</span>
      <span class="n">indices</span> <span class="o">=</span> <span class="n">_normalize_index</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">axis_size</span><span class="p">)</span>
      <span class="n">gather_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">gather_index_shape</span><span class="p">))</span>
      <span class="n">slice_sizes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
      <span class="n">start_index_map</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
      <span class="n">collapsed_slice_dims</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
      <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">elif</span> <span class="n">idx_shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
      <span class="n">iota</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">iota</span><span class="p">(</span><span class="n">_dtype</span><span class="p">(</span><span class="n">indices</span><span class="p">),</span> <span class="n">out_shape</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
      <span class="k">if</span> <span class="ow">not</span> <span class="n">config</span><span class="o">.</span><span class="n">omnistaging_enabled</span><span class="p">:</span>
        <span class="n">iota</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">tie_in</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">iota</span><span class="p">)</span>
      <span class="n">iota</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">broadcast_in_dim</span><span class="p">(</span><span class="n">iota</span><span class="p">,</span> <span class="n">gather_index_shape</span><span class="p">,</span> <span class="p">(</span><span class="n">j</span><span class="p">,))</span>
      <span class="n">gather_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">iota</span><span class="p">)</span>
      <span class="n">slice_sizes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
      <span class="n">start_index_map</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
      <span class="n">collapsed_slice_dims</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
      <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="c1"># If idx_shape[i] == 1, we can just take the entirety of the arr&#39;s axis</span>
      <span class="c1"># and avoid forming an iota index.</span>
      <span class="n">offset_dims</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
      <span class="n">slice_sizes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arr_shape</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

  <span class="n">gather_indices</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">gather_indices</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="n">j</span><span class="p">)</span>
  <span class="n">dnums</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">GatherDimensionNumbers</span><span class="p">(</span>
    <span class="n">offset_dims</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">offset_dims</span><span class="p">),</span>
    <span class="n">collapsed_slice_dims</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">collapsed_slice_dims</span><span class="p">),</span>
    <span class="n">start_index_map</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">start_index_map</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">gather_indices</span><span class="p">,</span> <span class="n">dnums</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">slice_sizes</span><span class="p">))</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s2">&quot;take_along_axis&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="n">update_doc</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">take_along_axis</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;take_along_axis&quot;</span><span class="p">,</span> <span class="n">arr</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">_take_along_axis</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>


<span class="c1">### SetOps</span>

<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnums</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_unique1d_sorted_mask</span><span class="p">(</span><span class="n">ar</span><span class="p">,</span> <span class="n">optional_indices</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Helper function for unique which is jit-able</span>
<span class="sd">  &quot;&quot;&quot;</span>

  <span class="n">ar</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">ar</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

  <span class="k">if</span> <span class="n">optional_indices</span><span class="p">:</span>
    <span class="n">perm</span> <span class="o">=</span> <span class="n">ar</span><span class="o">.</span><span class="n">argsort</span><span class="p">()</span>
    <span class="n">aux</span> <span class="o">=</span> <span class="n">ar</span><span class="p">[</span><span class="n">perm</span><span class="p">]</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">aux</span> <span class="o">=</span> <span class="n">ar</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

  <span class="n">mask</span> <span class="o">=</span> <span class="n">empty</span><span class="p">(</span><span class="n">aux</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">bool_</span><span class="p">)</span>
  <span class="n">mask</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">index_update</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">ops</span><span class="o">.</span><span class="n">index</span><span class="p">[:</span><span class="mi">1</span><span class="p">],</span> <span class="kc">True</span><span class="p">)</span>
  <span class="n">mask</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">index_update</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">ops</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">aux</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">!=</span> <span class="n">aux</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

  <span class="k">if</span> <span class="n">optional_indices</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">aux</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">perm</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">aux</span><span class="p">,</span> <span class="n">mask</span>

<span class="k">def</span> <span class="nf">_unique1d</span><span class="p">(</span><span class="n">ar</span><span class="p">,</span> <span class="n">return_index</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">return_inverse</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
              <span class="n">return_counts</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Find the unique elements of an array, ignoring shape.</span>
<span class="sd">  &quot;&quot;&quot;</span>

  <span class="n">optional_indices</span> <span class="o">=</span> <span class="n">return_index</span> <span class="ow">or</span> <span class="n">return_inverse</span>

  <span class="k">if</span> <span class="n">optional_indices</span><span class="p">:</span>
    <span class="n">aux</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">perm</span> <span class="o">=</span> <span class="n">_unique1d_sorted_mask</span><span class="p">(</span><span class="n">ar</span><span class="p">,</span> <span class="n">optional_indices</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">aux</span><span class="p">,</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">_unique1d_sorted_mask</span><span class="p">(</span><span class="n">ar</span><span class="p">,</span> <span class="n">optional_indices</span><span class="p">)</span>

  <span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="n">aux</span><span class="p">[</span><span class="n">mask</span><span class="p">],)</span>
  <span class="k">if</span> <span class="n">return_index</span><span class="p">:</span>
    <span class="n">ret</span> <span class="o">+=</span> <span class="p">(</span><span class="n">perm</span><span class="p">[</span><span class="n">mask</span><span class="p">],)</span>
  <span class="k">if</span> <span class="n">return_inverse</span><span class="p">:</span>
    <span class="n">imask</span> <span class="o">=</span> <span class="n">cumsum</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">inv_idx</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtypes</span><span class="o">.</span><span class="n">canonicalize_dtype</span><span class="p">(</span><span class="n">int_</span><span class="p">))</span>
    <span class="n">inv_idx</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">index_update</span><span class="p">(</span><span class="n">inv_idx</span><span class="p">,</span> <span class="n">perm</span><span class="p">,</span> <span class="n">imask</span><span class="p">)</span>
    <span class="n">ret</span> <span class="o">+=</span> <span class="p">(</span><span class="n">inv_idx</span><span class="p">,)</span>
  <span class="k">if</span> <span class="n">return_counts</span><span class="p">:</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">(</span><span class="n">nonzero</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">array</span><span class="p">([</span><span class="n">mask</span><span class="o">.</span><span class="n">size</span><span class="p">]),))</span>
    <span class="n">ret</span> <span class="o">+=</span> <span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="n">idx</span><span class="p">),)</span>
  <span class="k">return</span> <span class="n">ret</span>

<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">unique</span><span class="p">(</span><span class="n">ar</span><span class="p">,</span> <span class="n">return_index</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">return_inverse</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
           <span class="n">return_counts</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
  <span class="n">ar</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="n">asarray</span><span class="p">,</span> <span class="n">ar</span><span class="p">,</span> <span class="s2">&quot;The error arose in jnp.unique()&quot;</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">iscomplexobj</span><span class="p">(</span><span class="n">ar</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
          <span class="s2">&quot;np.unique is not implemented for complex valued arrays&quot;</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">_unique1d</span><span class="p">(</span><span class="n">ar</span><span class="p">,</span> <span class="n">return_index</span><span class="p">,</span> <span class="n">return_inverse</span><span class="p">,</span> <span class="n">return_counts</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">ret</span>

  <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
        <span class="s2">&quot;np.unique is not implemented for the axis argument&quot;</span><span class="p">)</span>

<span class="c1">### Indexing</span>

<span class="k">def</span> <span class="nf">_rewriting_take</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
  <span class="c1"># Computes arr[idx].</span>
  <span class="c1"># All supported cases of indexing can be implemented as an XLA gather,</span>
  <span class="c1"># followed by an optional reverse and broadcast_in_dim.</span>
  <span class="n">arr</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
  <span class="n">treedef</span><span class="p">,</span> <span class="n">static_idx</span><span class="p">,</span> <span class="n">dynamic_idx</span> <span class="o">=</span> <span class="n">_split_index_for_jit</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">_gather</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">treedef</span><span class="p">,</span> <span class="n">static_idx</span><span class="p">,</span> <span class="n">dynamic_idx</span><span class="p">)</span>

<span class="c1"># TODO(phawkins): re-enable jit after fixing excessive recompilation for</span>
<span class="c1"># slice indexes (e.g., slice(0, 5, None), slice(10, 15, None), etc.).</span>
<span class="c1"># @partial(jit, static_argnums=(1, 2))</span>
<span class="k">def</span> <span class="nf">_gather</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">treedef</span><span class="p">,</span> <span class="n">static_idx</span><span class="p">,</span> <span class="n">dynamic_idx</span><span class="p">):</span>
  <span class="n">idx</span> <span class="o">=</span> <span class="n">_merge_static_and_dynamic_indices</span><span class="p">(</span><span class="n">treedef</span><span class="p">,</span> <span class="n">static_idx</span><span class="p">,</span> <span class="n">dynamic_idx</span><span class="p">)</span>
  <span class="n">indexer</span> <span class="o">=</span> <span class="n">_index_to_gather</span><span class="p">(</span><span class="n">shape</span><span class="p">(</span><span class="n">arr</span><span class="p">),</span> <span class="n">idx</span><span class="p">)</span>  <span class="c1"># shared with _scatter_update</span>
  <span class="n">y</span> <span class="o">=</span> <span class="n">arr</span>

  <span class="c1"># Avoid calling gather if the slice shape is empty, both as a fast path and to</span>
  <span class="c1"># handle cases like zeros(0)[array([], int32)].</span>
  <span class="k">if</span> <span class="n">_prod</span><span class="p">(</span><span class="n">indexer</span><span class="o">.</span><span class="n">slice_shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">zeros_like</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">indexer</span><span class="o">.</span><span class="n">slice_shape</span><span class="p">)</span>

  <span class="c1"># We avoid generating a gather when indexer.gather_indices.size is empty.</span>
  <span class="k">if</span> <span class="n">indexer</span><span class="o">.</span><span class="n">gather_indices</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">indexer</span><span class="o">.</span><span class="n">gather_indices</span><span class="p">,</span> <span class="n">indexer</span><span class="o">.</span><span class="n">dnums</span><span class="p">,</span>
                   <span class="n">indexer</span><span class="o">.</span><span class="n">gather_slice_shape</span><span class="p">)</span>

  <span class="c1"># Reverses axes with negative strides.</span>
  <span class="k">if</span> <span class="n">indexer</span><span class="o">.</span><span class="n">reversed_y_dims</span><span class="p">:</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">rev</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">indexer</span><span class="o">.</span><span class="n">reversed_y_dims</span><span class="p">)</span>

  <span class="c1"># This adds np.newaxis/None dimensions.</span>
  <span class="k">return</span> <span class="n">expand_dims</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">indexer</span><span class="o">.</span><span class="n">newaxis_dims</span><span class="p">)</span>

<span class="n">_Indexer</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s2">&quot;_Indexer&quot;</span><span class="p">,</span> <span class="p">[</span>
  <span class="c1"># The expected shape of the slice output.</span>
  <span class="s2">&quot;slice_shape&quot;</span><span class="p">,</span>

  <span class="c1"># The slice shape to pass to lax.gather().</span>
  <span class="s2">&quot;gather_slice_shape&quot;</span><span class="p">,</span>

  <span class="c1"># The gather indices to use.</span>
  <span class="s2">&quot;gather_indices&quot;</span><span class="p">,</span>

  <span class="c1"># A GatherDimensionNumbers object describing the gather to perform.</span>
  <span class="s2">&quot;dnums&quot;</span><span class="p">,</span>

  <span class="c1"># Slice dimensions that have negative strides, and so must be reversed after</span>
  <span class="c1"># the gather.</span>
  <span class="s2">&quot;reversed_y_dims&quot;</span><span class="p">,</span>

  <span class="c1"># Keep track of any axes created by `newaxis`. These must be inserted for</span>
  <span class="c1"># gathers and eliminated for scatters.</span>
  <span class="s2">&quot;newaxis_dims&quot;</span><span class="p">,</span>
<span class="p">])</span>

<span class="k">def</span> <span class="nf">_split_index_for_jit</span><span class="p">(</span><span class="n">idx</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Splits indices into necessarily-static and dynamic parts.</span>

<span class="sd">  Used to pass indices into `jit`-ted function.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="c1"># Convert list indices to tuples in cases (deprecated by NumPy.)</span>
  <span class="n">idx</span> <span class="o">=</span> <span class="n">_eliminate_deprecated_list_indexing</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>

  <span class="c1"># Expand any (concrete) boolean indices. We can then use advanced integer</span>
  <span class="c1"># indexing logic to handle them.</span>
  <span class="n">idx</span> <span class="o">=</span> <span class="n">_expand_bool_indices</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>

  <span class="n">leaves</span><span class="p">,</span> <span class="n">treedef</span> <span class="o">=</span> <span class="n">tree_flatten</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
  <span class="n">dynamic</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">leaves</span><span class="p">)</span>
  <span class="n">static</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">leaves</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">leaves</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="bp">Ellipsis</span><span class="p">:</span>
      <span class="n">static</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
      <span class="c1"># slice objects aren&#39;t hashable.</span>
      <span class="n">static</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">step</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">dynamic</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>
  <span class="k">return</span> <span class="n">treedef</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">static</span><span class="p">),</span> <span class="n">dynamic</span>

<span class="k">def</span> <span class="nf">_merge_static_and_dynamic_indices</span><span class="p">(</span><span class="n">treedef</span><span class="p">,</span> <span class="n">static_idx</span><span class="p">,</span> <span class="n">dynamic_idx</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Recombines indices that were split by _split_index_for_jit.&quot;&quot;&quot;</span>
  <span class="n">idx</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">static_idx</span><span class="p">,</span> <span class="n">dynamic_idx</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">d</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
      <span class="n">idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
      <span class="n">idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">treedef</span><span class="o">.</span><span class="n">unflatten</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_int</span><span class="p">(</span><span class="n">aval</span><span class="p">):</span>
  <span class="k">return</span> <span class="ow">not</span> <span class="n">aval</span><span class="o">.</span><span class="n">shape</span> <span class="ow">and</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">aval</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">integer</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_index_to_gather</span><span class="p">(</span><span class="n">x_shape</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">normalize_indices</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
  <span class="c1"># Remove ellipses and add trailing slice(None)s.</span>
  <span class="n">idx</span> <span class="o">=</span> <span class="n">_canonicalize_tuple_index</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x_shape</span><span class="p">),</span> <span class="n">idx</span><span class="p">)</span>

  <span class="c1"># Check for advanced indexing:</span>
  <span class="c1"># https://docs.scipy.org/doc/numpy/reference/arrays.indexing.html#advanced-indexing</span>

  <span class="c1"># Do the advanced indexing axes appear contiguously? If not, NumPy semantics</span>
  <span class="c1"># move the advanced axes to the front.</span>
  <span class="n">advanced_axes_are_contiguous</span> <span class="o">=</span> <span class="kc">False</span>

  <span class="n">advanced_indexes</span> <span class="o">=</span> <span class="kc">None</span>

  <span class="c1"># The positions of the advanced indexing axes in `idx`.</span>
  <span class="n">idx_advanced_axes</span> <span class="o">=</span> <span class="p">[]</span>

  <span class="c1"># The positions of the advanced indexes in x&#39;s shape.</span>
  <span class="c1"># collapsed, after None axes have been removed. See below.</span>
  <span class="n">x_advanced_axes</span> <span class="o">=</span> <span class="kc">None</span>

  <span class="k">if</span> <span class="n">_is_advanced_int_indexer</span><span class="p">(</span><span class="n">idx</span><span class="p">):</span>
    <span class="n">idx_no_nones</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="k">if</span> <span class="n">d</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>
    <span class="n">advanced_pairs</span> <span class="o">=</span> <span class="p">(</span>
      <span class="p">(</span><span class="n">asarray</span><span class="p">(</span><span class="n">e</span><span class="p">),</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">idx_no_nones</span><span class="p">)</span>
      <span class="k">if</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="p">(</span><span class="n">Sequence</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">)))</span>
    <span class="k">if</span> <span class="n">normalize_indices</span><span class="p">:</span>
      <span class="n">advanced_pairs</span> <span class="o">=</span> <span class="p">((</span><span class="n">_normalize_index</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">x_shape</span><span class="p">[</span><span class="n">j</span><span class="p">]),</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">e</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">advanced_pairs</span><span class="p">)</span>
    <span class="n">advanced_indexes</span><span class="p">,</span> <span class="n">idx_advanced_axes</span><span class="p">,</span> <span class="n">x_advanced_axes</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">advanced_pairs</span><span class="p">)</span>
    <span class="n">advanced_axes_are_contiguous</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">idx_advanced_axes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>

  <span class="n">x_axis</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Current axis in x.</span>
  <span class="n">y_axis</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Current axis in y, before collapsing. See below.</span>
  <span class="n">collapsed_y_axis</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Current axis in y, after collapsing.</span>

  <span class="c1"># Scatter dimension numbers.</span>
  <span class="n">offset_dims</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="n">collapsed_slice_dims</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="n">start_index_map</span> <span class="o">=</span> <span class="p">[]</span>

  <span class="n">use_64bit_index</span> <span class="o">=</span> <span class="n">_any</span><span class="p">([</span><span class="nb">type</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="ow">is</span> <span class="n">Poly</span> <span class="ow">or</span> <span class="n">d</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">31</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">x_shape</span><span class="p">])</span>
  <span class="n">index_dtype</span> <span class="o">=</span> <span class="n">int64</span> <span class="k">if</span> <span class="n">use_64bit_index</span> <span class="k">else</span> <span class="n">int32</span>
  <span class="n">gather_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">0</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">index_dtype</span><span class="p">)</span>  <span class="c1"># use np to save a compilation</span>

  <span class="c1"># We perform three transformations to y before the scatter op, in order:</span>
  <span class="c1"># First, y is broadcast to slice_shape. In general `y` only need broadcast to</span>
  <span class="c1"># the right shape.</span>
  <span class="n">slice_shape</span> <span class="o">=</span> <span class="p">[]</span>

  <span class="c1"># Next, y is squeezed to remove newaxis_dims. This removes np.newaxis/`None`</span>
  <span class="c1"># indices, which the scatter cannot remove itself.</span>
  <span class="n">newaxis_dims</span> <span class="o">=</span> <span class="p">[]</span>

  <span class="c1"># Finally, we reverse reversed_y_dims to handle slices with negative strides.</span>
  <span class="n">reversed_y_dims</span> <span class="o">=</span> <span class="p">[]</span>

  <span class="n">gather_slice_shape</span> <span class="o">=</span> <span class="p">[]</span>

  <span class="k">for</span> <span class="n">idx_pos</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">idx</span><span class="p">):</span>
    <span class="c1"># Handle the advanced indices here if:</span>
    <span class="c1"># * the advanced indices were not contiguous and we are the start.</span>
    <span class="c1"># * we are at the position of the first advanced index.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">advanced_indexes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>
        <span class="p">(</span><span class="n">advanced_axes_are_contiguous</span> <span class="ow">and</span> <span class="n">idx_pos</span> <span class="o">==</span> <span class="n">idx_advanced_axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span>
         <span class="ow">not</span> <span class="n">advanced_axes_are_contiguous</span> <span class="ow">and</span> <span class="n">idx_pos</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)):</span>
      <span class="n">advanced_indexes</span> <span class="o">=</span> <span class="n">broadcast_arrays</span><span class="p">(</span><span class="o">*</span><span class="n">advanced_indexes</span><span class="p">)</span>
      <span class="n">shape</span> <span class="o">=</span> <span class="n">advanced_indexes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
      <span class="n">ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
      <span class="n">advanced_indexes</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">lax</span><span class="o">.</span><span class="n">convert_element_type</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">shape</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)),</span> <span class="n">index_dtype</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">advanced_indexes</span><span class="p">]</span>

      <span class="c1"># Broadcast gather_indices from [..., k] to [..., 1, 1, ..., 1, k].</span>
      <span class="n">gather_indices</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">broadcast_in_dim</span><span class="p">(</span>
        <span class="n">gather_indices</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">gather_indices</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">shape</span><span class="p">),</span>
        <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">gather_indices</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="p">(</span><span class="n">gather_indices</span><span class="o">.</span><span class="n">ndim</span> <span class="o">+</span> <span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,))</span>
      <span class="n">gather_indices</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">([</span><span class="n">gather_indices</span><span class="p">]</span> <span class="o">+</span> <span class="n">advanced_indexes</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
      <span class="n">start_index_map</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">x_advanced_axes</span><span class="p">)</span>
      <span class="n">collapsed_slice_dims</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">x_advanced_axes</span><span class="p">)</span>
      <span class="n">slice_shape</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
      <span class="n">y_axis</span> <span class="o">+=</span> <span class="n">ndim</span>
      <span class="n">collapsed_y_axis</span> <span class="o">+=</span> <span class="n">ndim</span>

    <span class="c1"># Per-index bookkeeping for advanced indexes.</span>
    <span class="k">if</span> <span class="n">idx_pos</span> <span class="ow">in</span> <span class="n">idx_advanced_axes</span><span class="p">:</span>
      <span class="n">x_axis</span> <span class="o">+=</span> <span class="mi">1</span>
      <span class="n">gather_slice_shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
      <span class="k">continue</span>

    <span class="k">try</span><span class="p">:</span>
      <span class="n">abstract_i</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">get_aval</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
      <span class="n">abstract_i</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="c1"># Handle basic int indexes.</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">abstract_i</span><span class="p">,</span> <span class="p">(</span><span class="n">ConcreteArray</span><span class="p">,</span><span class="n">ShapedArray</span><span class="p">))</span> <span class="ow">and</span> <span class="n">_int</span><span class="p">(</span><span class="n">abstract_i</span><span class="p">):</span>
      <span class="k">if</span> <span class="n">x_shape</span><span class="p">[</span><span class="n">x_axis</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># XLA gives error when indexing into an axis of size 0</span>
        <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;index is out of bounds for axis </span><span class="si">{</span><span class="n">x_axis</span><span class="si">}</span><span class="s2"> with size 0&quot;</span><span class="p">)</span>
      <span class="n">i</span> <span class="o">=</span> <span class="n">_normalize_index</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x_shape</span><span class="p">[</span><span class="n">x_axis</span><span class="p">])</span> <span class="k">if</span> <span class="n">normalize_indices</span> <span class="k">else</span> <span class="n">i</span>
      <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="ow">is</span> <span class="n">Poly</span><span class="p">:</span>
        <span class="c1"># dummy index if i is polynomial, doesn&#39;t matter for shape inference</span>
        <span class="c1"># TODO(mattjj,j-towns,juliuskunze): revise this logic</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
      <span class="n">i</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">convert_element_type</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">index_dtype</span><span class="p">)</span>
      <span class="n">i</span> <span class="o">=</span> <span class="n">broadcast_to</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">gather_indices</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="p">,))</span>
      <span class="n">gather_indices</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">((</span><span class="n">gather_indices</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
      <span class="n">collapsed_slice_dims</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x_axis</span><span class="p">)</span>
      <span class="n">gather_slice_shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
      <span class="n">start_index_map</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x_axis</span><span class="p">)</span>
      <span class="n">x_axis</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="c1"># Handle np.newaxis (None)</span>
    <span class="k">elif</span> <span class="n">i</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
      <span class="n">slice_shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
      <span class="n">newaxis_dims</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y_axis</span><span class="p">)</span>
      <span class="n">y_axis</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="c1"># Handle slice(None)</span>
    <span class="k">elif</span> <span class="n">_is_slice_none</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
      <span class="n">slice_shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x_shape</span><span class="p">[</span><span class="n">x_axis</span><span class="p">])</span>
      <span class="n">gather_slice_shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x_shape</span><span class="p">[</span><span class="n">x_axis</span><span class="p">])</span>
      <span class="n">offset_dims</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">collapsed_y_axis</span><span class="p">)</span>
      <span class="n">collapsed_y_axis</span> <span class="o">+=</span> <span class="mi">1</span>
      <span class="n">y_axis</span> <span class="o">+=</span> <span class="mi">1</span>
      <span class="n">x_axis</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="c1"># Handle slice index (only static, otherwise an error is raised)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
      <span class="k">if</span> <span class="ow">not</span> <span class="n">_all</span><span class="p">(</span><span class="n">elt</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">elt</span><span class="p">)</span> <span class="ow">is</span> <span class="n">Poly</span>
                  <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">get_aval</span><span class="p">(</span><span class="n">elt</span><span class="p">))</span> <span class="ow">is</span> <span class="n">ConcreteArray</span>
                  <span class="k">for</span> <span class="n">elt</span> <span class="ow">in</span> <span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">i</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="n">i</span><span class="o">.</span><span class="n">step</span><span class="p">)):</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Array slice indices must have static start/stop/step to be used &quot;</span>
               <span class="s2">&quot;with NumPy indexing syntax. To index a statically sized &quot;</span>
               <span class="s2">&quot;array at a dynamic position, try lax.dynamic_slice/&quot;</span>
               <span class="s2">&quot;dynamic_update_slice (JAX does not support dynamically sized &quot;</span>
               <span class="s2">&quot;arrays within JIT compiled functions).&quot;</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
      <span class="n">start</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">needs_rev</span> <span class="o">=</span> <span class="n">_static_idx</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x_shape</span><span class="p">[</span><span class="n">x_axis</span><span class="p">])</span>
      <span class="k">if</span> <span class="n">needs_rev</span><span class="p">:</span>
        <span class="n">reversed_y_dims</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">collapsed_y_axis</span><span class="p">)</span>
      <span class="k">if</span> <span class="n">stride</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">convert_element_type</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">index_dtype</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">broadcast_to</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">gather_indices</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="p">,))</span>
        <span class="n">gather_indices</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">((</span><span class="n">gather_indices</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">slice_shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">limit</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span>
        <span class="n">gather_slice_shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">limit</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span>
        <span class="n">offset_dims</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">collapsed_y_axis</span><span class="p">)</span>
        <span class="n">start_index_map</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x_axis</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">arange</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">index_dtype</span><span class="p">)</span>
        <span class="n">size</span> <span class="o">=</span> <span class="n">i</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">slice_shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
        <span class="n">gather_slice_shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">gather_indices_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">gather_indices</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="p">(</span><span class="n">size</span><span class="p">,)</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">broadcast_in_dim</span><span class="p">(</span>
            <span class="n">i</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">gather_indices_shape</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="p">,),</span>
            <span class="n">broadcast_dimensions</span><span class="o">=</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">gather_indices_shape</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,))</span>
        <span class="n">gather_indices</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">broadcast_in_dim</span><span class="p">(</span>
            <span class="n">gather_indices</span><span class="p">,</span>
            <span class="n">shape</span><span class="o">=</span><span class="n">gather_indices_shape</span> <span class="o">+</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">start_index_map</span><span class="p">),),</span>
            <span class="n">broadcast_dimensions</span><span class="o">=</span><span class="p">(</span>
              <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">gather_indices_shape</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span>
              <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">gather_indices_shape</span><span class="p">),)))</span>
        <span class="n">gather_indices</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">(</span>
          <span class="p">(</span><span class="n">gather_indices</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">gather_indices_shape</span><span class="p">))</span>
        <span class="n">start_index_map</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x_axis</span><span class="p">)</span>
        <span class="n">collapsed_slice_dims</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x_axis</span><span class="p">)</span>

      <span class="n">collapsed_y_axis</span> <span class="o">+=</span> <span class="mi">1</span>
      <span class="n">y_axis</span> <span class="o">+=</span> <span class="mi">1</span>
      <span class="n">x_axis</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">abstract_i</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>
          <span class="ow">not</span> <span class="p">(</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">abstract_i</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">integer</span><span class="p">)</span> <span class="ow">or</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">abstract_i</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">bool_</span><span class="p">))):</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Indexer must have integer or boolean type, got indexer &quot;</span>
               <span class="s2">&quot;with type </span><span class="si">{}</span><span class="s2"> at position </span><span class="si">{}</span><span class="s2">, indexer value </span><span class="si">{}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">abstract_i</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">idx_pos</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>

      <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Indexing mode not yet supported. Open a feature request!</span><span class="se">\n</span><span class="si">{}</span><span class="s2">&quot;</span>
      <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span>

  <span class="n">dnums</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">GatherDimensionNumbers</span><span class="p">(</span>
    <span class="n">offset_dims</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">offset_dims</span><span class="p">),</span>
    <span class="n">collapsed_slice_dims</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">collapsed_slice_dims</span><span class="p">)),</span>
    <span class="n">start_index_map</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">start_index_map</span><span class="p">)</span>
  <span class="p">)</span>
  <span class="k">return</span> <span class="n">_Indexer</span><span class="p">(</span>
    <span class="n">slice_shape</span><span class="o">=</span><span class="n">slice_shape</span><span class="p">,</span>
    <span class="n">newaxis_dims</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">newaxis_dims</span><span class="p">),</span>
    <span class="n">gather_slice_shape</span><span class="o">=</span><span class="n">gather_slice_shape</span><span class="p">,</span>
    <span class="n">reversed_y_dims</span><span class="o">=</span><span class="n">reversed_y_dims</span><span class="p">,</span>
    <span class="n">dnums</span><span class="o">=</span><span class="n">dnums</span><span class="p">,</span>
    <span class="n">gather_indices</span><span class="o">=</span><span class="n">gather_indices</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_should_unpack_list_index</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Helper for _eliminate_deprecated_list_indexing.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span>
          <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">Sequence</span><span class="p">,</span> <span class="nb">slice</span><span class="p">))</span>
          <span class="ow">or</span> <span class="n">x</span> <span class="ow">is</span> <span class="bp">Ellipsis</span> <span class="ow">or</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_eliminate_deprecated_list_indexing</span><span class="p">(</span><span class="n">idx</span><span class="p">):</span>
  <span class="c1"># &quot;Basic slicing is initiated if the selection object is a non-array,</span>
  <span class="c1"># non-tuple sequence containing slice objects, [Ellipses, or newaxis</span>
  <span class="c1"># objects]&quot;. Detects this and raises a TypeError.</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">):</span>
      <span class="c1"># As of numpy 1.16, some non-tuple sequences of indices result in a warning, while</span>
      <span class="c1"># others are converted to arrays, based on a set of somewhat convoluted heuristics</span>
      <span class="c1"># (See https://github.com/numpy/numpy/blob/v1.19.2/numpy/core/src/multiarray/mapping.c#L179-L343)</span>
      <span class="c1"># In JAX, we raise an informative TypeError for *all* non-tuple sequences.</span>
      <span class="k">if</span> <span class="n">_any</span><span class="p">(</span><span class="n">_should_unpack_list_index</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">idx</span><span class="p">):</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Using a non-tuple sequence for multidimensional indexing is not allowed; &quot;</span>
               <span class="s2">&quot;use `arr[tuple(seq)]` instead of `arr[seq]`. &quot;</span>
               <span class="s2">&quot;See https://github.com/google/jax/issues/4564 for more information.&quot;</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Using a non-tuple sequence for multidimensional indexing is not allowed; &quot;</span>
               <span class="s2">&quot;use `arr[array(seq)]` instead of `arr[seq]`. &quot;</span>
               <span class="s2">&quot;See https://github.com/google/jax/issues/4564 for more information.&quot;</span><span class="p">)</span>
      <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">idx</span><span class="p">,)</span>
  <span class="k">return</span> <span class="n">idx</span>

<span class="k">def</span> <span class="nf">_expand_bool_indices</span><span class="p">(</span><span class="n">idx</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Converts concrete bool indexes into advanced integer indexes.&quot;&quot;&quot;</span>
  <span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">idx</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
      <span class="n">abstract_i</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">get_aval</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
      <span class="n">abstract_i</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">abstract_i</span><span class="p">,</span> <span class="n">ShapedArray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">abstract_i</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">bool_</span><span class="p">)</span>
          <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="n">_all</span><span class="p">(</span><span class="ow">not</span> <span class="n">_shape</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="ow">and</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">_dtype</span><span class="p">(</span><span class="n">e</span><span class="p">),</span> <span class="n">bool_</span><span class="p">)</span>
                                          <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">i</span><span class="p">)):</span>
      <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">abstract_i</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">get_aval</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

      <span class="k">if</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="n">abstract_i</span><span class="p">)</span> <span class="ow">is</span> <span class="n">ConcreteArray</span><span class="p">:</span>
        <span class="c1"># TODO(mattjj): improve this error by tracking _why_ the indices are not</span>
        <span class="c1"># concrete</span>
        <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;Array boolean indices must be concrete.&quot;</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">out</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
  <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_is_slice_none</span><span class="p">(</span><span class="n">idx</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Return True if idx is equal to slice(None), False otherwise.&quot;&quot;&quot;</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">idx</span><span class="o">.</span><span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">idx</span><span class="o">.</span><span class="n">stop</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">idx</span><span class="o">.</span><span class="n">step</span> <span class="ow">is</span> <span class="kc">None</span>

<span class="c1"># TODO(mattjj): clean up this logic</span>
<span class="k">def</span> <span class="nf">_is_advanced_int_indexer</span><span class="p">(</span><span class="n">idx</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Returns True if idx should trigger int array indexing, False otherwise.&quot;&quot;&quot;</span>
  <span class="c1"># https://docs.scipy.org/doc/numpy/reference/arrays.indexing.html#advanced-indexing</span>
  <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">_all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">elt</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">elt</span> <span class="ow">in</span> <span class="n">idx</span><span class="p">):</span>
    <span class="k">return</span> <span class="kc">False</span>
  <span class="k">return</span> <span class="n">_all</span><span class="p">(</span><span class="n">e</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">e</span> <span class="ow">is</span> <span class="bp">Ellipsis</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="nb">slice</span><span class="p">)</span>
              <span class="ow">or</span> <span class="n">_is_int_arraylike</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">idx</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_is_int_arraylike</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Returns True if x is array-like with integer dtype, False otherwise.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span>
          <span class="ow">or</span> <span class="n">issubdtype</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s2">&quot;dtype&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)</span>
          <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="ow">and</span> <span class="n">_all</span><span class="p">(</span><span class="n">_is_int_arraylike</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">x</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_canonicalize_tuple_index</span><span class="p">(</span><span class="n">arr_ndim</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Helper to remove Ellipsis and add in the implicit trailing slice(None).&quot;&quot;&quot;</span>
  <span class="n">len_without_none</span> <span class="o">=</span> <span class="n">_sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">idx</span> <span class="k">if</span> <span class="n">e</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">e</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">Ellipsis</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">len_without_none</span> <span class="o">&gt;</span> <span class="n">arr_ndim</span><span class="p">:</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Too many indices for array: </span><span class="si">{}</span><span class="s2"> non-None/Ellipsis indices for dim </span><span class="si">{}</span><span class="s2">.&quot;</span>
    <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">len_without_none</span><span class="p">,</span> <span class="n">arr_ndim</span><span class="p">))</span>
  <span class="n">ellipses</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">elt</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="k">if</span> <span class="n">elt</span> <span class="ow">is</span> <span class="bp">Ellipsis</span><span class="p">)</span>
  <span class="n">ellipsis_index</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">ellipses</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">ellipsis_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">next</span><span class="p">(</span><span class="n">ellipses</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
      <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Multiple ellipses (...) not supported: </span><span class="si">{}</span><span class="s2">.&quot;</span>
      <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="n">idx</span><span class="p">))))</span>
    <span class="n">colons</span> <span class="o">=</span> <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),)</span> <span class="o">*</span> <span class="p">(</span><span class="n">arr_ndim</span> <span class="o">-</span> <span class="n">len_without_none</span><span class="p">)</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[:</span><span class="n">ellipsis_index</span><span class="p">]</span> <span class="o">+</span> <span class="n">colons</span> <span class="o">+</span> <span class="n">idx</span><span class="p">[</span><span class="n">ellipsis_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span>
  <span class="k">elif</span> <span class="n">len_without_none</span> <span class="o">&lt;</span> <span class="n">arr_ndim</span><span class="p">:</span>
    <span class="n">colons</span> <span class="o">=</span> <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),)</span> <span class="o">*</span> <span class="p">(</span><span class="n">arr_ndim</span> <span class="o">-</span> <span class="n">len_without_none</span><span class="p">)</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">+</span> <span class="n">colons</span>
  <span class="k">return</span> <span class="n">idx</span>

<span class="k">def</span> <span class="nf">_polymorphic_slice_indices</span><span class="p">(</span><span class="n">idx</span><span class="p">:</span> <span class="nb">slice</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Poly</span><span class="p">]):</span>
  <span class="c1"># like idx.indices(size), but allows for polymorphic indices and size</span>
  <span class="c1"># see https://github.com/python/cpython/blob/6d6508765514c7c10719478a0430f5e47c9a96ac/Objects/sliceobject.c#L372</span>
  <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="nb">slice</span><span class="p">)</span>

  <span class="n">step</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">idx</span><span class="o">.</span><span class="n">step</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">idx</span><span class="o">.</span><span class="n">step</span>
  <span class="n">step_is_negative</span> <span class="o">=</span> <span class="n">step</span> <span class="o">&lt;</span> <span class="mi">0</span>
  <span class="n">lower</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">step_is_negative</span> <span class="k">else</span> <span class="mi">0</span>
  <span class="n">upper</span> <span class="o">=</span> <span class="n">size</span> <span class="o">+</span> <span class="n">lower</span>

  <span class="k">def</span> <span class="nf">sanitize</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">default</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">default</span>
    <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="ow">is</span> <span class="n">Poly</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">index</span>
    <span class="k">elif</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">_max</span><span class="p">(</span><span class="n">index</span> <span class="o">+</span> <span class="n">size</span><span class="p">,</span> <span class="n">lower</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">_min</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">upper</span><span class="p">)</span>

  <span class="n">start</span> <span class="o">=</span> <span class="n">sanitize</span><span class="p">(</span><span class="n">idx</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">upper</span> <span class="k">if</span> <span class="n">step_is_negative</span> <span class="k">else</span> <span class="n">lower</span><span class="p">)</span>
  <span class="n">stop</span> <span class="o">=</span> <span class="n">sanitize</span><span class="p">(</span><span class="n">idx</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">lower</span> <span class="k">if</span> <span class="n">step_is_negative</span> <span class="k">else</span> <span class="n">upper</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span>

<span class="k">def</span> <span class="nf">_static_idx</span><span class="p">(</span><span class="n">idx</span><span class="p">:</span> <span class="nb">slice</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Poly</span><span class="p">]):</span>
  <span class="sd">&quot;&quot;&quot;Helper function to compute the static slice start/limit/stride values.&quot;&quot;&quot;</span>
  <span class="k">if</span> <span class="n">_any</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="ow">is</span> <span class="n">Poly</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="p">(</span><span class="n">idx</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">idx</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="n">idx</span><span class="o">.</span><span class="n">step</span><span class="p">,</span> <span class="n">size</span><span class="p">)):</span>
    <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span> <span class="o">=</span> <span class="n">_polymorphic_slice_indices</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
  <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
    <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span> <span class="o">=</span> <span class="n">idx</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>

  <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">start</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">Poly</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">stop</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">Poly</span><span class="p">:</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">step</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">stop</span> <span class="o">&gt;=</span> <span class="n">start</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">step</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">start</span> <span class="o">&gt;=</span> <span class="n">stop</span><span class="p">):</span>
      <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="kc">False</span>  <span class="c1"># sliced to size zero</span>

  <span class="k">if</span> <span class="n">step</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="kc">False</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">k</span>  <span class="o">=</span> <span class="p">(</span><span class="n">start</span> <span class="o">-</span> <span class="n">stop</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="o">-</span><span class="n">step</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">stop</span> <span class="o">+</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="n">step</span><span class="p">,</span> <span class="kc">True</span>


<span class="n">blackman</span> <span class="o">=</span> <span class="n">_wrap_numpy_nullary_function</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">blackman</span><span class="p">)</span>
<span class="n">bartlett</span> <span class="o">=</span> <span class="n">_wrap_numpy_nullary_function</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">bartlett</span><span class="p">)</span>
<span class="n">hamming</span> <span class="o">=</span> <span class="n">_wrap_numpy_nullary_function</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hamming</span><span class="p">)</span>
<span class="n">hanning</span> <span class="o">=</span> <span class="n">_wrap_numpy_nullary_function</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hanning</span><span class="p">)</span>
<span class="c1"># TODO: lower `kaiser` via lax to allow non-constant beta values.</span>
<span class="n">kaiser</span> <span class="o">=</span> <span class="n">_wrap_numpy_nullary_function</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">kaiser</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_gcd_cond_fn</span><span class="p">(</span><span class="n">xs</span><span class="p">):</span>
  <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">xs</span>
  <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="n">x2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_gcd_body_fn</span><span class="p">(</span><span class="n">xs</span><span class="p">):</span>
  <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">xs</span>
  <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span> <span class="o">=</span> <span class="p">(</span><span class="n">where</span><span class="p">(</span><span class="n">x2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">x1</span><span class="p">),</span>
            <span class="n">where</span><span class="p">(</span><span class="n">x2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">rem</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">),</span> <span class="n">lax</span><span class="o">.</span><span class="n">_const</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">where</span><span class="p">(</span><span class="n">x1</span> <span class="o">&lt;</span> <span class="n">x2</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">x1</span><span class="p">),</span> <span class="n">where</span><span class="p">(</span><span class="n">x1</span> <span class="o">&lt;</span> <span class="n">x2</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">))</span>

<span class="nd">@_wraps</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s2">&quot;gcd&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">gcd</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;gcd&quot;</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span>
  <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">_dtype</span><span class="p">(</span><span class="n">x1</span><span class="p">),</span> <span class="n">integer</span><span class="p">)</span> <span class="ow">or</span>
      <span class="ow">not</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">_dtype</span><span class="p">(</span><span class="n">x2</span><span class="p">),</span> <span class="n">integer</span><span class="p">)):</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Arguments to jax.numpy.gcd must be integers.&quot;</span><span class="p">)</span>
  <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">_promote_dtypes</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span>
  <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">broadcast_arrays</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span>
  <span class="n">gcd</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">while_loop</span><span class="p">(</span><span class="n">_gcd_cond_fn</span><span class="p">,</span> <span class="n">_gcd_body_fn</span><span class="p">,</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">x1</span><span class="p">),</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x2</span><span class="p">)))</span>
  <span class="k">return</span> <span class="n">gcd</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s2">&quot;lcm&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">lcm</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;lcm&quot;</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span>
  <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">_promote_dtypes</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span>
  <span class="n">d</span> <span class="o">=</span> <span class="n">gcd</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">where</span><span class="p">(</span><span class="n">d</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">_const</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
               <span class="nb">abs</span><span class="p">(</span><span class="n">multiply</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">floor_divide</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">d</span><span class="p">))))</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">extract</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">extract</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="n">arr</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">compress</span><span class="p">(</span><span class="n">ravel</span><span class="p">(</span><span class="n">condition</span><span class="p">),</span> <span class="n">ravel</span><span class="p">(</span><span class="n">arr</span><span class="p">))</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">compress</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">compress</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;The &#39;out&#39; argument to jnp.compress is not supported.&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">ndim</span><span class="p">(</span><span class="n">condition</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;condition must be a 1D array&quot;</span><span class="p">)</span>
  <span class="n">condition</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">condition</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">ravel</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">moveaxis</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
  <span class="n">condition</span><span class="p">,</span> <span class="n">extra</span> <span class="o">=</span> <span class="n">condition</span><span class="p">[:</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">condition</span><span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:]</span>
  <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">extra</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;condition contains entries that are out of bounds&quot;</span><span class="p">)</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="p">[:</span><span class="n">condition</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
  <span class="k">return</span> <span class="n">moveaxis</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">condition</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">cov</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rowvar</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fweights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">aweights</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
    <span class="s2">&quot;jax.numpy.cov not implemented for nontrivial y. &quot;</span>
    <span class="s2">&quot;Open a feature request at https://github.com/google/jax/issues !&quot;</span><span class="p">)</span>

  <span class="n">m</span><span class="p">,</span> <span class="o">=</span> <span class="n">_promote_args_inexact</span><span class="p">(</span><span class="s2">&quot;cov&quot;</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;m has more than 2 dimensions&quot;</span><span class="p">)</span>  <span class="c1"># same as numpy error</span>
  <span class="n">X</span> <span class="o">=</span> <span class="n">atleast_2d</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">rowvar</span> <span class="ow">and</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span>
  <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">array</span><span class="p">([])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">ddof</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">ddof</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">bias</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>

  <span class="n">w</span> <span class="o">=</span> <span class="kc">None</span>
  <span class="k">if</span> <span class="n">fweights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;cov&quot;</span><span class="p">,</span> <span class="n">fweights</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ndim</span><span class="p">(</span><span class="n">fweights</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;cannot handle multidimensional fweights&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">shape</span><span class="p">(</span><span class="n">fweights</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
      <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;incompatible numbers of samples and fweights&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">_dtype</span><span class="p">(</span><span class="n">fweights</span><span class="p">),</span> <span class="n">integer</span><span class="p">):</span>
      <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;fweights must be integer.&quot;</span><span class="p">)</span>
    <span class="c1"># Ensure positive fweights; note that numpy raises an error on negative fweights.</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">fweights</span><span class="p">))</span>
  <span class="k">if</span> <span class="n">aweights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;cov&quot;</span><span class="p">,</span> <span class="n">aweights</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ndim</span><span class="p">(</span><span class="n">aweights</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;cannot handle multidimensional aweights&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">shape</span><span class="p">(</span><span class="n">aweights</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
      <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;incompatible numbers of samples and aweights&quot;</span><span class="p">)</span>
    <span class="c1"># Ensure positive aweights: note that numpy raises an error for negative aweights.</span>
    <span class="n">aweights</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">aweights</span><span class="p">)</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">aweights</span> <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">w</span> <span class="o">*</span> <span class="n">aweights</span>

  <span class="n">avg</span><span class="p">,</span> <span class="n">w_sum</span> <span class="o">=</span> <span class="n">average</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">w</span><span class="p">,</span> <span class="n">returned</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
  <span class="n">w_sum</span> <span class="o">=</span> <span class="n">w_sum</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

  <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">ddof</span>
  <span class="k">elif</span> <span class="n">ddof</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">w_sum</span>
  <span class="k">elif</span> <span class="n">aweights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">w_sum</span> <span class="o">-</span> <span class="n">ddof</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">w_sum</span> <span class="o">-</span> <span class="n">ddof</span> <span class="o">*</span> <span class="nb">sum</span><span class="p">(</span><span class="n">w</span> <span class="o">*</span> <span class="n">aweights</span><span class="p">)</span> <span class="o">/</span> <span class="n">w_sum</span>

  <span class="n">X</span> <span class="o">=</span> <span class="n">X</span> <span class="o">-</span> <span class="n">avg</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>
  <span class="n">X_T</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span> <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">(</span><span class="n">X</span> <span class="o">*</span> <span class="n">w</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
  <span class="k">return</span> <span class="n">true_divide</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">X_T</span><span class="o">.</span><span class="n">conj</span><span class="p">()),</span> <span class="n">f</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">corrcoef</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rowvar</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;corrcoef&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
  <span class="n">c</span> <span class="o">=</span> <span class="n">cov</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">rowvar</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="c1"># scalar - this should yield nan for values (nan/nan, inf/inf, 0/0), 1 otherwise</span>
    <span class="k">return</span> <span class="n">divide</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
  <span class="n">d</span> <span class="o">=</span> <span class="n">diag</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
  <span class="n">stddev</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">real</span><span class="p">(</span><span class="n">d</span><span class="p">))</span>
  <span class="n">c</span> <span class="o">=</span> <span class="n">divide</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">stddev</span><span class="p">[:,</span><span class="kc">None</span><span class="p">])</span>
  <span class="n">c</span> <span class="o">=</span> <span class="n">divide</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">stddev</span><span class="p">[</span><span class="kc">None</span><span class="p">,:])</span>

  <span class="n">real_part</span> <span class="o">=</span> <span class="n">clip</span><span class="p">(</span><span class="n">real</span><span class="p">(</span><span class="n">c</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">iscomplexobj</span><span class="p">(</span><span class="n">c</span><span class="p">):</span>
    <span class="n">complex_part</span> <span class="o">=</span> <span class="n">clip</span><span class="p">(</span><span class="n">imag</span><span class="p">(</span><span class="n">c</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">complex</span><span class="p">(</span><span class="n">real_part</span><span class="p">,</span> <span class="n">complex_part</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">real_part</span>
  <span class="k">return</span> <span class="n">c</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s2">&quot;quantile&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">quantile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">overwrite_input</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;quantile&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">overwrite_input</span> <span class="ow">or</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;jax.numpy.quantile does not support overwrite_input=True or &quot;</span>
           <span class="s2">&quot;out != None&quot;</span><span class="p">)</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">_quantile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">interpolation</span><span class="p">,</span> <span class="n">keepdims</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

<span class="nd">@_wraps</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s2">&quot;nanquantile&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">nanquantile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">overwrite_input</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span>
                <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;nanquantile&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">overwrite_input</span> <span class="ow">or</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;jax.numpy.nanquantile does not support overwrite_input=True or &quot;</span>
           <span class="s2">&quot;out != None&quot;</span><span class="p">)</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">_quantile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">interpolation</span><span class="p">,</span> <span class="n">keepdims</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>


<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnums</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">_quantile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">interpolation</span><span class="p">,</span> <span class="n">keepdims</span><span class="p">,</span> <span class="n">squash_nans</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">interpolation</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span> <span class="s2">&quot;lower&quot;</span><span class="p">,</span> <span class="s2">&quot;higher&quot;</span><span class="p">,</span> <span class="s2">&quot;midpoint&quot;</span><span class="p">,</span> <span class="s2">&quot;nearest&quot;</span><span class="p">]:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;interpolation can only be &#39;linear&#39;, &#39;lower&#39;, &#39;higher&#39;, &quot;</span>
                     <span class="s2">&quot;&#39;midpoint&#39;, or &#39;nearest&#39;&quot;</span><span class="p">)</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">promote_types</span><span class="p">(</span><span class="n">_dtype</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">float32</span><span class="p">))</span>
  <span class="n">q</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">promote_types</span><span class="p">(</span><span class="n">_dtype</span><span class="p">(</span><span class="n">q</span><span class="p">),</span> <span class="n">float32</span><span class="p">))</span>
  <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">ravel</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Tuple values for axis are not implemented&quot;</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">axis</span> <span class="o">=</span> <span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>

  <span class="n">q_shape</span> <span class="o">=</span> <span class="n">shape</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
  <span class="n">q_ndim</span> <span class="o">=</span> <span class="n">ndim</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">q_ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;q must be have rank &lt;= 1, got shape </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">shape</span><span class="p">(</span><span class="n">q</span><span class="p">)))</span>

  <span class="n">a_shape</span> <span class="o">=</span> <span class="n">shape</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">squash_nans</span><span class="p">:</span>
    <span class="n">counts</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">logical_not</span><span class="p">(</span><span class="n">isnan</span><span class="p">(</span><span class="n">a</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">q</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
                 <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span>
    <span class="n">shape_after_reduction</span> <span class="o">=</span> <span class="n">counts</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span>
      <span class="n">q</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">q_ndim</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape_after_reduction</span><span class="p">)</span> <span class="o">+</span> <span class="n">q_ndim</span><span class="p">)))</span>
    <span class="n">counts</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">counts</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">q_ndim</span><span class="p">)))</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">counts</span><span class="p">,</span> <span class="n">_constant_like</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>
    <span class="n">low</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
    <span class="n">high</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
    <span class="n">high_weight</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">low</span><span class="p">)</span>
    <span class="n">low_weight</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">_constant_like</span><span class="p">(</span><span class="n">high_weight</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">high_weight</span><span class="p">)</span>

    <span class="n">low</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">_constant_like</span><span class="p">(</span><span class="n">low</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">lax</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">low</span><span class="p">,</span> <span class="n">counts</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">high</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">_constant_like</span><span class="p">(</span><span class="n">high</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">lax</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">high</span><span class="p">,</span> <span class="n">counts</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">low</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">convert_element_type</span><span class="p">(</span><span class="n">low</span><span class="p">,</span> <span class="n">int64</span><span class="p">)</span>
    <span class="n">high</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">convert_element_type</span><span class="p">(</span><span class="n">high</span><span class="p">,</span> <span class="n">int64</span><span class="p">)</span>
    <span class="n">out_shape</span> <span class="o">=</span> <span class="n">q_shape</span> <span class="o">+</span> <span class="n">shape_after_reduction</span>
    <span class="n">index</span> <span class="o">=</span> <span class="p">[</span><span class="n">lax</span><span class="o">.</span><span class="n">broadcasted_iota</span><span class="p">(</span><span class="n">int64</span><span class="p">,</span> <span class="n">out_shape</span><span class="p">,</span> <span class="n">dim</span> <span class="o">+</span> <span class="n">q_ndim</span><span class="p">)</span>
             <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">shape_after_reduction</span><span class="p">))]</span>
    <span class="k">if</span> <span class="n">keepdims</span><span class="p">:</span>
      <span class="n">index</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">low</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">index</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">low</span><span class="p">)</span>
    <span class="n">low_value</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">index</span><span class="p">)]</span>
    <span class="n">index</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">high</span>
    <span class="n">high_value</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">index</span><span class="p">)]</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">a_shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">_constant_like</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">low</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
    <span class="n">high</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
    <span class="n">high_weight</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">low</span><span class="p">)</span>
    <span class="n">low_weight</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">_constant_like</span><span class="p">(</span><span class="n">high_weight</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">high_weight</span><span class="p">)</span>

    <span class="n">low</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">clamp</span><span class="p">(</span><span class="n">_constant_like</span><span class="p">(</span><span class="n">low</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">low</span><span class="p">,</span> <span class="n">_constant_like</span><span class="p">(</span><span class="n">low</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">high</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">clamp</span><span class="p">(</span><span class="n">_constant_like</span><span class="p">(</span><span class="n">high</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">high</span><span class="p">,</span> <span class="n">_constant_like</span><span class="p">(</span><span class="n">high</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">low</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">convert_element_type</span><span class="p">(</span><span class="n">low</span><span class="p">,</span> <span class="n">int64</span><span class="p">)</span>
    <span class="n">high</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">convert_element_type</span><span class="p">(</span><span class="n">high</span><span class="p">,</span> <span class="n">int64</span><span class="p">)</span>

    <span class="n">slice_sizes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">a_shape</span><span class="p">)</span>
    <span class="n">slice_sizes</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">dnums</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">GatherDimensionNumbers</span><span class="p">(</span>
      <span class="n">offset_dims</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span>
        <span class="n">q_ndim</span><span class="p">,</span>
        <span class="nb">len</span><span class="p">(</span><span class="n">a_shape</span><span class="p">)</span> <span class="o">+</span> <span class="n">q_ndim</span> <span class="k">if</span> <span class="n">keepdims</span> <span class="k">else</span> <span class="nb">len</span><span class="p">(</span><span class="n">a_shape</span><span class="p">)</span> <span class="o">+</span> <span class="n">q_ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)),</span>
      <span class="n">collapsed_slice_dims</span><span class="o">=</span><span class="p">()</span> <span class="k">if</span> <span class="n">keepdims</span> <span class="k">else</span> <span class="p">(</span><span class="n">axis</span><span class="p">,),</span>
      <span class="n">start_index_map</span><span class="o">=</span><span class="p">(</span><span class="n">axis</span><span class="p">,))</span>
    <span class="n">low_value</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">low</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">dimension_numbers</span><span class="o">=</span><span class="n">dnums</span><span class="p">,</span>
                           <span class="n">slice_sizes</span><span class="o">=</span><span class="n">slice_sizes</span><span class="p">)</span>
    <span class="n">high_value</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">high</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">dimension_numbers</span><span class="o">=</span><span class="n">dnums</span><span class="p">,</span>
                            <span class="n">slice_sizes</span><span class="o">=</span><span class="n">slice_sizes</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">q_ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
      <span class="n">low_weight</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">broadcast_in_dim</span><span class="p">(</span><span class="n">low_weight</span><span class="p">,</span> <span class="n">low_value</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                                        <span class="n">broadcast_dimensions</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,))</span>
      <span class="n">high_weight</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">broadcast_in_dim</span><span class="p">(</span><span class="n">high_weight</span><span class="p">,</span> <span class="n">high_value</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                                        <span class="n">broadcast_dimensions</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,))</span>

  <span class="k">if</span> <span class="n">interpolation</span> <span class="o">==</span> <span class="s2">&quot;linear&quot;</span><span class="p">:</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">low_value</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span> <span class="n">low_weight</span><span class="p">),</span>
                     <span class="n">lax</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">high_value</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span> <span class="n">high_weight</span><span class="p">))</span>
  <span class="k">elif</span> <span class="n">interpolation</span> <span class="o">==</span> <span class="s2">&quot;lower&quot;</span><span class="p">:</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">low_value</span>
  <span class="k">elif</span> <span class="n">interpolation</span> <span class="o">==</span> <span class="s2">&quot;higher&quot;</span><span class="p">:</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">high_value</span>
  <span class="k">elif</span> <span class="n">interpolation</span> <span class="o">==</span> <span class="s2">&quot;nearest&quot;</span><span class="p">:</span>
    <span class="n">pred</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">le</span><span class="p">(</span><span class="n">high_weight</span><span class="p">,</span> <span class="n">_constant_like</span><span class="p">(</span><span class="n">high_weight</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">))</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">pred</span><span class="p">,</span> <span class="n">low_value</span><span class="p">,</span> <span class="n">high_value</span><span class="p">)</span>
  <span class="k">elif</span> <span class="n">interpolation</span> <span class="o">==</span> <span class="s2">&quot;midpoint&quot;</span><span class="p">:</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">low_value</span><span class="p">,</span> <span class="n">high_value</span><span class="p">),</span> <span class="n">_constant_like</span><span class="p">(</span><span class="n">low_value</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">))</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;interpolation=</span><span class="si">{</span><span class="n">interpolation</span><span class="si">!r}</span><span class="s2"> not recognized&quot;</span><span class="p">)</span>

  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">convert_element_type</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>


<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnums</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="nd">@partial</span><span class="p">(</span><span class="n">vectorize</span><span class="p">,</span> <span class="n">excluded</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">})</span>
<span class="k">def</span> <span class="nf">_searchsorted</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">side</span><span class="p">):</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">return</span> <span class="mi">0</span>
  <span class="n">op</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">le</span> <span class="k">if</span> <span class="n">side</span> <span class="o">==</span> <span class="s1">&#39;left&#39;</span> <span class="k">else</span> <span class="n">operator</span><span class="o">.</span><span class="n">lt</span>

  <span class="k">def</span> <span class="nf">body_fun</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
    <span class="n">low</span><span class="p">,</span> <span class="n">high</span> <span class="o">=</span> <span class="n">state</span>
    <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">low</span> <span class="o">+</span> <span class="n">high</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="n">go_left</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="n">mid</span><span class="p">])</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">where</span><span class="p">(</span><span class="n">go_left</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">mid</span><span class="p">),</span> <span class="n">where</span><span class="p">(</span><span class="n">go_left</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">high</span><span class="p">))</span>

  <span class="n">n_levels</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">fori_loop</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_levels</span><span class="p">,</span> <span class="n">body_fun</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)))[</span><span class="mi">1</span><span class="p">]</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">searchsorted</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="n">sorter</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">side</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="s1">&#39;right&#39;</span><span class="p">]:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">side</span><span class="si">!r}</span><span class="s2"> is an invalid value for keyword &#39;side&#39;&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">sorter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;sorter is not implemented&quot;</span><span class="p">)</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
  <span class="n">v</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;a should be 1-dimensional&quot;</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">_searchsorted</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">side</span><span class="p">)</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">digitize</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">zeros</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtypes</span><span class="o">.</span><span class="n">canonicalize_dtype</span><span class="p">(</span><span class="n">int_</span><span class="p">))</span>
  <span class="n">side</span> <span class="o">=</span> <span class="s1">&#39;right&#39;</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">right</span> <span class="k">else</span> <span class="s1">&#39;left&#39;</span>
  <span class="k">return</span> <span class="n">where</span><span class="p">(</span>
    <span class="n">bins</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">bins</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
    <span class="n">searchsorted</span><span class="p">(</span><span class="n">bins</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="n">side</span><span class="p">),</span>
    <span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span> <span class="o">-</span> <span class="n">searchsorted</span><span class="p">(</span><span class="n">bins</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="n">side</span><span class="p">)</span>
  <span class="p">)</span>

<span class="n">_PIECEWISE_DOC</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">Unlike `np.piecewise`, :py:func:`jax.numpy.piecewise` requires functions in</span>
<span class="s2">`funclist` to be traceable by JAX, as it is implemeted via :func:`jax.lax.switch`.</span>
<span class="s2">See the :func:`jax.lax.switch` documentation for more information.</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">piecewise</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_PIECEWISE_DOC</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">piecewise</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">condlist</span><span class="p">,</span> <span class="n">funclist</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;piecewise&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
  <span class="n">condlist</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">condlist</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">bool_</span><span class="p">)</span>
  <span class="n">nc</span><span class="p">,</span> <span class="n">nf</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">condlist</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">funclist</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">nf</span> <span class="o">==</span> <span class="n">nc</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">funclist</span> <span class="o">=</span> <span class="n">funclist</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">funclist</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
  <span class="k">elif</span> <span class="n">nf</span> <span class="o">==</span> <span class="n">nc</span><span class="p">:</span>
    <span class="n">funclist</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">funclist</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;with </span><span class="si">{</span><span class="n">nc</span><span class="si">}</span><span class="s2"> condition(s), either </span><span class="si">{</span><span class="n">nc</span><span class="si">}</span><span class="s2"> or </span><span class="si">{</span><span class="n">nc</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2"> functions are expected; got </span><span class="si">{</span><span class="n">nf</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
  <span class="n">indices</span> <span class="o">=</span> <span class="n">argmax</span><span class="p">(</span><span class="n">cumsum</span><span class="p">(</span><span class="n">vstack</span><span class="p">([</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">condlist</span><span class="p">[:</span><span class="mi">1</span><span class="p">]),</span> <span class="n">condlist</span><span class="p">]),</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
  <span class="n">dtype</span> <span class="o">=</span> <span class="n">_dtype</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="k">return</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
  <span class="k">def</span> <span class="nf">_const</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
    <span class="k">return</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">full_like</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
  <span class="n">funclist</span> <span class="o">=</span> <span class="p">[</span><span class="n">_call</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="k">else</span> <span class="n">_const</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">funclist</span><span class="p">]</span>
  <span class="k">return</span> <span class="n">vectorize</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">switch</span><span class="p">,</span> <span class="n">excluded</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,))(</span><span class="n">indices</span><span class="p">,</span> <span class="n">funclist</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>


<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">percentile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
               <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">overwrite_input</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span>
               <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;percentile&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="n">q</span> <span class="o">=</span> <span class="n">true_divide</span><span class="p">(</span><span class="n">asarray</span><span class="p">(</span><span class="n">q</span><span class="p">),</span> <span class="n">float32</span><span class="p">(</span><span class="mf">100.0</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">quantile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">overwrite_input</span><span class="o">=</span><span class="n">overwrite_input</span><span class="p">,</span>
                  <span class="n">interpolation</span><span class="o">=</span><span class="n">interpolation</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span>

<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanpercentile</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">nanpercentile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                  <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">overwrite_input</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span>
                  <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;nanpercentile&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="n">q</span> <span class="o">=</span> <span class="n">true_divide</span><span class="p">(</span><span class="n">asarray</span><span class="p">(</span><span class="n">q</span><span class="p">),</span> <span class="n">float32</span><span class="p">(</span><span class="mf">100.0</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">nanquantile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">overwrite_input</span><span class="o">=</span><span class="n">overwrite_input</span><span class="p">,</span>
                     <span class="n">interpolation</span><span class="o">=</span><span class="n">interpolation</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span>

<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">median</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
           <span class="n">overwrite_input</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;median&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">quantile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">overwrite_input</span><span class="o">=</span><span class="n">overwrite_input</span><span class="p">,</span>
                  <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;midpoint&#39;</span><span class="p">)</span>

<span class="nd">@_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">nanmedian</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
              <span class="n">overwrite_input</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
  <span class="n">_check_arraylike</span><span class="p">(</span><span class="s2">&quot;nanmedian&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">nanquantile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
                     <span class="n">overwrite_input</span><span class="o">=</span><span class="n">overwrite_input</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">,</span>
                     <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;midpoint&#39;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_astype</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
  <span class="n">lax</span><span class="o">.</span><span class="n">_check_user_dtype_supported</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="s2">&quot;astype&quot;</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">convert_element_type</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_nbytes</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">size</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">*</span> <span class="n">_dtype</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span><span class="o">.</span><span class="n">itemsize</span>


<span class="k">def</span> <span class="nf">_view</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="n">lax</span><span class="o">.</span><span class="n">_check_user_dtype_supported</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="s2">&quot;view&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;`type` argument of array.view()&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">arr</span>
  <span class="n">arr_dtype</span> <span class="o">=</span> <span class="n">_dtype</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">arr_dtype</span> <span class="o">==</span> <span class="n">dtype</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">arr</span>
  <span class="c1"># bool is implemented as lax:PRED, which is not compatible with lax.bitcast_convert_type.</span>
  <span class="c1"># We work around this by casting bool to uint8.</span>
  <span class="k">if</span> <span class="n">arr_dtype</span> <span class="o">==</span> <span class="n">bool_</span><span class="p">:</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">uint8</span><span class="p">)</span>
  <span class="n">nbits_in</span> <span class="o">=</span> <span class="mi">8</span> <span class="o">*</span> <span class="n">arr_dtype</span><span class="o">.</span><span class="n">itemsize</span>
  <span class="n">nbits_out</span> <span class="o">=</span> <span class="mi">8</span> <span class="o">*</span> <span class="n">_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">itemsize</span>
  <span class="k">if</span> <span class="n">nbits_in</span> <span class="o">==</span> <span class="n">nbits_out</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">dtype</span> <span class="o">==</span> <span class="n">bool_</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">bitcast_convert_type</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">uint8</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">bitcast_convert_type</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">nbits_out</span> <span class="o">&gt;</span> <span class="n">nbits_in</span> <span class="ow">and</span> <span class="p">(</span><span class="n">shape</span><span class="p">(</span><span class="n">arr</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">nbits_in</span><span class="p">)</span> <span class="o">%</span> <span class="n">nbits_out</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;When changing to a larger dtype, its size must be a divisor &quot;</span>
                     <span class="s2">&quot;of the total size in bytes of the last axis of the array.&quot;</span><span class="p">)</span>
  <span class="n">byte_dtypes</span> <span class="o">=</span> <span class="p">{</span><span class="mi">8</span><span class="p">:</span> <span class="n">uint8</span><span class="p">,</span> <span class="mi">16</span><span class="p">:</span> <span class="n">uint16</span><span class="p">,</span> <span class="mi">32</span><span class="p">:</span> <span class="n">uint32</span><span class="p">,</span> <span class="mi">64</span><span class="p">:</span> <span class="n">uint64</span><span class="p">}</span>
  <span class="k">if</span> <span class="n">nbits_in</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">byte_dtypes</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;arr.view() for arr.dtype=</span><span class="si">{</span><span class="n">arr_dtype</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">nbits_out</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">byte_dtypes</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;arr.view(dtype) for dtype=</span><span class="si">{</span><span class="n">dtype</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
  <span class="n">dt_in</span> <span class="o">=</span> <span class="n">byte_dtypes</span><span class="p">[</span><span class="n">nbits_in</span><span class="p">]</span>
  <span class="n">dt_out</span> <span class="o">=</span> <span class="n">byte_dtypes</span><span class="p">[</span><span class="n">nbits_out</span><span class="p">]</span>
  <span class="n">arr_bytes</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">bitcast_convert_type</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">dt_in</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">nbits_in</span> <span class="o">&lt;</span> <span class="n">nbits_out</span><span class="p">:</span>
    <span class="n">shifts</span> <span class="o">=</span> <span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nbits_out</span><span class="p">,</span> <span class="n">nbits_in</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dt_out</span><span class="p">)</span>
    <span class="n">arr_bytes</span> <span class="o">=</span> <span class="n">arr_bytes</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">nbits_out</span> <span class="o">//</span> <span class="n">nbits_in</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dt_out</span><span class="p">)</span>
    <span class="n">arr_bytes</span> <span class="o">=</span> <span class="p">(</span><span class="n">arr_bytes</span> <span class="o">&lt;&lt;</span> <span class="n">shifts</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dt_out</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">shifts</span> <span class="o">=</span> <span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nbits_in</span><span class="p">,</span> <span class="n">nbits_out</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dt_in</span><span class="p">)</span>
    <span class="n">arr_bytes</span> <span class="o">=</span> <span class="p">((</span><span class="n">arr_bytes</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">newaxis</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="n">shifts</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">iinfo</span><span class="p">(</span><span class="n">dt_out</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dt_out</span><span class="p">)</span>
    <span class="n">arr_bytes</span> <span class="o">=</span> <span class="n">arr_bytes</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">arr_bytes</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,))</span>
  <span class="k">if</span> <span class="n">dtype</span> <span class="o">==</span> <span class="n">bool_</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">bitcast_convert_type</span><span class="p">(</span><span class="n">arr_bytes</span><span class="p">,</span> <span class="n">uint8</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">bitcast_convert_type</span><span class="p">(</span><span class="n">arr_bytes</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>

<span class="c1">### track unimplemented functions</span>

<span class="n">_NOT_IMPLEMENTED_DESC</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">*** This function is not yet implemented by jax.numpy, and will raise NotImplementedError ***</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="k">def</span> <span class="nf">_not_implemented</span><span class="p">(</span><span class="n">fun</span><span class="p">):</span>
  <span class="nd">@_wraps</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">update_doc</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_NOT_IMPLEMENTED_DESC</span><span class="p">)</span>
  <span class="k">def</span> <span class="nf">wrapped</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Numpy function </span><span class="si">{}</span><span class="s2"> not yet implemented&quot;</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fun</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">wrapped</span>


<span class="c1">### add method and operator overloads to arraylike classes</span>

<span class="c1"># We add operator overloads to DeviceArray and ShapedArray. These method and</span>
<span class="c1"># operator overloads mainly just forward calls to the corresponding lax_numpy</span>
<span class="c1"># functions, which can themselves handle instances from any of these classes.</span>

<span class="n">_scalar_types</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">complex</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">generic</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_defer_to_unrecognized_arg</span><span class="p">(</span><span class="n">binary_op</span><span class="p">):</span>
  <span class="c1"># Ensure that other array types have the chance to override arithmetic.</span>
  <span class="k">def</span> <span class="nf">deferring_binary_op</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">_scalar_types</span> <span class="o">+</span> <span class="n">_arraylike_types</span> <span class="o">+</span> <span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">Tracer</span><span class="p">,)):</span>
      <span class="k">return</span> <span class="bp">NotImplemented</span>
    <span class="k">return</span> <span class="n">binary_op</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">deferring_binary_op</span>

<span class="k">def</span> <span class="nf">_swap_args</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
  <span class="k">return</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_unimplemented_setitem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
  <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;&#39;</span><span class="si">{}</span><span class="s2">&#39; object does not support item assignment. JAX arrays are &quot;</span>
         <span class="s2">&quot;immutable; perhaps you want jax.ops.index_update or &quot;</span>
         <span class="s2">&quot;jax.ops.index_add instead?&quot;</span><span class="p">)</span>
  <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span>

<span class="k">def</span> <span class="nf">_operator_round</span><span class="p">(</span><span class="n">number</span><span class="p">,</span> <span class="n">ndigits</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="n">out</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">number</span><span class="p">,</span> <span class="n">decimals</span><span class="o">=</span><span class="n">ndigits</span> <span class="ow">or</span> <span class="mi">0</span><span class="p">)</span>
  <span class="c1"># If `ndigits` is None, for a builtin float round(7.5) returns an integer.</span>
  <span class="k">return</span> <span class="n">out</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="k">if</span> <span class="n">ndigits</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">out</span>

<span class="n">_operators</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;getitem&quot;</span><span class="p">:</span> <span class="n">_rewriting_take</span><span class="p">,</span>
    <span class="s2">&quot;setitem&quot;</span><span class="p">:</span> <span class="n">_unimplemented_setitem</span><span class="p">,</span>
    <span class="s2">&quot;neg&quot;</span><span class="p">:</span> <span class="n">negative</span><span class="p">,</span>
    <span class="s2">&quot;pos&quot;</span><span class="p">:</span> <span class="n">positive</span><span class="p">,</span>
    <span class="s2">&quot;eq&quot;</span><span class="p">:</span> <span class="n">_defer_to_unrecognized_arg</span><span class="p">(</span><span class="n">equal</span><span class="p">),</span>
    <span class="s2">&quot;ne&quot;</span><span class="p">:</span> <span class="n">_defer_to_unrecognized_arg</span><span class="p">(</span><span class="n">not_equal</span><span class="p">),</span>
    <span class="s2">&quot;lt&quot;</span><span class="p">:</span> <span class="n">_defer_to_unrecognized_arg</span><span class="p">(</span><span class="n">less</span><span class="p">),</span>
    <span class="s2">&quot;le&quot;</span><span class="p">:</span> <span class="n">_defer_to_unrecognized_arg</span><span class="p">(</span><span class="n">less_equal</span><span class="p">),</span>
    <span class="s2">&quot;gt&quot;</span><span class="p">:</span> <span class="n">_defer_to_unrecognized_arg</span><span class="p">(</span><span class="n">greater</span><span class="p">),</span>
    <span class="s2">&quot;ge&quot;</span><span class="p">:</span> <span class="n">_defer_to_unrecognized_arg</span><span class="p">(</span><span class="n">greater_equal</span><span class="p">),</span>
    <span class="s2">&quot;abs&quot;</span><span class="p">:</span> <span class="nb">abs</span><span class="p">,</span>
    <span class="s2">&quot;add&quot;</span><span class="p">:</span> <span class="n">_defer_to_unrecognized_arg</span><span class="p">(</span><span class="n">add</span><span class="p">),</span>
    <span class="s2">&quot;radd&quot;</span><span class="p">:</span> <span class="n">_defer_to_unrecognized_arg</span><span class="p">(</span><span class="n">add</span><span class="p">),</span>
    <span class="s2">&quot;sub&quot;</span><span class="p">:</span> <span class="n">_defer_to_unrecognized_arg</span><span class="p">(</span><span class="n">subtract</span><span class="p">),</span>
    <span class="s2">&quot;rsub&quot;</span><span class="p">:</span> <span class="n">_defer_to_unrecognized_arg</span><span class="p">(</span><span class="n">_swap_args</span><span class="p">(</span><span class="n">subtract</span><span class="p">)),</span>
    <span class="s2">&quot;mul&quot;</span><span class="p">:</span> <span class="n">_defer_to_unrecognized_arg</span><span class="p">(</span><span class="n">multiply</span><span class="p">),</span>
    <span class="s2">&quot;rmul&quot;</span><span class="p">:</span> <span class="n">_defer_to_unrecognized_arg</span><span class="p">(</span><span class="n">multiply</span><span class="p">),</span>
    <span class="s2">&quot;div&quot;</span><span class="p">:</span> <span class="n">_defer_to_unrecognized_arg</span><span class="p">(</span><span class="n">divide</span><span class="p">),</span>
    <span class="s2">&quot;rdiv&quot;</span><span class="p">:</span> <span class="n">_defer_to_unrecognized_arg</span><span class="p">(</span><span class="n">_swap_args</span><span class="p">(</span><span class="n">divide</span><span class="p">)),</span>
    <span class="s2">&quot;truediv&quot;</span><span class="p">:</span> <span class="n">_defer_to_unrecognized_arg</span><span class="p">(</span><span class="n">true_divide</span><span class="p">),</span>
    <span class="s2">&quot;rtruediv&quot;</span><span class="p">:</span> <span class="n">_defer_to_unrecognized_arg</span><span class="p">(</span><span class="n">_swap_args</span><span class="p">(</span><span class="n">true_divide</span><span class="p">)),</span>
    <span class="s2">&quot;floordiv&quot;</span><span class="p">:</span> <span class="n">_defer_to_unrecognized_arg</span><span class="p">(</span><span class="n">floor_divide</span><span class="p">),</span>
    <span class="s2">&quot;rfloordiv&quot;</span><span class="p">:</span> <span class="n">_defer_to_unrecognized_arg</span><span class="p">(</span><span class="n">_swap_args</span><span class="p">(</span><span class="n">floor_divide</span><span class="p">)),</span>
    <span class="s2">&quot;divmod&quot;</span><span class="p">:</span> <span class="n">_defer_to_unrecognized_arg</span><span class="p">(</span><span class="nb">divmod</span><span class="p">),</span>
    <span class="s2">&quot;rdivmod&quot;</span><span class="p">:</span> <span class="n">_defer_to_unrecognized_arg</span><span class="p">(</span><span class="n">_swap_args</span><span class="p">(</span><span class="nb">divmod</span><span class="p">)),</span>
    <span class="s2">&quot;mod&quot;</span><span class="p">:</span> <span class="n">_defer_to_unrecognized_arg</span><span class="p">(</span><span class="n">mod</span><span class="p">),</span>
    <span class="s2">&quot;rmod&quot;</span><span class="p">:</span> <span class="n">_defer_to_unrecognized_arg</span><span class="p">(</span><span class="n">_swap_args</span><span class="p">(</span><span class="n">mod</span><span class="p">)),</span>
    <span class="s2">&quot;pow&quot;</span><span class="p">:</span> <span class="n">_defer_to_unrecognized_arg</span><span class="p">(</span><span class="n">power</span><span class="p">),</span>
    <span class="s2">&quot;rpow&quot;</span><span class="p">:</span> <span class="n">_defer_to_unrecognized_arg</span><span class="p">(</span><span class="n">_swap_args</span><span class="p">(</span><span class="n">power</span><span class="p">)),</span>
    <span class="s2">&quot;matmul&quot;</span><span class="p">:</span> <span class="n">_defer_to_unrecognized_arg</span><span class="p">(</span><span class="n">matmul</span><span class="p">),</span>
    <span class="s2">&quot;rmatmul&quot;</span><span class="p">:</span> <span class="n">_defer_to_unrecognized_arg</span><span class="p">(</span><span class="n">_swap_args</span><span class="p">(</span><span class="n">matmul</span><span class="p">)),</span>
    <span class="s2">&quot;and&quot;</span><span class="p">:</span> <span class="n">_defer_to_unrecognized_arg</span><span class="p">(</span><span class="n">bitwise_and</span><span class="p">),</span>
    <span class="s2">&quot;rand&quot;</span><span class="p">:</span> <span class="n">_defer_to_unrecognized_arg</span><span class="p">(</span><span class="n">bitwise_and</span><span class="p">),</span>
    <span class="s2">&quot;or&quot;</span><span class="p">:</span> <span class="n">_defer_to_unrecognized_arg</span><span class="p">(</span><span class="n">bitwise_or</span><span class="p">),</span>
    <span class="s2">&quot;ror&quot;</span><span class="p">:</span> <span class="n">_defer_to_unrecognized_arg</span><span class="p">(</span><span class="n">bitwise_or</span><span class="p">),</span>
    <span class="s2">&quot;xor&quot;</span><span class="p">:</span> <span class="n">_defer_to_unrecognized_arg</span><span class="p">(</span><span class="n">bitwise_xor</span><span class="p">),</span>
    <span class="s2">&quot;rxor&quot;</span><span class="p">:</span> <span class="n">_defer_to_unrecognized_arg</span><span class="p">(</span><span class="n">bitwise_xor</span><span class="p">),</span>
    <span class="s2">&quot;invert&quot;</span><span class="p">:</span> <span class="n">bitwise_not</span><span class="p">,</span>
    <span class="s2">&quot;lshift&quot;</span><span class="p">:</span> <span class="n">_defer_to_unrecognized_arg</span><span class="p">(</span><span class="n">left_shift</span><span class="p">),</span>
    <span class="s2">&quot;rshift&quot;</span><span class="p">:</span> <span class="n">_defer_to_unrecognized_arg</span><span class="p">(</span><span class="n">right_shift</span><span class="p">),</span>
    <span class="s2">&quot;rlshift&quot;</span><span class="p">:</span> <span class="n">_defer_to_unrecognized_arg</span><span class="p">(</span><span class="n">_swap_args</span><span class="p">(</span><span class="n">left_shift</span><span class="p">)),</span>
    <span class="s2">&quot;rrshift&quot;</span><span class="p">:</span> <span class="n">_defer_to_unrecognized_arg</span><span class="p">(</span><span class="n">_swap_args</span><span class="p">(</span><span class="n">right_shift</span><span class="p">)),</span>
    <span class="s2">&quot;round&quot;</span><span class="p">:</span> <span class="n">_operator_round</span><span class="p">,</span>
<span class="p">}</span>

<span class="c1"># These numpy.ndarray methods are just refs to an equivalent numpy function</span>
<span class="n">_nondiff_methods</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;all&quot;</span><span class="p">,</span> <span class="s2">&quot;any&quot;</span><span class="p">,</span> <span class="s2">&quot;argmax&quot;</span><span class="p">,</span> <span class="s2">&quot;argmin&quot;</span><span class="p">,</span> <span class="s2">&quot;argpartition&quot;</span><span class="p">,</span> <span class="s2">&quot;argsort&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;nonzero&quot;</span><span class="p">,</span> <span class="s2">&quot;searchsorted&quot;</span><span class="p">,</span> <span class="s2">&quot;round&quot;</span><span class="p">]</span>
<span class="n">_diff_methods</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;clip&quot;</span><span class="p">,</span> <span class="s2">&quot;conj&quot;</span><span class="p">,</span> <span class="s2">&quot;conjugate&quot;</span><span class="p">,</span> <span class="s2">&quot;cumprod&quot;</span><span class="p">,</span> <span class="s2">&quot;cumsum&quot;</span><span class="p">,</span>
                 <span class="s2">&quot;diagonal&quot;</span><span class="p">,</span> <span class="s2">&quot;dot&quot;</span><span class="p">,</span> <span class="s2">&quot;max&quot;</span><span class="p">,</span> <span class="s2">&quot;mean&quot;</span><span class="p">,</span> <span class="s2">&quot;min&quot;</span><span class="p">,</span> <span class="s2">&quot;prod&quot;</span><span class="p">,</span> <span class="s2">&quot;ptp&quot;</span><span class="p">,</span>
                 <span class="s2">&quot;ravel&quot;</span><span class="p">,</span> <span class="s2">&quot;repeat&quot;</span><span class="p">,</span> <span class="s2">&quot;sort&quot;</span><span class="p">,</span> <span class="s2">&quot;squeeze&quot;</span><span class="p">,</span> <span class="s2">&quot;std&quot;</span><span class="p">,</span> <span class="s2">&quot;sum&quot;</span><span class="p">,</span>
                 <span class="s2">&quot;swapaxes&quot;</span><span class="p">,</span> <span class="s2">&quot;take&quot;</span><span class="p">,</span> <span class="s2">&quot;tile&quot;</span><span class="p">,</span> <span class="s2">&quot;trace&quot;</span><span class="p">,</span> <span class="s2">&quot;transpose&quot;</span><span class="p">,</span> <span class="s2">&quot;var&quot;</span><span class="p">]</span>

<span class="c1"># These methods are mentioned explicitly by nondiff_methods, so we create</span>
<span class="c1"># _not_implemented implementations of them here rather than in __init__.py.</span>
<span class="c1"># TODO(phawkins): implement these.</span>
<span class="n">argpartition</span> <span class="o">=</span> <span class="n">_not_implemented</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argpartition</span><span class="p">)</span>
<span class="n">_NOT_IMPLEMENTED</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;argpartition&#39;</span><span class="p">]</span>

<span class="c1"># Set up operator, method, and property forwarding on Tracer instances containing</span>
<span class="c1"># ShapedArray avals by following the forwarding conventions for Tracer.</span>
<span class="c1"># Forward operators using a single-underscore-prefix naming convention:</span>
<span class="k">for</span> <span class="n">operator_name</span><span class="p">,</span> <span class="n">function</span> <span class="ow">in</span> <span class="n">_operators</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
  <span class="nb">setattr</span><span class="p">(</span><span class="n">ShapedArray</span><span class="p">,</span> <span class="s2">&quot;_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">operator_name</span><span class="p">),</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">function</span><span class="p">))</span>
<span class="c1"># Forward methods and properties using core.aval_method and core.aval_property:</span>
<span class="k">for</span> <span class="n">method_name</span> <span class="ow">in</span> <span class="n">_nondiff_methods</span> <span class="o">+</span> <span class="n">_diff_methods</span><span class="p">:</span>
  <span class="nb">setattr</span><span class="p">(</span><span class="n">ShapedArray</span><span class="p">,</span> <span class="n">method_name</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">aval_method</span><span class="p">(</span><span class="nb">globals</span><span class="p">()[</span><span class="n">method_name</span><span class="p">]))</span>
<span class="nb">setattr</span><span class="p">(</span><span class="n">ShapedArray</span><span class="p">,</span> <span class="s2">&quot;reshape&quot;</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">aval_method</span><span class="p">(</span><span class="n">_reshape</span><span class="p">))</span>
<span class="nb">setattr</span><span class="p">(</span><span class="n">ShapedArray</span><span class="p">,</span> <span class="s2">&quot;flatten&quot;</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">aval_method</span><span class="p">(</span><span class="n">ravel</span><span class="p">))</span>
<span class="nb">setattr</span><span class="p">(</span><span class="n">ShapedArray</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">aval_property</span><span class="p">(</span><span class="n">transpose</span><span class="p">))</span>
<span class="nb">setattr</span><span class="p">(</span><span class="n">ShapedArray</span><span class="p">,</span> <span class="s2">&quot;real&quot;</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">aval_property</span><span class="p">(</span><span class="n">real</span><span class="p">))</span>
<span class="nb">setattr</span><span class="p">(</span><span class="n">ShapedArray</span><span class="p">,</span> <span class="s2">&quot;imag&quot;</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">aval_property</span><span class="p">(</span><span class="n">imag</span><span class="p">))</span>
<span class="nb">setattr</span><span class="p">(</span><span class="n">ShapedArray</span><span class="p">,</span> <span class="s2">&quot;astype&quot;</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">aval_method</span><span class="p">(</span><span class="n">_astype</span><span class="p">))</span>
<span class="nb">setattr</span><span class="p">(</span><span class="n">ShapedArray</span><span class="p">,</span> <span class="s2">&quot;view&quot;</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">aval_method</span><span class="p">(</span><span class="n">_view</span><span class="p">))</span>
<span class="nb">setattr</span><span class="p">(</span><span class="n">ShapedArray</span><span class="p">,</span> <span class="s2">&quot;nbytes&quot;</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">aval_property</span><span class="p">(</span><span class="n">_nbytes</span><span class="p">))</span>


<span class="c1"># Forward operators, methods, and properties on DeviceArray to lax_numpy</span>
<span class="c1"># functions (with no Tracers involved; this forwarding is direct)</span>
<span class="k">for</span> <span class="n">device_array</span> <span class="ow">in</span> <span class="p">[</span><span class="n">_DeviceArray</span><span class="p">,</span> <span class="n">_CppDeviceArray</span><span class="p">]:</span>
  <span class="k">for</span> <span class="n">operator_name</span><span class="p">,</span> <span class="n">function</span> <span class="ow">in</span> <span class="n">_operators</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="nb">setattr</span><span class="p">(</span><span class="n">device_array</span><span class="p">,</span> <span class="s2">&quot;__</span><span class="si">{}</span><span class="s2">__&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">operator_name</span><span class="p">),</span> <span class="n">function</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">method_name</span> <span class="ow">in</span> <span class="n">_nondiff_methods</span> <span class="o">+</span> <span class="n">_diff_methods</span><span class="p">:</span>
    <span class="nb">setattr</span><span class="p">(</span><span class="n">device_array</span><span class="p">,</span> <span class="n">method_name</span><span class="p">,</span> <span class="nb">globals</span><span class="p">()[</span><span class="n">method_name</span><span class="p">])</span>
  <span class="nb">setattr</span><span class="p">(</span><span class="n">device_array</span><span class="p">,</span> <span class="s2">&quot;reshape&quot;</span><span class="p">,</span> <span class="n">_reshape</span><span class="p">)</span>
  <span class="nb">setattr</span><span class="p">(</span><span class="n">device_array</span><span class="p">,</span> <span class="s2">&quot;flatten&quot;</span><span class="p">,</span> <span class="n">ravel</span><span class="p">)</span>
  <span class="nb">setattr</span><span class="p">(</span><span class="n">device_array</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="nb">property</span><span class="p">(</span><span class="n">transpose</span><span class="p">))</span>
  <span class="nb">setattr</span><span class="p">(</span><span class="n">device_array</span><span class="p">,</span> <span class="s2">&quot;real&quot;</span><span class="p">,</span> <span class="nb">property</span><span class="p">(</span><span class="n">real</span><span class="p">))</span>
  <span class="nb">setattr</span><span class="p">(</span><span class="n">device_array</span><span class="p">,</span> <span class="s2">&quot;imag&quot;</span><span class="p">,</span> <span class="nb">property</span><span class="p">(</span><span class="n">imag</span><span class="p">))</span>
  <span class="nb">setattr</span><span class="p">(</span><span class="n">device_array</span><span class="p">,</span> <span class="s2">&quot;astype&quot;</span><span class="p">,</span> <span class="n">_astype</span><span class="p">)</span>
  <span class="nb">setattr</span><span class="p">(</span><span class="n">device_array</span><span class="p">,</span> <span class="s2">&quot;view&quot;</span><span class="p">,</span> <span class="n">_view</span><span class="p">)</span>
  <span class="nb">setattr</span><span class="p">(</span><span class="n">device_array</span><span class="p">,</span> <span class="s2">&quot;nbytes&quot;</span><span class="p">,</span> <span class="nb">property</span><span class="p">(</span><span class="n">_nbytes</span><span class="p">))</span>


<span class="c1"># Experimental support for NumPy&#39;s module dispatch with NEP-37.</span>
<span class="c1"># Currently requires https://github.com/seberg/numpy-dispatch</span>
<span class="n">_JAX_ARRAY_TYPES</span> <span class="o">=</span> <span class="p">(</span><span class="n">DeviceArray</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Tracer</span><span class="p">)</span>
<span class="n">_HANDLED_ARRAY_TYPES</span> <span class="o">=</span> <span class="n">_JAX_ARRAY_TYPES</span> <span class="o">+</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,)</span>

<span class="k">def</span> <span class="nf">__array_module__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">types</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">builtins</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="nb">issubclass</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">_HANDLED_ARRAY_TYPES</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">types</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">jax</span><span class="o">.</span><span class="n">numpy</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="bp">NotImplemented</span>

<span class="nb">setattr</span><span class="p">(</span><span class="n">ShapedArray</span><span class="p">,</span> <span class="s2">&quot;_array_module&quot;</span><span class="p">,</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">__array_module__</span><span class="p">))</span>
<span class="nb">setattr</span><span class="p">(</span><span class="n">_DeviceArray</span><span class="p">,</span> <span class="s2">&quot;__array_module__&quot;</span><span class="p">,</span> <span class="n">__array_module__</span><span class="p">)</span>
<span class="nb">setattr</span><span class="p">(</span><span class="n">_CppDeviceArray</span><span class="p">,</span> <span class="s2">&quot;__array_module__&quot;</span><span class="p">,</span> <span class="n">__array_module__</span><span class="p">)</span>


<span class="c1"># Extra methods that are handy</span>
<span class="nb">setattr</span><span class="p">(</span><span class="n">ShapedArray</span><span class="p">,</span> <span class="s2">&quot;broadcast&quot;</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">aval_method</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">broadcast</span><span class="p">))</span>
<span class="nb">setattr</span><span class="p">(</span><span class="n">ShapedArray</span><span class="p">,</span> <span class="s2">&quot;broadcast_in_dim&quot;</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">aval_method</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">broadcast_in_dim</span><span class="p">))</span>
<span class="nb">setattr</span><span class="p">(</span><span class="n">ShapedArray</span><span class="p">,</span> <span class="s2">&quot;split&quot;</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">aval_method</span><span class="p">(</span><span class="n">split</span><span class="p">))</span>
<span class="k">for</span> <span class="n">device_array</span> <span class="ow">in</span> <span class="p">[</span><span class="n">_DeviceArray</span><span class="p">,</span> <span class="n">_CppDeviceArray</span><span class="p">]:</span>
  <span class="nb">setattr</span><span class="p">(</span><span class="n">device_array</span><span class="p">,</span> <span class="s2">&quot;broadcast&quot;</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">broadcast</span><span class="p">)</span>
  <span class="nb">setattr</span><span class="p">(</span><span class="n">device_array</span><span class="p">,</span> <span class="s2">&quot;broadcast_in_dim&quot;</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">broadcast_in_dim</span><span class="p">)</span>
  <span class="nb">setattr</span><span class="p">(</span><span class="n">device_array</span><span class="p">,</span> <span class="s2">&quot;split&quot;</span><span class="p">,</span> <span class="n">split</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_compress_method</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">condition</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">compress</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>

<span class="nb">setattr</span><span class="p">(</span><span class="n">ShapedArray</span><span class="p">,</span> <span class="s2">&quot;compress&quot;</span><span class="p">,</span> <span class="n">_compress_method</span><span class="p">)</span>
<span class="nb">setattr</span><span class="p">(</span><span class="n">_DeviceArray</span><span class="p">,</span> <span class="s2">&quot;compress&quot;</span><span class="p">,</span> <span class="n">_compress_method</span><span class="p">)</span>
<span class="nb">setattr</span><span class="p">(</span><span class="n">_CppDeviceArray</span><span class="p">,</span> <span class="s2">&quot;compress&quot;</span><span class="p">,</span> <span class="n">_compress_method</span><span class="p">)</span>

<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnums</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">_multi_slice</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span>
                 <span class="n">start_indices</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]],</span>
                 <span class="n">limit_indices</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]],</span>
                 <span class="n">removed_dims</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]]):</span>
  <span class="sd">&quot;&quot;&quot;Extracts multiple slices from `arr`.</span>

<span class="sd">  This is used to shard DeviceArray arguments to pmap. It&#39;s implemented as a</span>
<span class="sd">  DeviceArray method here to avoid circular imports.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">for</span> <span class="n">starts</span><span class="p">,</span> <span class="n">limits</span><span class="p">,</span> <span class="n">removed</span> <span class="ow">in</span> <span class="n">safe_zip</span><span class="p">(</span><span class="n">start_indices</span><span class="p">,</span> <span class="n">limit_indices</span><span class="p">,</span> <span class="n">removed_dims</span><span class="p">):</span>
    <span class="n">sliced</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">starts</span><span class="p">,</span> <span class="n">limits</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">removed</span><span class="p">:</span>
      <span class="n">sliced</span> <span class="o">=</span> <span class="n">sliced</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">sliced</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">removed_dims</span><span class="p">))</span>
    <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sliced</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">results</span>
<span class="nb">setattr</span><span class="p">(</span><span class="n">_DeviceArray</span><span class="p">,</span> <span class="s2">&quot;_multi_slice&quot;</span><span class="p">,</span> <span class="n">_multi_slice</span><span class="p">)</span>
<span class="nb">setattr</span><span class="p">(</span><span class="n">_CppDeviceArray</span><span class="p">,</span> <span class="s2">&quot;_multi_slice&quot;</span><span class="p">,</span> <span class="n">_multi_slice</span><span class="p">)</span>


<span class="c1"># Syntactic sugar for scatter operations.</span>
<span class="k">class</span> <span class="nc">_IndexUpdateHelper</span><span class="p">:</span>
  <span class="c1"># Note: this docstring will appear as the docstring for the `at` property.</span>
  <span class="sd">&quot;&quot;&quot;Indexable helper object to call indexed update functions.</span>

<span class="sd">  The `at` property is syntactic sugar for calling the indexed update functions</span>
<span class="sd">  defined in :mod:`jax.ops`, and acts as a pure equivalent of in-place</span>
<span class="sd">  modificatons.</span>

<span class="sd">  In particular:</span>
<span class="sd">  - ``x = x.at[idx].set(y)`` is a pure equivalent of ``x[idx] = y``.</span>
<span class="sd">  - ``x = x.at[idx].add(y)`` is a pure equivalent of ``x[idx] += y``.</span>
<span class="sd">  - ``x = x.at[idx].mul(y)`` is a pure equivalent of ``x[idx] *= y``.</span>
<span class="sd">  - ``x = x.at[idx].min(y)`` is a pure equivalent of</span>
<span class="sd">      ``x[idx] = minimum(x[idx], y)``.</span>
<span class="sd">  - ``x = x.at[idx].max(y)`` is a pure equivalent of</span>
<span class="sd">      ``x[idx] = maximum(x[idx], y)``.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;array&quot;</span><span class="p">,)</span>

  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">array</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">array</span> <span class="o">=</span> <span class="n">array</span>

  <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">_IndexUpdateRef</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

  <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;_IndexUpdateHelper(</span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span>


<span class="k">class</span> <span class="nc">_IndexUpdateRef</span><span class="p">:</span>
  <span class="sd">&quot;&quot;&quot;Helper object to call indexed update functions for an (advanced) index.</span>

<span class="sd">  This object references a source array and a specific indexer into that array.</span>
<span class="sd">  Methods on this object return copies of the source array that have been</span>
<span class="sd">  modified at the positions specified by the indexer.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;array&quot;</span><span class="p">,</span> <span class="s2">&quot;index&quot;</span><span class="p">)</span>

  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">array</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">array</span> <span class="o">=</span> <span class="n">array</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">index</span>

  <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;_IndexUpdateRef(</span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">)</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span>

  <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">indices_are_sorted</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">unique_indices</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Pure equivalent of ``x[idx] = y``.</span>

<span class="sd">    ``x.at[idx].set(y)`` is syntactic sugar for</span>
<span class="sd">    ``jax.ops.index_update(x, jax.ops.index[idx], y)``, and</span>
<span class="sd">    returns the value of ``x`` that would result from the NumPy-style</span>
<span class="sd">    :mod:indexed assignment &lt;numpy.doc.indexing&gt;` ``x[idx] = y``.</span>

<span class="sd">    See :mod:`jax.ops` for details.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ops</span><span class="o">.</span><span class="n">index_update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span>
                            <span class="n">indices_are_sorted</span><span class="o">=</span><span class="n">indices_are_sorted</span><span class="p">,</span>
                            <span class="n">unique_indices</span><span class="o">=</span><span class="n">unique_indices</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">indices_are_sorted</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">unique_indices</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Pure equivalent of ``x[idx] += y``.</span>

<span class="sd">    ``x.at[idx].add(y)`` is syntactic sugar for</span>
<span class="sd">    ``jax.ops.index_add(x, jax.ops.index[idx], y)``, and</span>
<span class="sd">    returns the value of ``x`` that would result from the NumPy-style</span>
<span class="sd">    :mod:indexed assignment &lt;numpy.doc.indexing&gt;` ``x[idx] += y``.</span>

<span class="sd">    See :mod:`jax.ops` for details.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ops</span><span class="o">.</span><span class="n">index_add</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span>
                         <span class="n">indices_are_sorted</span><span class="o">=</span><span class="n">indices_are_sorted</span><span class="p">,</span>
                         <span class="n">unique_indices</span><span class="o">=</span><span class="n">unique_indices</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">mul</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">indices_are_sorted</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">unique_indices</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Pure equivalent of ``x[idx] += y``.</span>

<span class="sd">    ``x.at[idx].mul(y)`` is syntactic sugar for</span>
<span class="sd">    ``jax.ops.index_mul(x, jax.ops.index[idx], y)``, and</span>
<span class="sd">    returns the value of ``x`` that would result from the NumPy-style</span>
<span class="sd">    :mod:indexed assignment &lt;numpy.doc.indexing&gt;` ``x[idx] *= y``.</span>

<span class="sd">    See :mod:`jax.ops` for details.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ops</span><span class="o">.</span><span class="n">index_mul</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span>
                         <span class="n">indices_are_sorted</span><span class="o">=</span><span class="n">indices_are_sorted</span><span class="p">,</span>
                         <span class="n">unique_indices</span><span class="o">=</span><span class="n">unique_indices</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">min</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">indices_are_sorted</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">unique_indices</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Pure equivalent of ``x[idx] = minimum(x[idx], y)``.</span>

<span class="sd">    ``x.at[idx].min(y)`` is syntactic sugar for</span>
<span class="sd">    ``jax.ops.index_min(x, jax.ops.index[idx], y)``, and</span>
<span class="sd">    returns the value of ``x`` that would result from the NumPy-style</span>
<span class="sd">    :mod:indexed assignment &lt;numpy.doc.indexing&gt;`</span>
<span class="sd">    ``x[idx] = minimum(x[idx], y)``.</span>

<span class="sd">    See :mod:`jax.ops` for details.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ops</span><span class="o">.</span><span class="n">index_min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span>
                         <span class="n">indices_are_sorted</span><span class="o">=</span><span class="n">indices_are_sorted</span><span class="p">,</span>
                         <span class="n">unique_indices</span><span class="o">=</span><span class="n">unique_indices</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">max</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">indices_are_sorted</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">unique_indices</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Pure equivalent of ``x[idx] = maximum(x[idx], y)``.</span>

<span class="sd">    ``x.at[idx].max(y)`` is syntactic sugar for</span>
<span class="sd">    ``jax.ops.index_max(x, jax.ops.index[idx], y)``, and</span>
<span class="sd">    returns the value of ``x`` that would result from the NumPy-style</span>
<span class="sd">    :mod:indexed assignment &lt;numpy.doc.indexing&gt;`</span>
<span class="sd">    ``x[idx] = maximum(x[idx], y)``.</span>

<span class="sd">    See :mod:`jax.ops` for details.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ops</span><span class="o">.</span><span class="n">index_max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span>
                         <span class="n">indices_are_sorted</span><span class="o">=</span><span class="n">indices_are_sorted</span><span class="p">,</span>
                         <span class="n">unique_indices</span><span class="o">=</span><span class="n">unique_indices</span><span class="p">)</span>

<span class="nb">setattr</span><span class="p">(</span><span class="n">_DeviceArray</span><span class="p">,</span> <span class="s2">&quot;at&quot;</span><span class="p">,</span> <span class="nb">property</span><span class="p">(</span><span class="n">_IndexUpdateHelper</span><span class="p">))</span>
<span class="nb">setattr</span><span class="p">(</span><span class="n">_CppDeviceArray</span><span class="p">,</span> <span class="s2">&quot;at&quot;</span><span class="p">,</span> <span class="nb">property</span><span class="p">(</span><span class="n">_IndexUpdateHelper</span><span class="p">))</span>
<span class="nb">setattr</span><span class="p">(</span><span class="n">ShapedArray</span><span class="p">,</span> <span class="s2">&quot;at&quot;</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">aval_property</span><span class="p">(</span><span class="n">_IndexUpdateHelper</span><span class="p">))</span>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2020.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>